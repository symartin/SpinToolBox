<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SpinToolBox: D:/Sylvain/Instru/SpinToolBox V2.6/src/SDK/SDK/SPlot/qcustomplot.cpp Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../compass64.png"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SpinToolBox&#160;<span id="projectnumber">2.6</span></div>
   <div id="projectbrief">Automatize the measurement process in the characterization of the magnetic tunnel junction</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>D:/Sylvain/Instru/SpinToolBox V2.6/src/SDK/SDK/SPlot/qcustomplot.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">**                                                                        **</span>
<a name="l00003"></a>00003 <span class="comment">**  QCustomPlot, a simple to use, modern plotting widget for Qt           **</span>
<a name="l00004"></a>00004 <span class="comment">**  Copyright (C) 2012 Emanuel Eichhammer                                 **</span>
<a name="l00005"></a>00005 <span class="comment">**                                                                        **</span>
<a name="l00006"></a>00006 <span class="comment">**  This program is free software: you can redistribute it and/or modify  **</span>
<a name="l00007"></a>00007 <span class="comment">**  it under the terms of the GNU General Public License as published by  **</span>
<a name="l00008"></a>00008 <span class="comment">**  the Free Software Foundation, either version 3 of the License, or     **</span>
<a name="l00009"></a>00009 <span class="comment">**  (at your option) any later version.                                   **</span>
<a name="l00010"></a>00010 <span class="comment">**                                                                        **</span>
<a name="l00011"></a>00011 <span class="comment">**  This program is distributed in the hope that it will be useful,       **</span>
<a name="l00012"></a>00012 <span class="comment">**  but WITHOUT ANY WARRANTY; without even the implied warranty of        **</span>
<a name="l00013"></a>00013 <span class="comment">**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **</span>
<a name="l00014"></a>00014 <span class="comment">**  GNU General Public License for more details.                          **</span>
<a name="l00015"></a>00015 <span class="comment">**                                                                        **</span>
<a name="l00016"></a>00016 <span class="comment">**  You should have received a copy of the GNU General Public License     **</span>
<a name="l00017"></a>00017 <span class="comment">**  along with this program.  If not, see http://www.gnu.org/licenses/.   **</span>
<a name="l00018"></a>00018 <span class="comment">**                                                                        **</span>
<a name="l00019"></a>00019 <span class="comment">****************************************************************************</span>
<a name="l00020"></a>00020 <span class="comment">**           Author: Emanuel Eichhammer                                   **</span>
<a name="l00021"></a>00021 <span class="comment">**  Website/Contact: http://www.WorksLikeClockwork.com/                   **</span>
<a name="l00022"></a>00022 <span class="comment">**             Date: 31.03.12                                             **</span>
<a name="l00023"></a>00023 <span class="comment">****************************************************************************/</span>
<a name="l00024"></a>00024 
<a name="l00148"></a>00148 <span class="preprocessor">#include &quot;<a class="code" href="../../d7/dd3/qcustomplot_8h.html">qcustomplot.h</a>&quot;</span>
<a name="l00149"></a>00149 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00150"></a>00150 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="comment">// ================================================================================</span>
<a name="l00153"></a>00153 <span class="comment">// =================== QCPData</span>
<a name="l00154"></a>00154 <span class="comment">// ================================================================================</span>
<a name="l00155"></a>00155 
<a name="l00173"></a>00173 QCPData::QCPData() :
<a name="l00174"></a>00174   key(0),
<a name="l00175"></a>00175   value(0),
<a name="l00176"></a>00176   keyErrorPlus(0),
<a name="l00177"></a>00177   keyErrorMinus(0),
<a name="l00178"></a>00178   valueErrorPlus(0),
<a name="l00179"></a>00179   valueErrorMinus(0)
<a name="l00180"></a>00180 {
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="comment">// ================================================================================</span>
<a name="l00184"></a>00184 <span class="comment">// =================== QCPCurveData</span>
<a name="l00185"></a>00185 <span class="comment">// ================================================================================</span>
<a name="l00186"></a>00186 
<a name="l00201"></a>00201 QCPCurveData::QCPCurveData() :
<a name="l00202"></a>00202   t(0),
<a name="l00203"></a>00203   key(0),
<a name="l00204"></a>00204   value(0)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="comment">// ================================================================================</span>
<a name="l00210"></a>00210 <span class="comment">// =================== QCPBarData</span>
<a name="l00211"></a>00211 <span class="comment">// ================================================================================</span>
<a name="l00212"></a>00212 
<a name="l00226"></a>00226 QCPBarData::QCPBarData() :
<a name="l00227"></a>00227   key(0),
<a name="l00228"></a>00228   value(0)
<a name="l00229"></a>00229 {
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="comment">// ================================================================================</span>
<a name="l00233"></a>00233 <span class="comment">// =================== QCPGraph</span>
<a name="l00234"></a>00234 <span class="comment">// ================================================================================</span>
<a name="l00235"></a>00235 
<a name="l00273"></a>00273 QCPGraph::QCPGraph(QCPAxis *keyAxis, QCPAxis *valueAxis) :
<a name="l00274"></a>00274   QCPAbstractPlottable(keyAxis, valueAxis)
<a name="l00275"></a>00275 {
<a name="l00276"></a>00276   mData = <span class="keyword">new</span> QCPDataMap;
<a name="l00277"></a>00277   
<a name="l00278"></a>00278   mPen.setColor(Qt::blue);
<a name="l00279"></a>00279   mPen.setStyle(Qt::SolidLine);
<a name="l00280"></a>00280   mErrorPen.setColor(Qt::black);
<a name="l00281"></a>00281   mBrush.setColor(Qt::blue);
<a name="l00282"></a>00282   mBrush.setStyle(Qt::NoBrush);
<a name="l00283"></a>00283   mSelectedPen = mPen;
<a name="l00284"></a>00284   mSelectedPen.setWidthF(2.5);
<a name="l00285"></a>00285   mSelectedPen.setColor(QColor(80, 80, 255)); <span class="comment">// lighter than Qt::blue of mPen</span>
<a name="l00286"></a>00286   mSelectedBrush = mBrush;
<a name="l00287"></a>00287   
<a name="l00288"></a>00288   mLineStyle = lsLine;
<a name="l00289"></a>00289   mScatterStyle = ssNone;
<a name="l00290"></a>00290   mScatterSize = 6;
<a name="l00291"></a>00291   mErrorType = etNone;
<a name="l00292"></a>00292   mErrorBarSize = 6;
<a name="l00293"></a>00293   mErrorBarSkipSymbol = <span class="keyword">true</span>;
<a name="l00294"></a>00294   mChannelFillGraph = 0;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296   mBijective = <span class="keyword">false</span>;
<a name="l00297"></a>00297 }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 QCPGraph::~QCPGraph()
<a name="l00300"></a>00300 {
<a name="l00301"></a>00301   <span class="keywordflow">if</span> (mParentPlot)
<a name="l00302"></a>00302   {
<a name="l00303"></a>00303     <span class="comment">// if another graph has a channel fill towards this graph, set it to zero</span>
<a name="l00304"></a>00304     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mParentPlot-&gt;graphCount(); ++i)
<a name="l00305"></a>00305     {
<a name="l00306"></a>00306       <span class="keywordflow">if</span> (mParentPlot-&gt;graph(i)-&gt;channelFillGraph() == <span class="keyword">this</span>)
<a name="l00307"></a>00307         mParentPlot-&gt;graph(i)-&gt;setChannelFillGraph(0);
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309   }
<a name="l00310"></a>00310   <span class="keyword">delete</span> mData;
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 
<a name="l00320"></a>00320 <span class="keywordtype">void</span> QCPGraph::setData(QCPDataMap *data, <span class="keywordtype">bool</span> copy,  <span class="keywordtype">bool</span> bijective)
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322   <span class="keywordflow">if</span> (copy)
<a name="l00323"></a>00323   {
<a name="l00324"></a>00324     *mData = *data;
<a name="l00325"></a>00325   } <span class="keywordflow">else</span>
<a name="l00326"></a>00326   {
<a name="l00327"></a>00327     <span class="keyword">delete</span> mData;
<a name="l00328"></a>00328     mData = data;
<a name="l00329"></a>00329   }
<a name="l00330"></a>00330 }
<a name="l00331"></a>00331 
<a name="l00338"></a>00338 <span class="keywordtype">void</span> QCPGraph::setData(<span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value, <span class="keywordtype">bool</span> bijective)
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340   mData-&gt;clear();
<a name="l00341"></a>00341   <span class="keywordtype">int</span> n = key.size();
<a name="l00342"></a>00342   n = qMin(n, value.size());
<a name="l00343"></a>00343   QCPData newData;
<a name="l00344"></a>00344   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00345"></a>00345   {
<a name="l00346"></a>00346     newData.key = key[i];
<a name="l00347"></a>00347     newData.value = value[i];
<a name="l00348"></a>00348     mData-&gt;insertMulti(newData.key, newData);
<a name="l00349"></a>00349   }
<a name="l00350"></a>00350 }
<a name="l00351"></a>00351 
<a name="l00370"></a>00370 <span class="keywordtype">void</span> QCPGraph::setData(<span class="keyword">const</span> QList&lt;double&gt; &amp;key, <span class="keyword">const</span> QList&lt;double&gt; &amp;value, <span class="keywordtype">bool</span> bijective)
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372      mBijective = bijective;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374      mData-&gt;clear();
<a name="l00375"></a>00375      <span class="keywordtype">int</span> n = key.size();
<a name="l00376"></a>00376      n = qMin(n, value.size());
<a name="l00377"></a>00377      QCPData newData;
<a name="l00378"></a>00378      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00379"></a>00379      {
<a name="l00380"></a>00380           newData.key = key.at(i);
<a name="l00381"></a>00381           newData.value = value.at(i);
<a name="l00382"></a>00382           mData-&gt;insertMulti(bijective?newData.key:i, newData);
<a name="l00383"></a>00383      }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 }
<a name="l00386"></a>00386 
<a name="l00406"></a>00406 <span class="keywordtype">void</span> QCPGraph::setData(<span class="keyword">const</span> QList&lt;double&gt; *key, <span class="keyword">const</span> QList&lt;double&gt; *value, <span class="keywordtype">bool</span> bijective )
<a name="l00407"></a>00407 {
<a name="l00408"></a>00408   mBijective = bijective;
<a name="l00409"></a>00409      
<a name="l00410"></a>00410   mData-&gt;clear();
<a name="l00411"></a>00411   <span class="keywordtype">int</span> n = key-&gt;size();
<a name="l00412"></a>00412   n = qMin(n, value-&gt;size());
<a name="l00413"></a>00413   QCPData newData;
<a name="l00414"></a>00414   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00415"></a>00415   {
<a name="l00416"></a>00416     newData.key = key-&gt;at(i);
<a name="l00417"></a>00417     newData.value = value-&gt;at(i);
<a name="l00418"></a>00418     mData-&gt;insertMulti(bijective?newData.key:i, newData);
<a name="l00419"></a>00419   }
<a name="l00420"></a>00420 }
<a name="l00421"></a>00421 
<a name="l00429"></a>00429 <span class="keywordtype">void</span> QCPGraph::setDataValueError(<span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value, <span class="keyword">const</span> QVector&lt;double&gt; &amp;valueError)
<a name="l00430"></a>00430 {
<a name="l00431"></a>00431   mData-&gt;clear();
<a name="l00432"></a>00432   <span class="keywordtype">int</span> n = key.size();
<a name="l00433"></a>00433   n = qMin(n, value.size());
<a name="l00434"></a>00434   n = qMin(n, valueError.size());
<a name="l00435"></a>00435   QCPData newData;
<a name="l00436"></a>00436   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00437"></a>00437   {
<a name="l00438"></a>00438     newData.key = key[i];
<a name="l00439"></a>00439     newData.value = value[i];
<a name="l00440"></a>00440     newData.valueErrorMinus = valueError[i];
<a name="l00441"></a>00441     newData.valueErrorPlus = valueError[i];
<a name="l00442"></a>00442     mData-&gt;insertMulti(key[i], newData);
<a name="l00443"></a>00443   }
<a name="l00444"></a>00444 }
<a name="l00445"></a>00445 
<a name="l00455"></a>00455 <span class="keywordtype">void</span> QCPGraph::setDataValueError(<span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value, <span class="keyword">const</span> QVector&lt;double&gt; &amp;valueErrorMinus, <span class="keyword">const</span> QVector&lt;double&gt; &amp;valueErrorPlus)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457   mData-&gt;clear();
<a name="l00458"></a>00458   <span class="keywordtype">int</span> n = key.size();
<a name="l00459"></a>00459   n = qMin(n, value.size());
<a name="l00460"></a>00460   n = qMin(n, valueErrorMinus.size());
<a name="l00461"></a>00461   n = qMin(n, valueErrorPlus.size());
<a name="l00462"></a>00462   QCPData newData;
<a name="l00463"></a>00463   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00464"></a>00464   {
<a name="l00465"></a>00465     newData.key = key[i];
<a name="l00466"></a>00466     newData.value = value[i];
<a name="l00467"></a>00467     newData.valueErrorMinus = valueErrorMinus[i];
<a name="l00468"></a>00468     newData.valueErrorPlus = valueErrorPlus[i];
<a name="l00469"></a>00469     mData-&gt;insertMulti(key[i], newData);
<a name="l00470"></a>00470   }
<a name="l00471"></a>00471 }
<a name="l00472"></a>00472 
<a name="l00480"></a>00480 <span class="keywordtype">void</span> QCPGraph::setDataKeyError(<span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value, <span class="keyword">const</span> QVector&lt;double&gt; &amp;keyError)
<a name="l00481"></a>00481 {
<a name="l00482"></a>00482   mData-&gt;clear();
<a name="l00483"></a>00483   <span class="keywordtype">int</span> n = key.size();
<a name="l00484"></a>00484   n = qMin(n, value.size());
<a name="l00485"></a>00485   n = qMin(n, keyError.size());
<a name="l00486"></a>00486   QCPData newData;
<a name="l00487"></a>00487   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00488"></a>00488   {
<a name="l00489"></a>00489     newData.key = key[i];
<a name="l00490"></a>00490     newData.value = value[i];
<a name="l00491"></a>00491     newData.keyErrorMinus = keyError[i];
<a name="l00492"></a>00492     newData.keyErrorPlus = keyError[i];
<a name="l00493"></a>00493     mData-&gt;insertMulti(key[i], newData);
<a name="l00494"></a>00494   }
<a name="l00495"></a>00495 }
<a name="l00496"></a>00496 
<a name="l00506"></a>00506 <span class="keywordtype">void</span> QCPGraph::setDataKeyError(<span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value, <span class="keyword">const</span> QVector&lt;double&gt; &amp;keyErrorMinus, <span class="keyword">const</span> QVector&lt;double&gt; &amp;keyErrorPlus)
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508   mData-&gt;clear();
<a name="l00509"></a>00509   <span class="keywordtype">int</span> n = key.size();
<a name="l00510"></a>00510   n = qMin(n, value.size());
<a name="l00511"></a>00511   n = qMin(n, keyErrorMinus.size());
<a name="l00512"></a>00512   n = qMin(n, keyErrorPlus.size());
<a name="l00513"></a>00513   QCPData newData;
<a name="l00514"></a>00514   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00515"></a>00515   {
<a name="l00516"></a>00516     newData.key = key[i];
<a name="l00517"></a>00517     newData.value = value[i];
<a name="l00518"></a>00518     newData.keyErrorMinus = keyErrorMinus[i];
<a name="l00519"></a>00519     newData.keyErrorPlus = keyErrorPlus[i];
<a name="l00520"></a>00520     mData-&gt;insertMulti(key[i], newData);
<a name="l00521"></a>00521   }
<a name="l00522"></a>00522 }
<a name="l00523"></a>00523 
<a name="l00531"></a>00531 <span class="keywordtype">void</span> QCPGraph::setDataBothError(<span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value, <span class="keyword">const</span> QVector&lt;double&gt; &amp;keyError, <span class="keyword">const</span> QVector&lt;double&gt; &amp;valueError)
<a name="l00532"></a>00532 {
<a name="l00533"></a>00533   mData-&gt;clear();
<a name="l00534"></a>00534   <span class="keywordtype">int</span> n = key.size();
<a name="l00535"></a>00535   n = qMin(n, value.size());
<a name="l00536"></a>00536   n = qMin(n, valueError.size());
<a name="l00537"></a>00537   n = qMin(n, keyError.size());
<a name="l00538"></a>00538   QCPData newData;
<a name="l00539"></a>00539   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00540"></a>00540   {
<a name="l00541"></a>00541     newData.key = key[i];
<a name="l00542"></a>00542     newData.value = value[i];
<a name="l00543"></a>00543     newData.keyErrorMinus = keyError[i];
<a name="l00544"></a>00544     newData.keyErrorPlus = keyError[i];
<a name="l00545"></a>00545     newData.valueErrorMinus = valueError[i];
<a name="l00546"></a>00546     newData.valueErrorPlus = valueError[i];
<a name="l00547"></a>00547     mData-&gt;insertMulti(key[i], newData);
<a name="l00548"></a>00548   }
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00560"></a>00560 <span class="keywordtype">void</span> QCPGraph::setDataBothError(<span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value, <span class="keyword">const</span> QVector&lt;double&gt; &amp;keyErrorMinus, <span class="keyword">const</span> QVector&lt;double&gt; &amp;keyErrorPlus, <span class="keyword">const</span> QVector&lt;double&gt; &amp;valueErrorMinus, <span class="keyword">const</span> QVector&lt;double&gt; &amp;valueErrorPlus)
<a name="l00561"></a>00561 {
<a name="l00562"></a>00562   mData-&gt;clear();
<a name="l00563"></a>00563   <span class="keywordtype">int</span> n = key.size();
<a name="l00564"></a>00564   n = qMin(n, value.size());
<a name="l00565"></a>00565   n = qMin(n, valueErrorMinus.size());
<a name="l00566"></a>00566   n = qMin(n, valueErrorPlus.size());
<a name="l00567"></a>00567   n = qMin(n, keyErrorMinus.size());
<a name="l00568"></a>00568   n = qMin(n, keyErrorPlus.size());
<a name="l00569"></a>00569   QCPData newData;
<a name="l00570"></a>00570   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00571"></a>00571   {
<a name="l00572"></a>00572     newData.key = key[i];
<a name="l00573"></a>00573     newData.value = value[i];
<a name="l00574"></a>00574     newData.keyErrorMinus = keyErrorMinus[i];
<a name="l00575"></a>00575     newData.keyErrorPlus = keyErrorPlus[i];
<a name="l00576"></a>00576     newData.valueErrorMinus = valueErrorMinus[i];
<a name="l00577"></a>00577     newData.valueErrorPlus = valueErrorPlus[i];
<a name="l00578"></a>00578     mData-&gt;insertMulti(key[i], newData);
<a name="l00579"></a>00579   }
<a name="l00580"></a>00580 }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 
<a name="l00589"></a>00589 <span class="keywordtype">void</span> QCPGraph::setLineStyle(LineStyle ls)
<a name="l00590"></a>00590 {
<a name="l00591"></a>00591   mLineStyle = ls;
<a name="l00592"></a>00592 }
<a name="l00593"></a>00593 
<a name="l00599"></a>00599 <span class="keywordtype">void</span> QCPGraph::setScatterStyle(ScatterStyle ss)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601   mScatterStyle = ss;
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00610"></a>00610 <span class="keywordtype">void</span> QCPGraph::setScatterSize(<span class="keywordtype">double</span> size)
<a name="l00611"></a>00611 {
<a name="l00612"></a>00612   mScatterSize = size;
<a name="l00613"></a>00613 }
<a name="l00614"></a>00614 
<a name="l00620"></a>00620 <span class="keywordtype">void</span> QCPGraph::setScatterPixmap(<span class="keyword">const</span> QPixmap &amp;pixmap)
<a name="l00621"></a>00621 {
<a name="l00622"></a>00622   mScatterPixmap = pixmap;
<a name="l00623"></a>00623 }
<a name="l00624"></a>00624 
<a name="l00628"></a>00628 <span class="keywordtype">void</span> QCPGraph::setErrorType(ErrorType errorType)
<a name="l00629"></a>00629 {
<a name="l00630"></a>00630   mErrorType = errorType;
<a name="l00631"></a>00631 }
<a name="l00632"></a>00632 
<a name="l00637"></a>00637 <span class="keywordtype">void</span> QCPGraph::setErrorPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l00638"></a>00638 {
<a name="l00639"></a>00639   mErrorPen = pen;
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00645"></a>00645 <span class="keywordtype">void</span> QCPGraph::setErrorBarSize(<span class="keywordtype">double</span> size)
<a name="l00646"></a>00646 {
<a name="l00647"></a>00647   mErrorBarSize = size;
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00659"></a>00659 <span class="keywordtype">void</span> QCPGraph::setErrorBarSkipSymbol(<span class="keywordtype">bool</span> enabled)
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661   mErrorBarSkipSymbol = enabled;
<a name="l00662"></a>00662 }
<a name="l00663"></a>00663 
<a name="l00673"></a>00673 <span class="keywordtype">void</span> QCPGraph::setChannelFillGraph(QCPGraph *targetGraph)
<a name="l00674"></a>00674 {
<a name="l00675"></a>00675   <span class="comment">// prevent setting channel target to this graph itself:</span>
<a name="l00676"></a>00676   <span class="keywordflow">if</span> (targetGraph == <span class="keyword">this</span>)
<a name="l00677"></a>00677   {
<a name="l00678"></a>00678     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;targetGraph is self&quot;</span>;
<a name="l00679"></a>00679     mChannelFillGraph = 0;
<a name="l00680"></a>00680     <span class="keywordflow">return</span>;
<a name="l00681"></a>00681   }
<a name="l00682"></a>00682   <span class="comment">// prevent setting channel target to a graph not in the plot:</span>
<a name="l00683"></a>00683   <span class="keywordflow">if</span> (targetGraph &amp;&amp; targetGraph-&gt;mParentPlot != mParentPlot)
<a name="l00684"></a>00684   {
<a name="l00685"></a>00685     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;targetGraph not in same plot&quot;</span>;
<a name="l00686"></a>00686     mChannelFillGraph = 0;
<a name="l00687"></a>00687     <span class="keywordflow">return</span>;
<a name="l00688"></a>00688   }
<a name="l00689"></a>00689   
<a name="l00690"></a>00690   mChannelFillGraph = targetGraph;
<a name="l00691"></a>00691 }
<a name="l00692"></a>00692 
<a name="l00697"></a>00697 <span class="keywordtype">void</span> QCPGraph::addData(<span class="keyword">const</span> QCPDataMap &amp;dataMap)
<a name="l00698"></a>00698 {
<a name="l00699"></a>00699 <span class="comment">// change by Sylvain Martin</span>
<a name="l00700"></a>00700 <span class="keywordflow">if</span>(mBijective){ 
<a name="l00701"></a>00701      mData-&gt;unite(dataMap);
<a name="l00702"></a>00702 }<span class="keywordflow">else</span>{
<a name="l00703"></a>00703      <span class="keywordtype">int</span> p = dataMap.count();
<a name="l00704"></a>00704 
<a name="l00705"></a>00705      <span class="keywordflow">if</span> (dataMap.isEmpty()) <span class="keywordflow">return</span>;
<a name="l00706"></a>00706      QCPDataMap::iterator i = dataMap.begin();
<a name="l00707"></a>00707 
<a name="l00708"></a>00708      <span class="keywordflow">while</span> (i != dataMap.end()) {
<a name="l00709"></a>00709           mData-&gt;insertMulti(p, i.value());
<a name="l00710"></a>00710                p++  ;
<a name="l00711"></a>00711      }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713 }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 }
<a name="l00716"></a>00716 
<a name="l00721"></a>00721 <span class="keywordtype">void</span> QCPGraph::addData(<span class="keyword">const</span> QCPData &amp;data)
<a name="l00722"></a>00722 {
<a name="l00723"></a>00723      mData-&gt;insertMulti(mBijective?data.key:mData-&gt;count(), data); <span class="comment">// change by Sylvain Martin</span>
<a name="l00724"></a>00724 }
<a name="l00725"></a>00725 
<a name="l00730"></a>00730 <span class="keywordtype">void</span> QCPGraph::addData(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)
<a name="l00731"></a>00731 {
<a name="l00732"></a>00732   QCPData newData;
<a name="l00733"></a>00733   newData.key = key;
<a name="l00734"></a>00734   newData.value = value;
<a name="l00735"></a>00735   mData-&gt;insertMulti(mBijective?newData.key:mData-&gt;count(), newData); <span class="comment">// change by Sylvain Martin</span>
<a name="l00736"></a>00736 }
<a name="l00737"></a>00737 
<a name="l00742"></a>00742 <span class="keywordtype">void</span> QCPGraph::addData(<span class="keyword">const</span> QVector&lt;double&gt; &amp;keys, <span class="keyword">const</span> QVector&lt;double&gt; &amp;values)
<a name="l00743"></a>00743 {
<a name="l00744"></a>00744   <span class="keywordtype">int</span> n = qMin(keys.size(), values.size());
<a name="l00745"></a>00745   QCPData newData;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="keywordtype">int</span> shift = mData-&gt;count();
<a name="l00748"></a>00748   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00749"></a>00749   {
<a name="l00750"></a>00750        newData.key = keys.at(i);
<a name="l00751"></a>00751        newData.value = values.at(i);
<a name="l00752"></a>00752        <span class="keywordtype">int</span> p =i+shift;
<a name="l00753"></a>00753        mData-&gt;insertMulti(mBijective?newData.key:(i+shift), newData);
<a name="l00754"></a>00754   }
<a name="l00755"></a>00755 }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 
<a name="l00765"></a>00765 <span class="keywordtype">void</span> QCPGraph::addData(<span class="keyword">const</span> QList&lt;double&gt; &amp;keys, <span class="keyword">const</span> QList&lt;double&gt; &amp;values)
<a name="l00766"></a>00766 {
<a name="l00767"></a>00767   <span class="keywordtype">int</span> n = qMin(keys.size(), values.size());
<a name="l00768"></a>00768   QCPData newData;
<a name="l00769"></a>00769   <span class="keywordtype">int</span> shift = mData-&gt;count();
<a name="l00770"></a>00770   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00771"></a>00771   {
<a name="l00772"></a>00772        newData.key = keys.at(i);
<a name="l00773"></a>00773        newData.value = values.at(i);
<a name="l00774"></a>00774        <span class="keywordtype">int</span> p =i+shift;
<a name="l00775"></a>00775        mData-&gt;insertMulti(mBijective?newData.key:(i+shift), newData);
<a name="l00776"></a>00776   }
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 
<a name="l00785"></a>00785 <span class="keywordtype">void</span> QCPGraph::addData(<span class="keyword">const</span> QList&lt;double&gt; *keys, <span class="keyword">const</span> QList&lt;double&gt; *values)
<a name="l00786"></a>00786  {
<a name="l00787"></a>00787  <span class="keywordtype">int</span> n = qMin(keys-&gt;size(), values-&gt;size());
<a name="l00788"></a>00788  QCPData newData;
<a name="l00789"></a>00789  <span class="keywordtype">int</span> shift = mData-&gt;count();
<a name="l00790"></a>00790  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l00791"></a>00791       {
<a name="l00792"></a>00792            newData.key = keys-&gt;at(i);
<a name="l00793"></a>00793            newData.value = values-&gt;at(i);
<a name="l00794"></a>00794            <span class="keywordtype">int</span> p =i+shift;
<a name="l00795"></a>00795            mData-&gt;insertMulti(mBijective?newData.key:(i+shift), newData);
<a name="l00796"></a>00796       }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 }
<a name="l00799"></a>00799 
<a name="l00804"></a>00804 <span class="keywordtype">void</span> QCPGraph::removeDataBefore(<span class="keywordtype">double</span> key)
<a name="l00805"></a>00805 {
<a name="l00806"></a>00806   QCPDataMap::iterator it = mData-&gt;begin();
<a name="l00807"></a>00807   <span class="keywordflow">while</span> (it != mData-&gt;end() &amp;&amp; it.key() &lt; key)
<a name="l00808"></a>00808     it = mData-&gt;erase(it);
<a name="l00809"></a>00809 }
<a name="l00810"></a>00810 
<a name="l00817"></a>00817 <span class="keywordtype">void</span> QCPGraph::removeDataAfter(<span class="keywordtype">double</span> key)
<a name="l00818"></a>00818 {
<a name="l00819"></a>00819       <span class="keywordflow">if</span> (mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l00820"></a>00820      QCPDataMap::iterator i = mData-&gt;begin();
<a name="l00821"></a>00821 
<a name="l00822"></a>00822      <span class="keywordflow">while</span> (i != mData-&gt;end()) {
<a name="l00823"></a>00823           <span class="keywordflow">if</span>(i.key()&gt;key)
<a name="l00824"></a>00824                mData-&gt;erase(i);    
<a name="l00825"></a>00825           ++i;
<a name="l00826"></a>00826      }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 
<a name="l00829"></a>00829 <span class="comment">//   if (mData-&gt;isEmpty()) return;</span>
<a name="l00830"></a>00830 <span class="comment">//   QCPDataMap::iterator it = mData-&gt;upperBound(key);</span>
<a name="l00831"></a>00831 <span class="comment">//   while (it != mData-&gt;end())</span>
<a name="l00832"></a>00832 <span class="comment">//     it = mData-&gt;erase(it);</span>
<a name="l00833"></a>00833 }
<a name="l00834"></a>00834 
<a name="l00843"></a>00843 <span class="keywordtype">void</span> QCPGraph::removeData(<span class="keywordtype">double</span> fromKey, <span class="keywordtype">double</span> toKey)
<a name="l00844"></a>00844 {
<a name="l00845"></a>00845   <span class="keywordflow">if</span> (fromKey &gt;= toKey || mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l00846"></a>00846   QCPDataMap::iterator i = mData-&gt;begin();
<a name="l00847"></a>00847 
<a name="l00848"></a>00848   <span class="keywordflow">while</span> (i != mData-&gt;end()) {
<a name="l00849"></a>00849        <span class="keywordflow">if</span>(i.key()&gt;fromKey &amp;&amp;  i.key()&lt;toKey)
<a name="l00850"></a>00850           mData-&gt;erase(i);    
<a name="l00851"></a>00851        ++i;
<a name="l00852"></a>00852   }
<a name="l00853"></a>00853 
<a name="l00854"></a>00854 
<a name="l00855"></a>00855 <span class="comment">//   QCPDataMap::iterator it = mData-&gt;upperBound(fromKey);</span>
<a name="l00856"></a>00856 <span class="comment">//   QCPDataMap::iterator itEnd = mData-&gt;upperBound(toKey);</span>
<a name="l00857"></a>00857 <span class="comment">//   while (it != itEnd)</span>
<a name="l00858"></a>00858 <span class="comment">//     it = mData-&gt;erase(it);</span>
<a name="l00859"></a>00859 }
<a name="l00860"></a>00860 
<a name="l00869"></a>00869 <span class="keywordtype">void</span> QCPGraph::removeData(<span class="keywordtype">double</span> key)
<a name="l00870"></a>00870 {
<a name="l00871"></a>00871   mData-&gt;remove(key);
<a name="l00872"></a>00872 }
<a name="l00873"></a>00873 
<a name="l00878"></a>00878 <span class="keywordtype">void</span> QCPGraph::clearData()
<a name="l00879"></a>00879 {
<a name="l00880"></a>00880   mData-&gt;clear();
<a name="l00881"></a>00881 }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 <span class="comment">/* inherits documentation from base class */</span>
<a name="l00884"></a>00884 <span class="keywordtype">double</span> QCPGraph::selectTest(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l00885"></a>00885 <span class="keyword"></span>{
<a name="l00886"></a>00886   <span class="keywordflow">if</span> (mData-&gt;isEmpty() || !mVisible)
<a name="l00887"></a>00887     <span class="keywordflow">return</span> -1;
<a name="l00888"></a>00888   
<a name="l00889"></a>00889   <span class="keywordflow">return</span> pointDistance(coordsToPixels(key, value));
<a name="l00890"></a>00890 }
<a name="l00891"></a>00891 
<a name="l00897"></a>00897 <span class="keywordtype">void</span> QCPGraph::rescaleAxes(<span class="keywordtype">bool</span> onlyEnlarge, <span class="keywordtype">bool</span> includeErrorBars)<span class="keyword"> const</span>
<a name="l00898"></a>00898 <span class="keyword"></span>{
<a name="l00899"></a>00899   rescaleKeyAxis(onlyEnlarge, includeErrorBars);
<a name="l00900"></a>00900   rescaleValueAxis(onlyEnlarge, includeErrorBars);
<a name="l00901"></a>00901 }
<a name="l00902"></a>00902 
<a name="l00908"></a>00908 <span class="keywordtype">void</span> QCPGraph::rescaleKeyAxis(<span class="keywordtype">bool</span> onlyEnlarge, <span class="keywordtype">bool</span> includeErrorBars)<span class="keyword"> const</span>
<a name="l00909"></a>00909 <span class="keyword"></span>{
<a name="l00910"></a>00910   <span class="comment">// this code is a copy of QCPAbstractPlottable::rescaleKeyAxis with the only change</span>
<a name="l00911"></a>00911   <span class="comment">// that getKeyRange is passed the includeErrorBars value.</span>
<a name="l00912"></a>00912   <span class="keywordflow">if</span> (mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l00913"></a>00913 
<a name="l00914"></a>00914   SignDomain signDomain = sdBoth;
<a name="l00915"></a>00915   <span class="keywordflow">if</span> (mKeyAxis-&gt;scaleType() == QCPAxis::stLogarithmic)
<a name="l00916"></a>00916     signDomain = (mKeyAxis-&gt;range().upper &lt; 0 ? sdNegative : sdPositive);
<a name="l00917"></a>00917   
<a name="l00918"></a>00918   <span class="keywordtype">bool</span> validRange;
<a name="l00919"></a>00919   QCPRange newRange = getKeyRange(validRange, signDomain, includeErrorBars);
<a name="l00920"></a>00920   
<a name="l00921"></a>00921   <span class="keywordflow">if</span> (validRange)
<a name="l00922"></a>00922   {
<a name="l00923"></a>00923     <span class="keywordflow">if</span> (onlyEnlarge)
<a name="l00924"></a>00924     {
<a name="l00925"></a>00925       <span class="keywordflow">if</span> (mKeyAxis-&gt;range().lower &lt; newRange.lower)
<a name="l00926"></a>00926         newRange.lower = mKeyAxis-&gt;range().lower;
<a name="l00927"></a>00927       <span class="keywordflow">if</span> (mKeyAxis-&gt;range().upper &gt; newRange.upper)
<a name="l00928"></a>00928         newRange.upper = mKeyAxis-&gt;range().upper;
<a name="l00929"></a>00929     }
<a name="l00930"></a>00930     mKeyAxis-&gt;setRange(newRange);
<a name="l00931"></a>00931   }
<a name="l00932"></a>00932 }
<a name="l00933"></a>00933 
<a name="l00939"></a>00939 <span class="keywordtype">void</span> QCPGraph::rescaleValueAxis(<span class="keywordtype">bool</span> onlyEnlarge, <span class="keywordtype">bool</span> includeErrorBars)<span class="keyword"> const</span>
<a name="l00940"></a>00940 <span class="keyword"></span>{
<a name="l00941"></a>00941   <span class="comment">// this code is a copy of QCPAbstractPlottable::rescaleValueAxis with the only change</span>
<a name="l00942"></a>00942   <span class="comment">// is that getValueRange is passed the includeErrorBars value.</span>
<a name="l00943"></a>00943   <span class="keywordflow">if</span> (mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l00944"></a>00944 
<a name="l00945"></a>00945   SignDomain signDomain = sdBoth;
<a name="l00946"></a>00946   <span class="keywordflow">if</span> (mValueAxis-&gt;scaleType() == QCPAxis::stLogarithmic)
<a name="l00947"></a>00947     signDomain = (mValueAxis-&gt;range().upper &lt; 0 ? sdNegative : sdPositive);
<a name="l00948"></a>00948   
<a name="l00949"></a>00949   <span class="keywordtype">bool</span> validRange;
<a name="l00950"></a>00950   QCPRange newRange = getValueRange(validRange, signDomain, includeErrorBars);
<a name="l00951"></a>00951   
<a name="l00952"></a>00952   <span class="keywordflow">if</span> (validRange)
<a name="l00953"></a>00953   {
<a name="l00954"></a>00954     <span class="keywordflow">if</span> (onlyEnlarge)
<a name="l00955"></a>00955     {
<a name="l00956"></a>00956       <span class="keywordflow">if</span> (mValueAxis-&gt;range().lower &lt; newRange.lower)
<a name="l00957"></a>00957         newRange.lower = mValueAxis-&gt;range().lower;
<a name="l00958"></a>00958       <span class="keywordflow">if</span> (mValueAxis-&gt;range().upper &gt; newRange.upper)
<a name="l00959"></a>00959         newRange.upper = mValueAxis-&gt;range().upper;
<a name="l00960"></a>00960     }
<a name="l00961"></a>00961     mValueAxis-&gt;setRange(newRange);
<a name="l00962"></a>00962   }
<a name="l00963"></a>00963 }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="comment">/* inherits documentation from base class */</span>
<a name="l00966"></a>00966 <span class="keywordtype">void</span> QCPGraph::draw(QPainter *painter)<span class="keyword"> const</span>
<a name="l00967"></a>00967 <span class="keyword"></span>{
<a name="l00968"></a>00968   <span class="keywordflow">if</span> (!mVisible) <span class="keywordflow">return</span>;
<a name="l00969"></a>00969   <span class="keywordflow">if</span> (mKeyAxis-&gt;range().size() &lt;= 0) <span class="keywordflow">return</span>;
<a name="l00970"></a>00970   <span class="keywordflow">if</span> (mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l00971"></a>00971   <span class="keywordflow">if</span> (mLineStyle == lsNone &amp;&amp; mScatterStyle == ssNone) <span class="keywordflow">return</span>;
<a name="l00972"></a>00972   painter-&gt;setClipRect(mKeyAxis-&gt;axisRect() | mValueAxis-&gt;axisRect());
<a name="l00973"></a>00973   
<a name="l00974"></a>00974   <span class="comment">// allocate line and (if necessary) point vectors:</span>
<a name="l00975"></a>00975   QVector&lt;QPointF&gt; *lineData = <span class="keyword">new</span> QVector&lt;QPointF&gt;;
<a name="l00976"></a>00976   QVector&lt;QCPData&gt; *pointData = 0;
<a name="l00977"></a>00977   <span class="keywordflow">if</span> (mScatterStyle != ssNone)
<a name="l00978"></a>00978     pointData = <span class="keyword">new</span> QVector&lt;QCPData&gt;;
<a name="l00979"></a>00979   
<a name="l00980"></a>00980   <span class="comment">// fill vectors with data appropriate to plot style:</span>
<a name="l00981"></a>00981   getPlotData(lineData, pointData);
<a name="l00982"></a>00982 
<a name="l00983"></a>00983   <span class="comment">// draw fill of graph:</span>
<a name="l00984"></a>00984   drawFill(painter, lineData);
<a name="l00985"></a>00985   
<a name="l00986"></a>00986   <span class="comment">// draw line:</span>
<a name="l00987"></a>00987   <span class="keywordflow">if</span> (mLineStyle == lsImpulse)
<a name="l00988"></a>00988     drawImpulsePlot(painter, lineData);
<a name="l00989"></a>00989   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mLineStyle != lsNone)
<a name="l00990"></a>00990     drawLinePlot(painter, lineData); <span class="comment">// also step plots can be drawn as a line plot</span>
<a name="l00991"></a>00991   
<a name="l00992"></a>00992   <span class="comment">// draw scatters:</span>
<a name="l00993"></a>00993   <span class="keywordflow">if</span> (pointData)
<a name="l00994"></a>00994     drawScatterPlot(painter, pointData);
<a name="l00995"></a>00995   
<a name="l00996"></a>00996   <span class="comment">// free allocated line and point vectors:</span>
<a name="l00997"></a>00997   <span class="keyword">delete</span> lineData;
<a name="l00998"></a>00998   <span class="keywordflow">if</span> (pointData)
<a name="l00999"></a>00999     <span class="keyword">delete</span> pointData;
<a name="l01000"></a>01000 }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002 <span class="comment">/* inherits documentation from base class */</span>
<a name="l01003"></a>01003 <span class="keywordtype">void</span> QCPGraph::drawLegendIcon(QPainter *painter, <span class="keyword">const</span> QRect &amp;rect)<span class="keyword"> const</span>
<a name="l01004"></a>01004 <span class="keyword"></span>{
<a name="l01005"></a>01005   <span class="comment">// draw fill:</span>
<a name="l01006"></a>01006   <span class="keywordflow">if</span> (mBrush.style() != Qt::NoBrush)
<a name="l01007"></a>01007   {
<a name="l01008"></a>01008     painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l01009"></a>01009     painter-&gt;fillRect(rect.left(), rect.top()+rect.height()/2.0, rect.width(), rect.height()/3.0, mBrush);
<a name="l01010"></a>01010   }
<a name="l01011"></a>01011   <span class="comment">// draw line vertically centered:</span>
<a name="l01012"></a>01012   <span class="keywordflow">if</span> (mLineStyle != lsNone)
<a name="l01013"></a>01013   {
<a name="l01014"></a>01014     painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l01015"></a>01015     painter-&gt;setPen(mPen);
<a name="l01016"></a>01016     painter-&gt;drawLine(rect.left(), rect.top()+rect.height()/2.0, rect.right()+5, rect.top()+rect.height()/2.0); <span class="comment">// +5 on x2 else last segment is missing from dashed/dotted pens</span>
<a name="l01017"></a>01017   }
<a name="l01018"></a>01018   <span class="comment">// draw scatter symbol:</span>
<a name="l01019"></a>01019   <span class="keywordflow">if</span> (mScatterStyle != ssNone)
<a name="l01020"></a>01020   {
<a name="l01021"></a>01021     <span class="keywordflow">if</span> (mScatterStyle == ssPixmap &amp;&amp; (mScatterPixmap.size().width() &gt; rect.width() || mScatterPixmap.size().height() &gt; rect.height()))
<a name="l01022"></a>01022     {
<a name="l01023"></a>01023       <span class="comment">// handle pixmap scatters that are larger than legend icon rect separately.</span>
<a name="l01024"></a>01024       <span class="comment">// We resize them and draw them manually, instead of calling drawScatter:</span>
<a name="l01025"></a>01025       QSize newSize = mScatterPixmap.size();
<a name="l01026"></a>01026       newSize.scale(rect.size(), Qt::KeepAspectRatio);
<a name="l01027"></a>01027       QRect targetRect;
<a name="l01028"></a>01028       targetRect.setSize(newSize);
<a name="l01029"></a>01029       targetRect.moveCenter(rect.center());
<a name="l01030"></a>01030       <span class="keywordtype">bool</span> smoothBackup = painter-&gt;testRenderHint(QPainter::SmoothPixmapTransform);
<a name="l01031"></a>01031       painter-&gt;setRenderHint(QPainter::SmoothPixmapTransform, <span class="keyword">true</span>);
<a name="l01032"></a>01032       painter-&gt;drawPixmap(targetRect, mScatterPixmap);
<a name="l01033"></a>01033       painter-&gt;setRenderHint(QPainter::SmoothPixmapTransform, smoothBackup);
<a name="l01034"></a>01034     } <span class="keywordflow">else</span> <span class="comment">// mScatterStyle != ssPixmap</span>
<a name="l01035"></a>01035     {
<a name="l01036"></a>01036       painter-&gt;setPen(mPen);
<a name="l01037"></a>01037       painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeScatters));
<a name="l01038"></a>01038       drawScatter(painter, rect.center().x()+1, rect.center().y()+1, mScatterStyle);
<a name="l01039"></a>01039     }
<a name="l01040"></a>01040   }
<a name="l01041"></a>01041 }
<a name="l01042"></a>01042 
<a name="l01055"></a>01055 <span class="keywordtype">void</span> QCPGraph::getPlotData(QVector&lt;QPointF&gt; *lineData, QVector&lt;QCPData&gt; *pointData)<span class="keyword"> const</span>
<a name="l01056"></a>01056 <span class="keyword"></span>{
<a name="l01057"></a>01057   <span class="keywordflow">switch</span>(mLineStyle)
<a name="l01058"></a>01058   {
<a name="l01059"></a>01059     <span class="keywordflow">case</span> lsNone: getScatterPlotData(pointData); <span class="keywordflow">break</span>;
<a name="l01060"></a>01060     <span class="keywordflow">case</span> lsLine: getLinePlotData(lineData, pointData); <span class="keywordflow">break</span>;
<a name="l01061"></a>01061     <span class="keywordflow">case</span> lsStepLeft: getStepLeftPlotData(lineData, pointData); <span class="keywordflow">break</span>;
<a name="l01062"></a>01062     <span class="keywordflow">case</span> lsStepRight: getStepRightPlotData(lineData, pointData); <span class="keywordflow">break</span>;
<a name="l01063"></a>01063     <span class="keywordflow">case</span> lsStepCenter: getStepCenterPlotData(lineData, pointData); <span class="keywordflow">break</span>;
<a name="l01064"></a>01064     <span class="keywordflow">case</span> lsImpulse: getImpulsePlotData(lineData, pointData); <span class="keywordflow">break</span>;
<a name="l01065"></a>01065   }
<a name="l01066"></a>01066 }
<a name="l01067"></a>01067 
<a name="l01078"></a>01078 <span class="keywordtype">void</span> QCPGraph::getScatterPlotData(QVector&lt;QCPData&gt; *pointData)<span class="keyword"> const</span>
<a name="l01079"></a>01079 <span class="keyword"></span>{
<a name="l01080"></a>01080   <span class="keywordflow">if</span> (!pointData) <span class="keywordflow">return</span>;
<a name="l01081"></a>01081   
<a name="l01082"></a>01082   <span class="comment">// get visible data range:</span>
<a name="l01083"></a>01083   QCPDataMap::const_iterator lower, upper;
<a name="l01084"></a>01084   <span class="keywordtype">int</span> dataCount;
<a name="l01085"></a>01085   getVisibleDataBounds(lower, upper, dataCount);
<a name="l01086"></a>01086   <span class="comment">// prepare vectors:</span>
<a name="l01087"></a>01087   <span class="keywordflow">if</span> (pointData)
<a name="l01088"></a>01088     pointData-&gt;resize(dataCount);
<a name="l01089"></a>01089 
<a name="l01090"></a>01090   <span class="comment">// position data points:</span>
<a name="l01091"></a>01091   QCPDataMap::const_iterator it = lower;
<a name="l01092"></a>01092   QCPDataMap::const_iterator upperEnd = upper+1;
<a name="l01093"></a>01093   <span class="keywordtype">int</span> i = 0;
<a name="l01094"></a>01094   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01095"></a>01095   {
<a name="l01096"></a>01096     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01097"></a>01097     {
<a name="l01098"></a>01098       (*pointData)[i] = it.value();
<a name="l01099"></a>01099       ++i;
<a name="l01100"></a>01100       ++it;
<a name="l01101"></a>01101     }
<a name="l01102"></a>01102   } <span class="keywordflow">else</span> <span class="comment">// key axis is horizontal</span>
<a name="l01103"></a>01103   {
<a name="l01104"></a>01104     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01105"></a>01105     {
<a name="l01106"></a>01106       (*pointData)[i] = it.value();
<a name="l01107"></a>01107       ++i;
<a name="l01108"></a>01108       ++it;
<a name="l01109"></a>01109     }
<a name="l01110"></a>01110   }
<a name="l01111"></a>01111 }
<a name="l01112"></a>01112 
<a name="l01123"></a>01123 <span class="keywordtype">void</span> QCPGraph::getLinePlotData(QVector&lt;QPointF&gt; *lineData, QVector&lt;QCPData&gt; *pointData)<span class="keyword"> const</span>
<a name="l01124"></a>01124 <span class="keyword"></span>{
<a name="l01125"></a>01125   <span class="comment">// get visible data range:</span>
<a name="l01126"></a>01126   QCPDataMap::const_iterator lower, upper;
<a name="l01127"></a>01127   <span class="keywordtype">int</span> dataCount;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129   getVisibleDataBounds(lower, upper, dataCount);
<a name="l01130"></a>01130   <span class="comment">// prepare vectors:</span>
<a name="l01131"></a>01131   <span class="keywordflow">if</span> (lineData)
<a name="l01132"></a>01132   { 
<a name="l01133"></a>01133     <span class="comment">// added 2 to reserve memory for lower/upper fill base points that might be needed for fill</span>
<a name="l01134"></a>01134     lineData-&gt;reserve(dataCount+2);
<a name="l01135"></a>01135     lineData-&gt;resize(dataCount);
<a name="l01136"></a>01136   }
<a name="l01137"></a>01137   <span class="keywordflow">if</span> (pointData)
<a name="l01138"></a>01138     pointData-&gt;resize(dataCount);
<a name="l01139"></a>01139 
<a name="l01140"></a>01140      <span class="comment">// position data points:</span>
<a name="l01141"></a>01141      QCPDataMap::const_iterator it = lower;
<a name="l01142"></a>01142      QCPDataMap::const_iterator upperEnd = upper+1;
<a name="l01143"></a>01143      <span class="keywordtype">int</span> i = 0;
<a name="l01144"></a>01144      <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01145"></a>01145      {
<a name="l01146"></a>01146      <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01147"></a>01147      {
<a name="l01148"></a>01148           <span class="keywordflow">if</span> (pointData)
<a name="l01149"></a>01149           (*pointData)[i] = it.value();
<a name="l01150"></a>01150           (*lineData)[i].setX(mValueAxis-&gt;coordToPixel(it.value().value));
<a name="l01151"></a>01151           (*lineData)[i].setY(mKeyAxis-&gt;coordToPixel(it.value().key));
<a name="l01152"></a>01152           ++i;
<a name="l01153"></a>01153           ++it;
<a name="l01154"></a>01154      }
<a name="l01155"></a>01155      } <span class="keywordflow">else</span> <span class="comment">// key axis is horizontal</span>
<a name="l01156"></a>01156      {
<a name="l01157"></a>01157      <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01158"></a>01158      {
<a name="l01159"></a>01159           <span class="keywordflow">if</span> (pointData)
<a name="l01160"></a>01160           (*pointData)[i] = it.value();
<a name="l01161"></a>01161           (*lineData)[i].setX(mKeyAxis-&gt;coordToPixel(it.value().key));
<a name="l01162"></a>01162           (*lineData)[i].setY(mValueAxis-&gt;coordToPixel(it.value().value));
<a name="l01163"></a>01163           ++i;
<a name="l01164"></a>01164           ++it;
<a name="l01165"></a>01165      }
<a name="l01166"></a>01166      }
<a name="l01167"></a>01167   
<a name="l01168"></a>01168 }
<a name="l01169"></a>01169 
<a name="l01180"></a>01180 <span class="keywordtype">void</span> QCPGraph::getStepLeftPlotData(QVector&lt;QPointF&gt; *lineData, QVector&lt;QCPData&gt; *pointData)<span class="keyword"> const</span>
<a name="l01181"></a>01181 <span class="keyword"></span>{
<a name="l01182"></a>01182   <span class="comment">// get visible data range:</span>
<a name="l01183"></a>01183   QCPDataMap::const_iterator lower, upper;
<a name="l01184"></a>01184   <span class="keywordtype">int</span> dataCount;
<a name="l01185"></a>01185   getVisibleDataBounds(lower, upper, dataCount);
<a name="l01186"></a>01186   <span class="comment">// prepare vectors:</span>
<a name="l01187"></a>01187   <span class="keywordflow">if</span> (lineData)
<a name="l01188"></a>01188   {
<a name="l01189"></a>01189     <span class="comment">// added 2 to reserve memory for lower/upper fill base points that might be needed for fill</span>
<a name="l01190"></a>01190     <span class="comment">// multiplied by 2 because step plot needs two polyline points per one actual data point</span>
<a name="l01191"></a>01191     lineData-&gt;reserve(dataCount*2+2);
<a name="l01192"></a>01192     lineData-&gt;resize(dataCount*2);
<a name="l01193"></a>01193   }
<a name="l01194"></a>01194   <span class="keywordflow">if</span> (pointData)
<a name="l01195"></a>01195     pointData-&gt;resize(dataCount);
<a name="l01196"></a>01196   
<a name="l01197"></a>01197   <span class="comment">// position data points:</span>
<a name="l01198"></a>01198   QCPDataMap::const_iterator it = lower;
<a name="l01199"></a>01199   QCPDataMap::const_iterator upperEnd = upper+1;
<a name="l01200"></a>01200   <span class="keywordtype">int</span> i = 0;
<a name="l01201"></a>01201   <span class="keywordtype">int</span> ipoint = 0;
<a name="l01202"></a>01202   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01203"></a>01203   {
<a name="l01204"></a>01204     <span class="keywordtype">double</span> lastValue = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01205"></a>01205     <span class="keywordtype">double</span> key;
<a name="l01206"></a>01206     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01207"></a>01207     {
<a name="l01208"></a>01208       <span class="keywordflow">if</span> (pointData)
<a name="l01209"></a>01209       {
<a name="l01210"></a>01210         (*pointData)[ipoint] = it.value();
<a name="l01211"></a>01211         ++ipoint;
<a name="l01212"></a>01212       }
<a name="l01213"></a>01213       key = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01214"></a>01214       (*lineData)[i].setX(lastValue);
<a name="l01215"></a>01215       (*lineData)[i].setY(key);
<a name="l01216"></a>01216       ++i;
<a name="l01217"></a>01217       lastValue = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01218"></a>01218       (*lineData)[i].setX(lastValue);
<a name="l01219"></a>01219       (*lineData)[i].setY(key);
<a name="l01220"></a>01220       ++i;
<a name="l01221"></a>01221       ++it;
<a name="l01222"></a>01222     }
<a name="l01223"></a>01223   } <span class="keywordflow">else</span> <span class="comment">// key axis is horizontal</span>
<a name="l01224"></a>01224   {
<a name="l01225"></a>01225     <span class="keywordtype">double</span> lastValue = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01226"></a>01226     <span class="keywordtype">double</span> key;
<a name="l01227"></a>01227     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01228"></a>01228     {
<a name="l01229"></a>01229       <span class="keywordflow">if</span> (pointData)
<a name="l01230"></a>01230       {
<a name="l01231"></a>01231         (*pointData)[ipoint] = it.value();
<a name="l01232"></a>01232         ++ipoint;
<a name="l01233"></a>01233       }
<a name="l01234"></a>01234       key = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01235"></a>01235       (*lineData)[i].setX(key);
<a name="l01236"></a>01236       (*lineData)[i].setY(lastValue);
<a name="l01237"></a>01237       ++i;
<a name="l01238"></a>01238       lastValue = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01239"></a>01239       (*lineData)[i].setX(key);
<a name="l01240"></a>01240       (*lineData)[i].setY(lastValue);
<a name="l01241"></a>01241       ++i;
<a name="l01242"></a>01242       ++it;
<a name="l01243"></a>01243     }
<a name="l01244"></a>01244   }
<a name="l01245"></a>01245 }
<a name="l01246"></a>01246 
<a name="l01257"></a>01257 <span class="keywordtype">void</span> QCPGraph::getStepRightPlotData(QVector&lt;QPointF&gt; *lineData, QVector&lt;QCPData&gt; *pointData)<span class="keyword"> const</span>
<a name="l01258"></a>01258 <span class="keyword"></span>{
<a name="l01259"></a>01259   <span class="comment">// get visible data range:</span>
<a name="l01260"></a>01260   QCPDataMap::const_iterator lower, upper;
<a name="l01261"></a>01261   <span class="keywordtype">int</span> dataCount;
<a name="l01262"></a>01262   getVisibleDataBounds(lower, upper, dataCount);
<a name="l01263"></a>01263   <span class="comment">// prepare vectors:</span>
<a name="l01264"></a>01264   <span class="keywordflow">if</span> (lineData)
<a name="l01265"></a>01265   {
<a name="l01266"></a>01266     <span class="comment">// added 2 to reserve memory for lower/upper fill base points that might be needed for fill</span>
<a name="l01267"></a>01267     <span class="comment">// multiplied by 2 because step plot needs two polyline points per one actual data point</span>
<a name="l01268"></a>01268     lineData-&gt;reserve(dataCount*2+2);
<a name="l01269"></a>01269     lineData-&gt;resize(dataCount*2);
<a name="l01270"></a>01270   }
<a name="l01271"></a>01271   <span class="keywordflow">if</span> (pointData)
<a name="l01272"></a>01272     pointData-&gt;resize(dataCount);
<a name="l01273"></a>01273   
<a name="l01274"></a>01274   <span class="comment">// position points:</span>
<a name="l01275"></a>01275   QCPDataMap::const_iterator it = lower;
<a name="l01276"></a>01276   QCPDataMap::const_iterator upperEnd = upper+1;
<a name="l01277"></a>01277   <span class="keywordtype">int</span> i = 0;
<a name="l01278"></a>01278   <span class="keywordtype">int</span> ipoint = 0;
<a name="l01279"></a>01279   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01280"></a>01280   {
<a name="l01281"></a>01281     <span class="keywordtype">double</span> lastKey = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01282"></a>01282     <span class="keywordtype">double</span> value;
<a name="l01283"></a>01283     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01284"></a>01284     {
<a name="l01285"></a>01285       <span class="keywordflow">if</span> (pointData)
<a name="l01286"></a>01286       {
<a name="l01287"></a>01287         (*pointData)[ipoint] = it.value();
<a name="l01288"></a>01288         ++ipoint;
<a name="l01289"></a>01289       }
<a name="l01290"></a>01290       value = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01291"></a>01291       (*lineData)[i].setX(value);
<a name="l01292"></a>01292       (*lineData)[i].setY(lastKey);
<a name="l01293"></a>01293       ++i;
<a name="l01294"></a>01294       lastKey = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01295"></a>01295       (*lineData)[i].setX(value);
<a name="l01296"></a>01296       (*lineData)[i].setY(lastKey);
<a name="l01297"></a>01297       ++i;
<a name="l01298"></a>01298       ++it;
<a name="l01299"></a>01299     }
<a name="l01300"></a>01300   } <span class="keywordflow">else</span> <span class="comment">// key axis is horizontal</span>
<a name="l01301"></a>01301   {
<a name="l01302"></a>01302     <span class="keywordtype">double</span> lastKey = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01303"></a>01303     <span class="keywordtype">double</span> value;
<a name="l01304"></a>01304     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01305"></a>01305     {
<a name="l01306"></a>01306       <span class="keywordflow">if</span> (pointData)
<a name="l01307"></a>01307       {
<a name="l01308"></a>01308         (*pointData)[ipoint] = it.value();
<a name="l01309"></a>01309         ++ipoint;
<a name="l01310"></a>01310       }
<a name="l01311"></a>01311       value = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01312"></a>01312       (*lineData)[i].setX(lastKey);
<a name="l01313"></a>01313       (*lineData)[i].setY(value);
<a name="l01314"></a>01314       ++i;
<a name="l01315"></a>01315       lastKey = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01316"></a>01316       (*lineData)[i].setX(lastKey);
<a name="l01317"></a>01317       (*lineData)[i].setY(value);
<a name="l01318"></a>01318       ++i;
<a name="l01319"></a>01319       ++it;
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321   }
<a name="l01322"></a>01322 }
<a name="l01323"></a>01323 
<a name="l01334"></a>01334 <span class="keywordtype">void</span> QCPGraph::getStepCenterPlotData(QVector&lt;QPointF&gt; *lineData, QVector&lt;QCPData&gt; *pointData)<span class="keyword"> const</span>
<a name="l01335"></a>01335 <span class="keyword"></span>{
<a name="l01336"></a>01336   <span class="comment">// get visible data range:</span>
<a name="l01337"></a>01337   QCPDataMap::const_iterator lower, upper;
<a name="l01338"></a>01338   <span class="keywordtype">int</span> dataCount;
<a name="l01339"></a>01339   getVisibleDataBounds(lower, upper, dataCount);
<a name="l01340"></a>01340   <span class="comment">// prepare vectors:</span>
<a name="l01341"></a>01341   <span class="keywordflow">if</span> (lineData)
<a name="l01342"></a>01342   {
<a name="l01343"></a>01343     <span class="comment">// added 2 to reserve memory for lower/upper fill base points that might be needed for base fill</span>
<a name="l01344"></a>01344     <span class="comment">// multiplied by 2 because step plot needs two polyline points per one actual data point</span>
<a name="l01345"></a>01345     lineData-&gt;reserve(dataCount*2+2);
<a name="l01346"></a>01346     lineData-&gt;resize(dataCount*2);
<a name="l01347"></a>01347   }
<a name="l01348"></a>01348   <span class="keywordflow">if</span> (pointData)
<a name="l01349"></a>01349     pointData-&gt;resize(dataCount);
<a name="l01350"></a>01350   
<a name="l01351"></a>01351   <span class="comment">// position points:</span>
<a name="l01352"></a>01352   QCPDataMap::const_iterator it = lower;
<a name="l01353"></a>01353   QCPDataMap::const_iterator upperEnd = upper+1;
<a name="l01354"></a>01354   <span class="keywordtype">int</span> i = 0;
<a name="l01355"></a>01355   <span class="keywordtype">int</span> ipoint = 0;
<a name="l01356"></a>01356   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01357"></a>01357   {
<a name="l01358"></a>01358     <span class="keywordtype">double</span> lastKey = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01359"></a>01359     <span class="keywordtype">double</span> lastValue = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01360"></a>01360     <span class="keywordtype">double</span> key;
<a name="l01361"></a>01361     <span class="keywordflow">if</span> (pointData)
<a name="l01362"></a>01362     {
<a name="l01363"></a>01363       (*pointData)[ipoint] = it.value();
<a name="l01364"></a>01364       ++ipoint;
<a name="l01365"></a>01365     }
<a name="l01366"></a>01366     (*lineData)[i].setX(lastValue);
<a name="l01367"></a>01367     (*lineData)[i].setY(lastKey);
<a name="l01368"></a>01368     ++it;
<a name="l01369"></a>01369     ++i;
<a name="l01370"></a>01370     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01371"></a>01371     {
<a name="l01372"></a>01372       <span class="keywordflow">if</span> (pointData)
<a name="l01373"></a>01373       {
<a name="l01374"></a>01374         (*pointData)[ipoint] = it.value();
<a name="l01375"></a>01375         ++ipoint;
<a name="l01376"></a>01376       }
<a name="l01377"></a>01377       key = (mKeyAxis-&gt;coordToPixel(it.key())-lastKey)*0.5 + lastKey;
<a name="l01378"></a>01378       (*lineData)[i].setX(lastValue);
<a name="l01379"></a>01379       (*lineData)[i].setY(key);
<a name="l01380"></a>01380       ++i;
<a name="l01381"></a>01381       lastValue = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01382"></a>01382       lastKey = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01383"></a>01383       (*lineData)[i].setX(lastValue);
<a name="l01384"></a>01384       (*lineData)[i].setY(key);
<a name="l01385"></a>01385       ++it;
<a name="l01386"></a>01386       ++i;
<a name="l01387"></a>01387     }
<a name="l01388"></a>01388     (*lineData)[i].setX(lastValue);
<a name="l01389"></a>01389     (*lineData)[i].setY(lastKey);
<a name="l01390"></a>01390   } <span class="keywordflow">else</span> <span class="comment">// key axis is horizontal</span>
<a name="l01391"></a>01391   {
<a name="l01392"></a>01392     <span class="keywordtype">double</span> lastKey = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01393"></a>01393     <span class="keywordtype">double</span> lastValue = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01394"></a>01394     <span class="keywordtype">double</span> key;
<a name="l01395"></a>01395     <span class="keywordflow">if</span> (pointData)
<a name="l01396"></a>01396     {
<a name="l01397"></a>01397       (*pointData)[ipoint] = it.value();
<a name="l01398"></a>01398       ++ipoint;
<a name="l01399"></a>01399     }
<a name="l01400"></a>01400     (*lineData)[i].setX(lastKey);
<a name="l01401"></a>01401     (*lineData)[i].setY(lastValue);
<a name="l01402"></a>01402     ++it;
<a name="l01403"></a>01403     ++i;
<a name="l01404"></a>01404     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01405"></a>01405     {
<a name="l01406"></a>01406       <span class="keywordflow">if</span> (pointData)
<a name="l01407"></a>01407       {
<a name="l01408"></a>01408         (*pointData)[ipoint] = it.value();
<a name="l01409"></a>01409         ++ipoint;
<a name="l01410"></a>01410       }
<a name="l01411"></a>01411       key = (mKeyAxis-&gt;coordToPixel(it.key())-lastKey)*0.5 + lastKey;
<a name="l01412"></a>01412       (*lineData)[i].setX(key);
<a name="l01413"></a>01413       (*lineData)[i].setY(lastValue);
<a name="l01414"></a>01414       ++i;
<a name="l01415"></a>01415       lastValue = mValueAxis-&gt;coordToPixel(it.value().value);
<a name="l01416"></a>01416       lastKey = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01417"></a>01417       (*lineData)[i].setX(key);
<a name="l01418"></a>01418       (*lineData)[i].setY(lastValue);
<a name="l01419"></a>01419       ++it;
<a name="l01420"></a>01420       ++i;
<a name="l01421"></a>01421     }
<a name="l01422"></a>01422     (*lineData)[i].setX(lastKey);
<a name="l01423"></a>01423     (*lineData)[i].setY(lastValue);
<a name="l01424"></a>01424   }
<a name="l01425"></a>01425 }
<a name="l01426"></a>01426 
<a name="l01437"></a>01437 <span class="keywordtype">void</span> QCPGraph::getImpulsePlotData(QVector&lt;QPointF&gt; *lineData, QVector&lt;QCPData&gt; *pointData)<span class="keyword"> const</span>
<a name="l01438"></a>01438 <span class="keyword"></span>{
<a name="l01439"></a>01439   <span class="comment">// get visible data range:</span>
<a name="l01440"></a>01440   QCPDataMap::const_iterator lower, upper;
<a name="l01441"></a>01441   <span class="keywordtype">int</span> dataCount;
<a name="l01442"></a>01442   getVisibleDataBounds(lower, upper, dataCount);
<a name="l01443"></a>01443   <span class="comment">// prepare vectors:</span>
<a name="l01444"></a>01444   <span class="keywordflow">if</span> (lineData)
<a name="l01445"></a>01445   {
<a name="l01446"></a>01446     <span class="comment">// no need to reserve 2 extra points, because there is no fill for impulse plot</span>
<a name="l01447"></a>01447     lineData-&gt;resize(dataCount*2);
<a name="l01448"></a>01448   }
<a name="l01449"></a>01449   <span class="keywordflow">if</span> (pointData)
<a name="l01450"></a>01450     pointData-&gt;resize(dataCount);
<a name="l01451"></a>01451   
<a name="l01452"></a>01452   <span class="comment">// position data points:</span>
<a name="l01453"></a>01453   QCPDataMap::const_iterator it = lower;
<a name="l01454"></a>01454   QCPDataMap::const_iterator upperEnd = upper+1;
<a name="l01455"></a>01455   <span class="keywordtype">int</span> i = 0;
<a name="l01456"></a>01456   <span class="keywordtype">int</span> ipoint = 0;
<a name="l01457"></a>01457   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01458"></a>01458   {
<a name="l01459"></a>01459     <span class="keywordtype">double</span> zeroPointX = mValueAxis-&gt;coordToPixel(0);
<a name="l01460"></a>01460     <span class="keywordtype">double</span> key;
<a name="l01461"></a>01461     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01462"></a>01462     {
<a name="l01463"></a>01463       <span class="keywordflow">if</span> (pointData)
<a name="l01464"></a>01464       {
<a name="l01465"></a>01465         (*pointData)[ipoint] = it.value();
<a name="l01466"></a>01466         ++ipoint;
<a name="l01467"></a>01467       }
<a name="l01468"></a>01468       key = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01469"></a>01469       (*lineData)[i].setX(zeroPointX);
<a name="l01470"></a>01470       (*lineData)[i].setY(key);
<a name="l01471"></a>01471       ++i;
<a name="l01472"></a>01472       (*lineData)[i].setX(mValueAxis-&gt;coordToPixel(it.value().value));
<a name="l01473"></a>01473       (*lineData)[i].setY(key);
<a name="l01474"></a>01474       ++i;
<a name="l01475"></a>01475       ++it;
<a name="l01476"></a>01476     }
<a name="l01477"></a>01477   } <span class="keywordflow">else</span> <span class="comment">// key axis is horizontal</span>
<a name="l01478"></a>01478   {
<a name="l01479"></a>01479     <span class="keywordtype">double</span> zeroPointY = mValueAxis-&gt;coordToPixel(0);
<a name="l01480"></a>01480     <span class="keywordtype">double</span> key;
<a name="l01481"></a>01481     <span class="keywordflow">while</span> (it != upperEnd)
<a name="l01482"></a>01482     {
<a name="l01483"></a>01483       <span class="keywordflow">if</span> (pointData)
<a name="l01484"></a>01484       {
<a name="l01485"></a>01485         (*pointData)[ipoint] = it.value();
<a name="l01486"></a>01486         ++ipoint;
<a name="l01487"></a>01487       }
<a name="l01488"></a>01488       key = mKeyAxis-&gt;coordToPixel(it.key());
<a name="l01489"></a>01489       (*lineData)[i].setX(key);
<a name="l01490"></a>01490       (*lineData)[i].setY(zeroPointY);
<a name="l01491"></a>01491       ++i;
<a name="l01492"></a>01492       (*lineData)[i].setX(key);
<a name="l01493"></a>01493       (*lineData)[i].setY(mValueAxis-&gt;coordToPixel(it.value().value));
<a name="l01494"></a>01494       ++i;
<a name="l01495"></a>01495       ++it;
<a name="l01496"></a>01496     }
<a name="l01497"></a>01497   }
<a name="l01498"></a>01498 }
<a name="l01499"></a>01499 
<a name="l01511"></a>01511 <span class="keywordtype">void</span> QCPGraph::drawFill(QPainter *painter, QVector&lt;QPointF&gt; *lineData)<span class="keyword"> const</span>
<a name="l01512"></a>01512 <span class="keyword"></span>{
<a name="l01513"></a>01513   <span class="keywordflow">if</span> (mLineStyle == lsImpulse) <span class="keywordflow">return</span>; <span class="comment">// fill doesn&#39;t make sense for impulse plot</span>
<a name="l01514"></a>01514   <span class="keywordflow">if</span> (mainBrush().style() == Qt::NoBrush || mainBrush().color().alpha() == 0) <span class="keywordflow">return</span>;
<a name="l01515"></a>01515   
<a name="l01516"></a>01516   painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeFills));
<a name="l01517"></a>01517   <span class="keywordflow">if</span> (!mChannelFillGraph)
<a name="l01518"></a>01518   {
<a name="l01519"></a>01519     <span class="comment">// draw base fill under graph, fill goes all the way to the zero-value-line:</span>
<a name="l01520"></a>01520     addFillBasePoints(lineData);
<a name="l01521"></a>01521     painter-&gt;setPen(Qt::NoPen);
<a name="l01522"></a>01522     painter-&gt;setBrush(mainBrush());
<a name="l01523"></a>01523     painter-&gt;drawPolygon(QPolygonF(*lineData));
<a name="l01524"></a>01524     removeFillBasePoints(lineData);
<a name="l01525"></a>01525   } <span class="keywordflow">else</span>
<a name="l01526"></a>01526   {
<a name="l01527"></a>01527     <span class="comment">// draw channel fill between this graph and mChannelFillGraph:</span>
<a name="l01528"></a>01528     painter-&gt;setPen(Qt::NoPen);
<a name="l01529"></a>01529     painter-&gt;setBrush(mainBrush());
<a name="l01530"></a>01530     painter-&gt;drawPolygon(getChannelFillPolygon(lineData));
<a name="l01531"></a>01531   }
<a name="l01532"></a>01532 }
<a name="l01533"></a>01533 
<a name="l01541"></a>01541 <span class="keywordtype">void</span> QCPGraph::drawScatterPlot(QPainter *painter, QVector&lt;QCPData&gt; *pointData)<span class="keyword"> const</span>
<a name="l01542"></a>01542 <span class="keyword"></span>{
<a name="l01543"></a>01543   <span class="comment">// draw error bars:</span>
<a name="l01544"></a>01544   <span class="keywordflow">if</span> (mErrorType != etNone)
<a name="l01545"></a>01545   {
<a name="l01546"></a>01546     painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeErrorBars));
<a name="l01547"></a>01547     painter-&gt;setPen(mErrorPen);
<a name="l01548"></a>01548     <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01549"></a>01549     {
<a name="l01550"></a>01550       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;pointData-&gt;size(); ++i)
<a name="l01551"></a>01551         drawError(painter, mValueAxis-&gt;coordToPixel(pointData-&gt;at(i).value), mKeyAxis-&gt;coordToPixel(pointData-&gt;at(i).key), pointData-&gt;at(i));
<a name="l01552"></a>01552     } <span class="keywordflow">else</span>
<a name="l01553"></a>01553     {
<a name="l01554"></a>01554       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;pointData-&gt;size(); ++i)
<a name="l01555"></a>01555         drawError(painter, mKeyAxis-&gt;coordToPixel(pointData-&gt;at(i).key), mValueAxis-&gt;coordToPixel(pointData-&gt;at(i).value), pointData-&gt;at(i));
<a name="l01556"></a>01556     }
<a name="l01557"></a>01557   }
<a name="l01558"></a>01558   
<a name="l01559"></a>01559   <span class="comment">// draw scatter point symbols:</span>
<a name="l01560"></a>01560   painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeScatters));
<a name="l01561"></a>01561   painter-&gt;setPen(mainPen());
<a name="l01562"></a>01562   painter-&gt;setBrush(mainBrush());
<a name="l01563"></a>01563   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01564"></a>01564   {
<a name="l01565"></a>01565     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;pointData-&gt;size(); ++i)
<a name="l01566"></a>01566       drawScatter(painter, mValueAxis-&gt;coordToPixel(pointData-&gt;at(i).value), mKeyAxis-&gt;coordToPixel(pointData-&gt;at(i).key), mScatterStyle);
<a name="l01567"></a>01567   } <span class="keywordflow">else</span>
<a name="l01568"></a>01568   {
<a name="l01569"></a>01569     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;pointData-&gt;size(); ++i)
<a name="l01570"></a>01570       drawScatter(painter, mKeyAxis-&gt;coordToPixel(pointData-&gt;at(i).key), mValueAxis-&gt;coordToPixel(pointData-&gt;at(i).value), mScatterStyle);
<a name="l01571"></a>01571   }
<a name="l01572"></a>01572 }
<a name="l01573"></a>01573 
<a name="l01582"></a>01582 <span class="keywordtype">void</span> QCPGraph::drawLinePlot(QPainter *painter, QVector&lt;QPointF&gt; *lineData)<span class="keyword"> const</span>
<a name="l01583"></a>01583 <span class="keyword"></span>{
<a name="l01584"></a>01584   <span class="comment">// draw line of graph:</span>
<a name="l01585"></a>01585   <span class="keywordflow">if</span> (mainPen().style() != Qt::NoPen &amp;&amp; mainPen().color().alpha() != 0)
<a name="l01586"></a>01586   {
<a name="l01587"></a>01587     painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l01588"></a>01588     painter-&gt;setPen(mainPen());
<a name="l01589"></a>01589     painter-&gt;setBrush(Qt::NoBrush);
<a name="l01590"></a>01590     painter-&gt;drawPolyline(QPolygonF(*lineData));
<a name="l01591"></a>01591   }
<a name="l01592"></a>01592 }
<a name="l01593"></a>01593 
<a name="l01600"></a>01600 <span class="keywordtype">void</span> QCPGraph::drawImpulsePlot(QPainter *painter, QVector&lt;QPointF&gt; *lineData)<span class="keyword"> const</span>
<a name="l01601"></a>01601 <span class="keyword"></span>{
<a name="l01602"></a>01602   <span class="comment">// draw impulses:</span>
<a name="l01603"></a>01603   <span class="keywordflow">if</span> (mainPen().style() != Qt::NoPen &amp;&amp; mainPen().color().alpha() != 0)
<a name="l01604"></a>01604   {
<a name="l01605"></a>01605     painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l01606"></a>01606     painter-&gt;setPen(mainPen());
<a name="l01607"></a>01607     painter-&gt;setBrush(Qt::NoBrush);
<a name="l01608"></a>01608     painter-&gt;drawLines(*lineData);
<a name="l01609"></a>01609   }
<a name="l01610"></a>01610 }
<a name="l01611"></a>01611 
<a name="l01620"></a>01620 <span class="keywordtype">void</span> QCPGraph::drawScatter(QPainter *painter, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, ScatterStyle style)<span class="keyword"> const</span>
<a name="l01621"></a>01621 <span class="keyword"></span>{
<a name="l01622"></a>01622   <span class="comment">// If you change this correction, make sure pdf exported scatters are properly centered in error bars!</span>
<a name="l01623"></a>01623   <span class="comment">// There seems to be some kind of discrepancy for different paint devices here.</span>
<a name="l01624"></a>01624   <span class="keywordflow">if</span> (style == ssCross || style == ssPlus)
<a name="l01625"></a>01625   {
<a name="l01626"></a>01626     x = x-0.7; <span class="comment">// paint system correction, else, we don&#39;t get pixel exact matches (Qt problem)</span>
<a name="l01627"></a>01627     y = y-0.4; <span class="comment">// paint system correction, else, we don&#39;t get pixel exact matches (Qt problem)</span>
<a name="l01628"></a>01628   }
<a name="l01629"></a>01629   
<a name="l01630"></a>01630   <span class="keywordtype">double</span> w = mScatterSize/2.0;
<a name="l01631"></a>01631   <span class="keywordflow">switch</span> (style)
<a name="l01632"></a>01632   {
<a name="l01633"></a>01633     <span class="keywordflow">case</span> ssDot:
<a name="l01634"></a>01634     {
<a name="l01635"></a>01635       painter-&gt;drawPoint(QPointF(x, y));
<a name="l01636"></a>01636       <span class="keywordflow">break</span>;
<a name="l01637"></a>01637     }
<a name="l01638"></a>01638     <span class="keywordflow">case</span> ssCross:
<a name="l01639"></a>01639     {
<a name="l01640"></a>01640       painter-&gt;drawLine(QLineF(x-w, y-w, x+w, y+w));
<a name="l01641"></a>01641       painter-&gt;drawLine(QLineF(x-w, y+w, x+w, y-w));
<a name="l01642"></a>01642       <span class="keywordflow">break</span>;
<a name="l01643"></a>01643     }
<a name="l01644"></a>01644     <span class="keywordflow">case</span> ssPlus:
<a name="l01645"></a>01645     {
<a name="l01646"></a>01646       painter-&gt;drawLine(QLineF(x-w, y, x+w, y));
<a name="l01647"></a>01647       painter-&gt;drawLine(QLineF(x, y+w, x, y-w));
<a name="l01648"></a>01648       <span class="keywordflow">break</span>;
<a name="l01649"></a>01649     }
<a name="l01650"></a>01650     <span class="keywordflow">case</span> ssCircle:
<a name="l01651"></a>01651     {
<a name="l01652"></a>01652       painter-&gt;setBrush(Qt::NoBrush);
<a name="l01653"></a>01653       painter-&gt;drawEllipse(x-w,y-w,mScatterSize,mScatterSize);
<a name="l01654"></a>01654       <span class="keywordflow">break</span>;
<a name="l01655"></a>01655     }
<a name="l01656"></a>01656     <span class="keywordflow">case</span> ssDisc:
<a name="l01657"></a>01657     {
<a name="l01658"></a>01658       painter-&gt;setBrush(QBrush(painter-&gt;pen().color()));
<a name="l01659"></a>01659       painter-&gt;drawEllipse(QPointF(x,y), w, w);
<a name="l01660"></a>01660       <span class="keywordflow">break</span>;
<a name="l01661"></a>01661     }
<a name="l01662"></a>01662     <span class="keywordflow">case</span> ssSquare:
<a name="l01663"></a>01663     {
<a name="l01664"></a>01664       painter-&gt;setBrush(Qt::NoBrush);
<a name="l01665"></a>01665       painter-&gt;drawRect(x-w,y-w,mScatterSize,mScatterSize);
<a name="l01666"></a>01666       <span class="keywordflow">break</span>;
<a name="l01667"></a>01667     }
<a name="l01668"></a>01668     <span class="keywordflow">case</span> ssStar:
<a name="l01669"></a>01669     {
<a name="l01670"></a>01670       painter-&gt;drawLine(QLineF(x-w, y, x+w, y));
<a name="l01671"></a>01671       painter-&gt;drawLine(QLineF(x, y+w, x, y-w));
<a name="l01672"></a>01672       painter-&gt;drawLine(QLineF(x-w*0.707, y-w*0.707, x+w*0.707, y+w*0.707));
<a name="l01673"></a>01673       painter-&gt;drawLine(QLineF(x-w*0.707, y+w*0.707, x+w*0.707, y-w*0.707));
<a name="l01674"></a>01674       <span class="keywordflow">break</span>;
<a name="l01675"></a>01675     }
<a name="l01676"></a>01676     <span class="keywordflow">case</span> ssTriangle:
<a name="l01677"></a>01677     {
<a name="l01678"></a>01678       painter-&gt;drawLine(QLineF(x-w, y+0.755*w, x+w, y+0.755*w));
<a name="l01679"></a>01679       painter-&gt;drawLine(QLineF(x+w, y+0.755*w, x, y-0.977*w));
<a name="l01680"></a>01680       painter-&gt;drawLine(QLineF(x, y-0.977*w, x-w, y+0.755*w));
<a name="l01681"></a>01681       <span class="keywordflow">break</span>;
<a name="l01682"></a>01682     }
<a name="l01683"></a>01683     <span class="keywordflow">case</span> ssTriangleInverted:
<a name="l01684"></a>01684     {
<a name="l01685"></a>01685       painter-&gt;drawLine(QLineF(x-w, y-0.755*w, x+w, y-0.755*w));
<a name="l01686"></a>01686       painter-&gt;drawLine(QLineF(x+w, y-0.755*w, x, y+0.977*w));
<a name="l01687"></a>01687       painter-&gt;drawLine(QLineF(x, y+0.977*w, x-w, y-0.755*w));
<a name="l01688"></a>01688       <span class="keywordflow">break</span>;
<a name="l01689"></a>01689     }
<a name="l01690"></a>01690     <span class="keywordflow">case</span> ssCrossSquare:
<a name="l01691"></a>01691     {
<a name="l01692"></a>01692       painter-&gt;setBrush(Qt::NoBrush);
<a name="l01693"></a>01693       painter-&gt;drawLine(QLineF(x-w, y-w, x+w*0.95, y+w*0.95));
<a name="l01694"></a>01694       painter-&gt;drawLine(QLineF(x-w, y+w*0.95, x+w*0.95, y-w));
<a name="l01695"></a>01695       painter-&gt;drawRect(x-w,y-w,mScatterSize,mScatterSize);
<a name="l01696"></a>01696       <span class="keywordflow">break</span>;
<a name="l01697"></a>01697     }
<a name="l01698"></a>01698     <span class="keywordflow">case</span> ssPlusSquare:
<a name="l01699"></a>01699     {
<a name="l01700"></a>01700       painter-&gt;setBrush(Qt::NoBrush);
<a name="l01701"></a>01701       painter-&gt;drawLine(QLineF(x-w, y, x+w*0.95, y));
<a name="l01702"></a>01702       painter-&gt;drawLine(QLineF(x, y+w, x, y-w));
<a name="l01703"></a>01703       painter-&gt;drawRect(x-w,y-w,mScatterSize,mScatterSize);
<a name="l01704"></a>01704       <span class="keywordflow">break</span>;
<a name="l01705"></a>01705     }
<a name="l01706"></a>01706     <span class="keywordflow">case</span> ssCrossCircle:
<a name="l01707"></a>01707     {
<a name="l01708"></a>01708       painter-&gt;setBrush(Qt::NoBrush);
<a name="l01709"></a>01709       painter-&gt;drawLine(QLineF(x-w*0.707, y-w*0.707, x+w*0.67, y+w*0.67));
<a name="l01710"></a>01710       painter-&gt;drawLine(QLineF(x-w*0.707, y+w*0.67, x+w*0.67, y-w*0.707));
<a name="l01711"></a>01711       painter-&gt;drawEllipse(x-w,y-w,mScatterSize,mScatterSize);
<a name="l01712"></a>01712       <span class="keywordflow">break</span>;
<a name="l01713"></a>01713     }
<a name="l01714"></a>01714     <span class="keywordflow">case</span> ssPlusCircle:
<a name="l01715"></a>01715     {
<a name="l01716"></a>01716       painter-&gt;setBrush(Qt::NoBrush);
<a name="l01717"></a>01717       painter-&gt;drawLine(QLineF(x-w, y, x+w, y));
<a name="l01718"></a>01718       painter-&gt;drawLine(QLineF(x, y+w, x, y-w));
<a name="l01719"></a>01719       painter-&gt;drawEllipse(x-w,y-w,mScatterSize,mScatterSize);
<a name="l01720"></a>01720       <span class="keywordflow">break</span>;
<a name="l01721"></a>01721     }
<a name="l01722"></a>01722     <span class="keywordflow">case</span> ssPeace:
<a name="l01723"></a>01723     {
<a name="l01724"></a>01724       painter-&gt;setBrush(Qt::NoBrush);
<a name="l01725"></a>01725       painter-&gt;drawLine(QLineF(x, y-w, x, y+w));
<a name="l01726"></a>01726       painter-&gt;drawLine(QLineF(x, y, x-w*0.707, y+w*0.707));
<a name="l01727"></a>01727       painter-&gt;drawLine(QLineF(x, y, x+w*0.707, y+w*0.707));
<a name="l01728"></a>01728       painter-&gt;drawEllipse(x-w,y-w,mScatterSize,mScatterSize);
<a name="l01729"></a>01729       <span class="keywordflow">break</span>;
<a name="l01730"></a>01730     }
<a name="l01731"></a>01731     <span class="keywordflow">case</span> ssPixmap:
<a name="l01732"></a>01732     {
<a name="l01733"></a>01733       painter-&gt;drawPixmap(x-mScatterPixmap.width()*0.5, y-mScatterPixmap.height()*0.5, mScatterPixmap);
<a name="l01734"></a>01734       <span class="comment">// if something in here is changed, adapt ssPixmap scatter style case in drawLegendIcon(), too</span>
<a name="l01735"></a>01735       <span class="keywordflow">break</span>;
<a name="l01736"></a>01736     }
<a name="l01737"></a>01737     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l01738"></a>01738   }
<a name="l01739"></a>01739 }
<a name="l01740"></a>01740 
<a name="l01748"></a>01748 <span class="keywordtype">void</span> QCPGraph::drawError(QPainter *painter, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keyword">const</span> QCPData &amp;data)<span class="keyword"> const</span>
<a name="l01749"></a>01749 <span class="keyword"></span>{
<a name="l01750"></a>01750   <span class="keywordtype">double</span> a, b; <span class="comment">// positions of error bar bounds in pixels</span>
<a name="l01751"></a>01751   <span class="keywordtype">double</span> barWidthHalf = mErrorBarSize*0.5;
<a name="l01752"></a>01752   <span class="keywordtype">double</span> skipSymbolMargin = mScatterSize*1.25; <span class="comment">// pixels left blank per side, when mErrorBarSkipSymbol is true</span>
<a name="l01753"></a>01753   
<a name="l01754"></a>01754   <span class="keywordflow">if</span> (!mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeErrorBars))
<a name="l01755"></a>01755   {
<a name="l01756"></a>01756     x = x-0.9; <span class="comment">// paint system correction, else, we don&#39;t get pixel exact matches (Qt problem)</span>
<a name="l01757"></a>01757     y = y-0.9; <span class="comment">// paint system correction, else, we don&#39;t get pixel exact matches (Qt problem)</span>
<a name="l01758"></a>01758   }
<a name="l01759"></a>01759   
<a name="l01760"></a>01760   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01761"></a>01761   {
<a name="l01762"></a>01762     <span class="comment">// draw key error vertically and value error horizontally</span>
<a name="l01763"></a>01763     <span class="keywordflow">if</span> (mErrorType == etKey || mErrorType == etBoth)
<a name="l01764"></a>01764     {
<a name="l01765"></a>01765       a = mKeyAxis-&gt;coordToPixel(data.key-data.keyErrorMinus);
<a name="l01766"></a>01766       b = mKeyAxis-&gt;coordToPixel(data.key+data.keyErrorPlus);
<a name="l01767"></a>01767       <span class="keywordflow">if</span> (mKeyAxis-&gt;rangeReversed())
<a name="l01768"></a>01768         qSwap(a,b);
<a name="l01769"></a>01769       <span class="comment">// draw spine:</span>
<a name="l01770"></a>01770       <span class="keywordflow">if</span> (mErrorBarSkipSymbol)
<a name="l01771"></a>01771       {
<a name="l01772"></a>01772         <span class="keywordflow">if</span> (a-y &gt; skipSymbolMargin) <span class="comment">// don&#39;t draw spine if error is so small it&#39;s within skipSymbolmargin</span>
<a name="l01773"></a>01773           painter-&gt;drawLine(QLineF(x, a, x, y+skipSymbolMargin));
<a name="l01774"></a>01774         <span class="keywordflow">if</span> (y-b &gt; skipSymbolMargin) 
<a name="l01775"></a>01775           painter-&gt;drawLine(QLineF(x, y-skipSymbolMargin, x, b));
<a name="l01776"></a>01776       } <span class="keywordflow">else</span>
<a name="l01777"></a>01777         painter-&gt;drawLine(QLineF(x, a, x, b));
<a name="l01778"></a>01778       <span class="comment">// draw handles:</span>
<a name="l01779"></a>01779       painter-&gt;drawLine(QLineF(x-barWidthHalf, a, x+barWidthHalf, a));
<a name="l01780"></a>01780       painter-&gt;drawLine(QLineF(x-barWidthHalf, b, x+barWidthHalf, b));
<a name="l01781"></a>01781     }
<a name="l01782"></a>01782     <span class="keywordflow">if</span> (mErrorType == etValue || mErrorType == etBoth)
<a name="l01783"></a>01783     {
<a name="l01784"></a>01784       a = mValueAxis-&gt;coordToPixel(data.value-data.valueErrorMinus);
<a name="l01785"></a>01785       b = mValueAxis-&gt;coordToPixel(data.value+data.valueErrorPlus);
<a name="l01786"></a>01786       <span class="keywordflow">if</span> (mValueAxis-&gt;rangeReversed())
<a name="l01787"></a>01787         qSwap(a,b);
<a name="l01788"></a>01788       <span class="comment">// draw spine:</span>
<a name="l01789"></a>01789       <span class="keywordflow">if</span> (mErrorBarSkipSymbol)
<a name="l01790"></a>01790       {
<a name="l01791"></a>01791         <span class="keywordflow">if</span> (x-a &gt; skipSymbolMargin) <span class="comment">// don&#39;t draw spine if error is so small it&#39;s within skipSymbolmargin</span>
<a name="l01792"></a>01792           painter-&gt;drawLine(QLineF(a, y, x-skipSymbolMargin, y));
<a name="l01793"></a>01793         <span class="keywordflow">if</span> (b-x &gt; skipSymbolMargin)
<a name="l01794"></a>01794           painter-&gt;drawLine(QLineF(x+skipSymbolMargin, y, b, y));
<a name="l01795"></a>01795       } <span class="keywordflow">else</span>
<a name="l01796"></a>01796         painter-&gt;drawLine(QLineF(a, y, b, y));
<a name="l01797"></a>01797       <span class="comment">// draw handles:</span>
<a name="l01798"></a>01798       painter-&gt;drawLine(QLineF(a, y-barWidthHalf, a, y+barWidthHalf));
<a name="l01799"></a>01799       painter-&gt;drawLine(QLineF(b, y-barWidthHalf, b, y+barWidthHalf));
<a name="l01800"></a>01800     }
<a name="l01801"></a>01801   } <span class="keywordflow">else</span>
<a name="l01802"></a>01802   {
<a name="l01803"></a>01803     <span class="comment">// draw value error vertically and key error horizontally</span>
<a name="l01804"></a>01804     <span class="keywordflow">if</span> (mErrorType == etKey || mErrorType == etBoth)
<a name="l01805"></a>01805     {
<a name="l01806"></a>01806       a = mKeyAxis-&gt;coordToPixel(data.key-data.keyErrorMinus);
<a name="l01807"></a>01807       b = mKeyAxis-&gt;coordToPixel(data.key+data.keyErrorPlus);
<a name="l01808"></a>01808       <span class="keywordflow">if</span> (mKeyAxis-&gt;rangeReversed())
<a name="l01809"></a>01809         qSwap(a,b);
<a name="l01810"></a>01810       <span class="comment">// draw spine:</span>
<a name="l01811"></a>01811       <span class="keywordflow">if</span> (mErrorBarSkipSymbol)
<a name="l01812"></a>01812       {
<a name="l01813"></a>01813         <span class="keywordflow">if</span> (x-a &gt; skipSymbolMargin) <span class="comment">// don&#39;t draw spine if error is so small it&#39;s within skipSymbolmargin</span>
<a name="l01814"></a>01814           painter-&gt;drawLine(QLineF(a, y, x-skipSymbolMargin, y));
<a name="l01815"></a>01815         <span class="keywordflow">if</span> (b-x &gt; skipSymbolMargin)
<a name="l01816"></a>01816           painter-&gt;drawLine(QLineF(x+skipSymbolMargin, y, b, y));
<a name="l01817"></a>01817       } <span class="keywordflow">else</span>
<a name="l01818"></a>01818         painter-&gt;drawLine(QLineF(a, y, b, y));
<a name="l01819"></a>01819       <span class="comment">// draw handles:</span>
<a name="l01820"></a>01820       painter-&gt;drawLine(QLineF(a, y-barWidthHalf, a, y+barWidthHalf));
<a name="l01821"></a>01821       painter-&gt;drawLine(QLineF(b, y-barWidthHalf, b, y+barWidthHalf));
<a name="l01822"></a>01822     }
<a name="l01823"></a>01823     <span class="keywordflow">if</span> (mErrorType == etValue || mErrorType == etBoth)
<a name="l01824"></a>01824     {
<a name="l01825"></a>01825       a = mValueAxis-&gt;coordToPixel(data.value-data.valueErrorMinus);
<a name="l01826"></a>01826       b = mValueAxis-&gt;coordToPixel(data.value+data.valueErrorPlus);
<a name="l01827"></a>01827       <span class="keywordflow">if</span> (mValueAxis-&gt;rangeReversed())
<a name="l01828"></a>01828         qSwap(a,b);
<a name="l01829"></a>01829       <span class="comment">// draw spine:</span>
<a name="l01830"></a>01830       <span class="keywordflow">if</span> (mErrorBarSkipSymbol)
<a name="l01831"></a>01831       {
<a name="l01832"></a>01832         <span class="keywordflow">if</span> (a-y &gt; skipSymbolMargin) <span class="comment">// don&#39;t draw spine if error is so small it&#39;s within skipSymbolmargin</span>
<a name="l01833"></a>01833           painter-&gt;drawLine(QLineF(x, a, x, y+skipSymbolMargin));
<a name="l01834"></a>01834         <span class="keywordflow">if</span> (y-b &gt; skipSymbolMargin)
<a name="l01835"></a>01835           painter-&gt;drawLine(QLineF(x, y-skipSymbolMargin, x, b));
<a name="l01836"></a>01836       } <span class="keywordflow">else</span>
<a name="l01837"></a>01837         painter-&gt;drawLine(QLineF(x, a, x, b));
<a name="l01838"></a>01838       <span class="comment">// draw handles:</span>
<a name="l01839"></a>01839       painter-&gt;drawLine(QLineF(x-barWidthHalf, a, x+barWidthHalf, a));
<a name="l01840"></a>01840       painter-&gt;drawLine(QLineF(x-barWidthHalf, b, x+barWidthHalf, b));
<a name="l01841"></a>01841     }
<a name="l01842"></a>01842   }
<a name="l01843"></a>01843 }
<a name="l01844"></a>01844 
<a name="l01845"></a>01845 
<a name="l01846"></a>01846 
<a name="l01860"></a>01860 <span class="keywordtype">void</span> QCPGraph::getVisibleDataBounds(QCPDataMap::const_iterator &amp;lower, QCPDataMap::const_iterator &amp;upper, <span class="keywordtype">int</span> &amp;count)<span class="keyword"> const</span>
<a name="l01861"></a>01861 <span class="keyword"></span>{
<a name="l01862"></a>01862 
<a name="l01863"></a>01863 
<a name="l01864"></a>01864 <span class="comment">//   si dans les data les key ne sont pas ordonnes, alors, </span>
<a name="l01865"></a>01865 <span class="comment">//   une partie des points seront trait pour rien</span>
<a name="l01866"></a>01866 <span class="comment">//   mais on n&#39;a pas trop le choix car sinon, on ne </span>
<a name="l01867"></a>01867 <span class="comment">//   peut pas traiterter les fonction non bijective (ce qui</span>
<a name="l01868"></a>01868 <span class="comment">//   n&#39;est pas tres pratique pour faire des R(H)).</span>
<a name="l01869"></a>01869      QCPDataMap::const_iterator lbound;
<a name="l01870"></a>01870      QCPDataMap::const_iterator ubound;
<a name="l01871"></a>01871 
<a name="l01872"></a>01872 <span class="comment">// get visible data range as QMap iterators</span>
<a name="l01873"></a>01873      <span class="keywordflow">if</span> (mBijective){
<a name="l01874"></a>01874           lbound = mData-&gt;lowerBound(mKeyAxis-&gt;range().lower);
<a name="l01875"></a>01875           ubound = mData-&gt;upperBound(mKeyAxis-&gt;range().upper)-1;
<a name="l01876"></a>01876           
<a name="l01877"></a>01877      }<span class="keywordflow">else</span>{
<a name="l01878"></a>01878           <span class="comment">//Hack a la con, pour les fonctions non bijective, on prend tout</span>
<a name="l01879"></a>01879           lbound = mData-&gt;begin();
<a name="l01880"></a>01880           ubound = mData-&gt;end()-1;
<a name="l01881"></a>01881      }
<a name="l01882"></a>01882 
<a name="l01883"></a>01883   <span class="keywordtype">bool</span> lowoutlier = lbound != mData-&gt;constBegin(); <span class="comment">// indicates whether there exist points below axis range</span>
<a name="l01884"></a>01884   <span class="keywordtype">bool</span> highoutlier = ubound+1 != mData-&gt;constEnd(); <span class="comment">// indicates whether there exist points above axis range</span>
<a name="l01885"></a>01885   lower = (lowoutlier ? lbound-1 : lbound); <span class="comment">// data pointrange that will be actually drawn</span>
<a name="l01886"></a>01886   upper = (highoutlier ? ubound+1 : ubound); <span class="comment">// data pointrange that will be actually drawn</span>
<a name="l01887"></a>01887   
<a name="l01888"></a>01888   <span class="comment">// count number of points in range lower to upper (including them), so we can allocate array for them in draw functions:</span>
<a name="l01889"></a>01889   QCPDataMap::const_iterator it = lower;
<a name="l01890"></a>01890   count = 1;
<a name="l01891"></a>01891   <span class="keywordflow">while</span> (it != upper)
<a name="l01892"></a>01892   {
<a name="l01893"></a>01893     ++it;
<a name="l01894"></a>01894     ++count;
<a name="l01895"></a>01895   }
<a name="l01896"></a>01896 }
<a name="l01897"></a>01897 
<a name="l01912"></a>01912 <span class="keywordtype">void</span> QCPGraph::addFillBasePoints(QVector&lt;QPointF&gt; *lineData)<span class="keyword"> const</span>
<a name="l01913"></a>01913 <span class="keyword"></span>{
<a name="l01914"></a>01914   <span class="comment">// append points that close the polygon fill at the key axis:</span>
<a name="l01915"></a>01915   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01916"></a>01916   {
<a name="l01917"></a>01917     *lineData &lt;&lt; upperFillBasePoint(lineData-&gt;last().y());
<a name="l01918"></a>01918     *lineData &lt;&lt; lowerFillBasePoint(lineData-&gt;first().y());
<a name="l01919"></a>01919   } <span class="keywordflow">else</span>
<a name="l01920"></a>01920   {
<a name="l01921"></a>01921     *lineData &lt;&lt; upperFillBasePoint(lineData-&gt;last().x());
<a name="l01922"></a>01922     *lineData &lt;&lt; lowerFillBasePoint(lineData-&gt;first().x());
<a name="l01923"></a>01923   }
<a name="l01924"></a>01924 }
<a name="l01925"></a>01925 
<a name="l01931"></a>01931 <span class="keywordtype">void</span> QCPGraph::removeFillBasePoints(QVector&lt;QPointF&gt; *lineData)<span class="keyword"> const</span>
<a name="l01932"></a>01932 <span class="keyword"></span>{
<a name="l01933"></a>01933   lineData-&gt;remove(lineData-&gt;size()-2, 2);
<a name="l01934"></a>01934 }
<a name="l01935"></a>01935 
<a name="l01949"></a>01949 QPointF QCPGraph::lowerFillBasePoint(<span class="keywordtype">double</span> lowerKey)<span class="keyword"> const</span>
<a name="l01950"></a>01950 <span class="keyword"></span>{
<a name="l01951"></a>01951   QPointF point;
<a name="l01952"></a>01952   <span class="keywordflow">if</span> (mValueAxis-&gt;scaleType() == QCPAxis::stLinear)
<a name="l01953"></a>01953   {
<a name="l01954"></a>01954     <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atLeft)
<a name="l01955"></a>01955     {
<a name="l01956"></a>01956       point.setX(mValueAxis-&gt;coordToPixel(0));
<a name="l01957"></a>01957       point.setY(lowerKey);
<a name="l01958"></a>01958     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atRight)
<a name="l01959"></a>01959     {
<a name="l01960"></a>01960       point.setX(mValueAxis-&gt;coordToPixel(0));
<a name="l01961"></a>01961       point.setY(lowerKey);
<a name="l01962"></a>01962     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atTop)
<a name="l01963"></a>01963     {
<a name="l01964"></a>01964       point.setX(lowerKey);
<a name="l01965"></a>01965       point.setY(mValueAxis-&gt;coordToPixel(0));
<a name="l01966"></a>01966     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atBottom)
<a name="l01967"></a>01967     {
<a name="l01968"></a>01968       point.setX(lowerKey);
<a name="l01969"></a>01969       point.setY(mValueAxis-&gt;coordToPixel(0));
<a name="l01970"></a>01970     }
<a name="l01971"></a>01971   } <span class="keywordflow">else</span> <span class="comment">// mValueAxis-&gt;mScaleType == QCPAxis::stLogarithmic</span>
<a name="l01972"></a>01972   {
<a name="l01973"></a>01973     <span class="comment">// In logarithmic scaling we can&#39;t just draw to value zero so we just fill all the way</span>
<a name="l01974"></a>01974     <span class="comment">// to the axis which is in the direction towards zero</span>
<a name="l01975"></a>01975     <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l01976"></a>01976     {
<a name="l01977"></a>01977       <span class="keywordflow">if</span> ((mValueAxis-&gt;range().upper &lt; 0 &amp;&amp; !mValueAxis-&gt;rangeReversed()) ||
<a name="l01978"></a>01978           (mValueAxis-&gt;range().upper &gt; 0 &amp;&amp; mValueAxis-&gt;rangeReversed())) <span class="comment">// if range is negative, zero is on opposite side of key axis</span>
<a name="l01979"></a>01979         point.setX(mKeyAxis-&gt;axisRect().right());
<a name="l01980"></a>01980       <span class="keywordflow">else</span>
<a name="l01981"></a>01981         point.setX(mKeyAxis-&gt;axisRect().left());
<a name="l01982"></a>01982       point.setY(lowerKey);
<a name="l01983"></a>01983     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atTop || mKeyAxis-&gt;axisType() == QCPAxis::atBottom)
<a name="l01984"></a>01984     {
<a name="l01985"></a>01985       point.setX(lowerKey);
<a name="l01986"></a>01986       <span class="keywordflow">if</span> ((mValueAxis-&gt;range().upper &lt; 0 &amp;&amp; !mValueAxis-&gt;rangeReversed()) ||
<a name="l01987"></a>01987           (mValueAxis-&gt;range().upper &gt; 0 &amp;&amp; mValueAxis-&gt;rangeReversed())) <span class="comment">// if range is negative, zero is on opposite side of key axis</span>
<a name="l01988"></a>01988         point.setY(mKeyAxis-&gt;axisRect().top());
<a name="l01989"></a>01989       <span class="keywordflow">else</span>
<a name="l01990"></a>01990         point.setY(mKeyAxis-&gt;axisRect().bottom());
<a name="l01991"></a>01991     }
<a name="l01992"></a>01992   }
<a name="l01993"></a>01993   <span class="keywordflow">return</span> point;
<a name="l01994"></a>01994 }
<a name="l01995"></a>01995 
<a name="l02009"></a>02009 QPointF QCPGraph::upperFillBasePoint(<span class="keywordtype">double</span> upperKey)<span class="keyword"> const</span>
<a name="l02010"></a>02010 <span class="keyword"></span>{
<a name="l02011"></a>02011   QPointF point;
<a name="l02012"></a>02012   <span class="keywordflow">if</span> (mValueAxis-&gt;scaleType() == QCPAxis::stLinear)
<a name="l02013"></a>02013   {
<a name="l02014"></a>02014     <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atLeft)
<a name="l02015"></a>02015     {
<a name="l02016"></a>02016       point.setX(mValueAxis-&gt;coordToPixel(0));
<a name="l02017"></a>02017       point.setY(upperKey);
<a name="l02018"></a>02018     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atRight)
<a name="l02019"></a>02019     {
<a name="l02020"></a>02020       point.setX(mValueAxis-&gt;coordToPixel(0));
<a name="l02021"></a>02021       point.setY(upperKey);
<a name="l02022"></a>02022     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atTop)
<a name="l02023"></a>02023     {
<a name="l02024"></a>02024       point.setX(upperKey);
<a name="l02025"></a>02025       point.setY(mValueAxis-&gt;coordToPixel(0));
<a name="l02026"></a>02026     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atBottom)
<a name="l02027"></a>02027     {
<a name="l02028"></a>02028       point.setX(upperKey);
<a name="l02029"></a>02029       point.setY(mValueAxis-&gt;coordToPixel(0));
<a name="l02030"></a>02030     }
<a name="l02031"></a>02031   } <span class="keywordflow">else</span> <span class="comment">// mValueAxis-&gt;mScaleType == QCPAxis::stLogarithmic</span>
<a name="l02032"></a>02032   {
<a name="l02033"></a>02033     <span class="comment">// In logarithmic scaling we can&#39;t just draw to value 0 so we just fill all the way</span>
<a name="l02034"></a>02034     <span class="comment">// to the axis which is in the direction towards 0</span>
<a name="l02035"></a>02035     <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Vertical)
<a name="l02036"></a>02036     {
<a name="l02037"></a>02037       <span class="keywordflow">if</span> ((mValueAxis-&gt;range().upper &lt; 0 &amp;&amp; !mValueAxis-&gt;rangeReversed()) ||
<a name="l02038"></a>02038           (mValueAxis-&gt;range().upper &gt; 0 &amp;&amp; mValueAxis-&gt;rangeReversed())) <span class="comment">// if range is negative, zero is on opposite side of key axis</span>
<a name="l02039"></a>02039         point.setX(mKeyAxis-&gt;axisRect().right());
<a name="l02040"></a>02040       <span class="keywordflow">else</span>
<a name="l02041"></a>02041         point.setX(mKeyAxis-&gt;axisRect().left());
<a name="l02042"></a>02042       point.setY(upperKey);
<a name="l02043"></a>02043     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKeyAxis-&gt;axisType() == QCPAxis::atTop || mKeyAxis-&gt;axisType() == QCPAxis::atBottom)
<a name="l02044"></a>02044     {
<a name="l02045"></a>02045       point.setX(upperKey);
<a name="l02046"></a>02046       <span class="keywordflow">if</span> ((mValueAxis-&gt;range().upper &lt; 0 &amp;&amp; !mValueAxis-&gt;rangeReversed()) ||
<a name="l02047"></a>02047           (mValueAxis-&gt;range().upper &gt; 0 &amp;&amp; mValueAxis-&gt;rangeReversed())) <span class="comment">// if range is negative, zero is on opposite side of key axis</span>
<a name="l02048"></a>02048         point.setY(mKeyAxis-&gt;axisRect().top());
<a name="l02049"></a>02049       <span class="keywordflow">else</span>
<a name="l02050"></a>02050         point.setY(mKeyAxis-&gt;axisRect().bottom());
<a name="l02051"></a>02051     }
<a name="l02052"></a>02052   }
<a name="l02053"></a>02053   <span class="keywordflow">return</span> point;
<a name="l02054"></a>02054 }
<a name="l02055"></a>02055 
<a name="l02065"></a>02065 <span class="keyword">const</span> QPolygonF QCPGraph::getChannelFillPolygon(<span class="keyword">const</span> QVector&lt;QPointF&gt; *lineData)<span class="keyword"> const</span>
<a name="l02066"></a>02066 <span class="keyword"></span>{
<a name="l02067"></a>02067   <span class="keywordflow">if</span> (mChannelFillGraph-&gt;mKeyAxis-&gt;orientation() != mKeyAxis-&gt;orientation())
<a name="l02068"></a>02068     <span class="keywordflow">return</span> QPolygonF(); <span class="comment">// don&#39;t have same axis orientation, can&#39;t fill that (Note: if keyAxis fits, valueAxis will fit too, because it&#39;s always orthogonal to keyAxis)</span>
<a name="l02069"></a>02069   
<a name="l02070"></a>02070   <span class="keywordflow">if</span> (lineData-&gt;isEmpty()) <span class="keywordflow">return</span> QPolygonF();
<a name="l02071"></a>02071   QVector&lt;QPointF&gt; otherData;
<a name="l02072"></a>02072   mChannelFillGraph-&gt;getPlotData(&amp;otherData, 0);
<a name="l02073"></a>02073   <span class="keywordflow">if</span> (otherData.isEmpty()) <span class="keywordflow">return</span> QPolygonF();
<a name="l02074"></a>02074   QVector&lt;QPointF&gt; thisData;
<a name="l02075"></a>02075   thisData.reserve(lineData-&gt;size()+otherData.size()); <span class="comment">// because we will join both vectors at end of this function</span>
<a name="l02076"></a>02076   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;lineData-&gt;size(); ++i) <span class="comment">// don&#39;t use the vector&lt;&lt;(vector),  it squeezes internally, which ruins the performance tuning with reserve()</span>
<a name="l02077"></a>02077     thisData &lt;&lt; lineData-&gt;at(i);
<a name="l02078"></a>02078   
<a name="l02079"></a>02079   <span class="comment">// pointers to be able to swap them, depending which data range needs cropping:</span>
<a name="l02080"></a>02080   QVector&lt;QPointF&gt; *staticData = &amp;thisData;
<a name="l02081"></a>02081   QVector&lt;QPointF&gt; *croppedData = &amp;otherData;
<a name="l02082"></a>02082   
<a name="l02083"></a>02083   <span class="comment">// crop both vectors to ranges in which the keys overlap (which coord is key, depends on axisType):</span>
<a name="l02084"></a>02084   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Horizontal)
<a name="l02085"></a>02085   {
<a name="l02086"></a>02086     <span class="comment">// x is key</span>
<a name="l02087"></a>02087     <span class="comment">// if an axis range is reversed, the data point keys will be descending. Reverse them, since following algorithm assumes ascending keys:</span>
<a name="l02088"></a>02088     <span class="keywordflow">if</span> (staticData-&gt;first().x() &gt; staticData-&gt;last().x())
<a name="l02089"></a>02089     {
<a name="l02090"></a>02090       <span class="keywordtype">int</span> size = staticData-&gt;size();
<a name="l02091"></a>02091       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size/2; ++i)
<a name="l02092"></a>02092         qSwap((*staticData)[i], (*staticData)[size-1-i]);
<a name="l02093"></a>02093     }
<a name="l02094"></a>02094     <span class="keywordflow">if</span> (croppedData-&gt;first().x() &gt; croppedData-&gt;last().x())
<a name="l02095"></a>02095     {
<a name="l02096"></a>02096       <span class="keywordtype">int</span> size = croppedData-&gt;size();
<a name="l02097"></a>02097       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size/2; ++i)
<a name="l02098"></a>02098         qSwap((*croppedData)[i], (*croppedData)[size-1-i]);
<a name="l02099"></a>02099     }
<a name="l02100"></a>02100     <span class="comment">// crop lower bound:</span>
<a name="l02101"></a>02101     <span class="keywordflow">if</span> (staticData-&gt;first().x() &lt; croppedData-&gt;first().x()) <span class="comment">// other one must be cropped</span>
<a name="l02102"></a>02102       qSwap(staticData, croppedData);
<a name="l02103"></a>02103     <span class="keywordtype">int</span> lowBound = findIndexBelowX(croppedData, staticData-&gt;first().x());
<a name="l02104"></a>02104     <span class="keywordflow">if</span> (lowBound == -1) <span class="keywordflow">return</span> QPolygonF(); <span class="comment">// key ranges have no overlap</span>
<a name="l02105"></a>02105     croppedData-&gt;remove(0, lowBound);
<a name="l02106"></a>02106     <span class="comment">// set lowest point of cropped data to fit exactly key position of first static data</span>
<a name="l02107"></a>02107     <span class="comment">// point via linear interpolation:</span>
<a name="l02108"></a>02108     <span class="keywordflow">if</span> (croppedData-&gt;size() &lt; 2) <span class="keywordflow">return</span> QPolygonF(); <span class="comment">// need at least two points for interpolation</span>
<a name="l02109"></a>02109     <span class="keywordtype">double</span> slope;
<a name="l02110"></a>02110     <span class="keywordflow">if</span> (croppedData-&gt;at(1).x()-croppedData-&gt;at(0).x() != 0)
<a name="l02111"></a>02111       slope = (croppedData-&gt;at(1).y()-croppedData-&gt;at(0).y())/(croppedData-&gt;at(1).x()-croppedData-&gt;at(0).x());
<a name="l02112"></a>02112     <span class="keywordflow">else</span>
<a name="l02113"></a>02113       slope = 0;
<a name="l02114"></a>02114     (*croppedData)[0].setY(croppedData-&gt;at(0).y()+slope*(staticData-&gt;first().x()-croppedData-&gt;at(0).x()));
<a name="l02115"></a>02115     (*croppedData)[0].setX(staticData-&gt;first().x());
<a name="l02116"></a>02116     
<a name="l02117"></a>02117     <span class="comment">// crop upper bound:</span>
<a name="l02118"></a>02118     <span class="keywordflow">if</span> (staticData-&gt;last().x() &gt; croppedData-&gt;last().x()) <span class="comment">// other one must be cropped</span>
<a name="l02119"></a>02119       qSwap(staticData, croppedData);
<a name="l02120"></a>02120     <span class="keywordtype">int</span> highBound = findIndexAboveX(croppedData, staticData-&gt;last().x());
<a name="l02121"></a>02121     <span class="keywordflow">if</span> (highBound == -1) <span class="keywordflow">return</span> QPolygonF(); <span class="comment">// key ranges have no overlap</span>
<a name="l02122"></a>02122     croppedData-&gt;remove(highBound+1, croppedData-&gt;size()-(highBound+1));
<a name="l02123"></a>02123     <span class="comment">// set highest point of cropped data to fit exactly key position of last static data</span>
<a name="l02124"></a>02124     <span class="comment">// point via linear interpolation:</span>
<a name="l02125"></a>02125     <span class="keywordflow">if</span> (croppedData-&gt;size() &lt; 2) <span class="keywordflow">return</span> QPolygonF(); <span class="comment">// need at least two points for interpolation</span>
<a name="l02126"></a>02126     <span class="keywordtype">int</span> li = croppedData-&gt;size()-1; <span class="comment">// last index</span>
<a name="l02127"></a>02127     <span class="keywordflow">if</span> (croppedData-&gt;at(li).x()-croppedData-&gt;at(li-1).x() != 0)
<a name="l02128"></a>02128       slope = (croppedData-&gt;at(li).y()-croppedData-&gt;at(li-1).y())/(croppedData-&gt;at(li).x()-croppedData-&gt;at(li-1).x());
<a name="l02129"></a>02129     <span class="keywordflow">else</span>
<a name="l02130"></a>02130       slope = 0;
<a name="l02131"></a>02131     (*croppedData)[li].setY(croppedData-&gt;at(li-1).y()+slope*(staticData-&gt;last().x()-croppedData-&gt;at(li-1).x()));
<a name="l02132"></a>02132     (*croppedData)[li].setX(staticData-&gt;last().x());
<a name="l02133"></a>02133   } <span class="keywordflow">else</span> <span class="comment">// mKeyAxis-&gt;orientation() == Qt::Vertical</span>
<a name="l02134"></a>02134   {
<a name="l02135"></a>02135     <span class="comment">// y is key</span>
<a name="l02136"></a>02136     <span class="comment">// similar to &quot;x is key&quot; but switched x,y. Further, lower/upper meaning is inverted compared to x,</span>
<a name="l02137"></a>02137     <span class="comment">// because in pixel coordinates, y increases from top to bottom, not bottom to top like data coordinate.</span>
<a name="l02138"></a>02138     <span class="comment">// if an axis range is reversed, the data point keys will be descending. Reverse them, since following algorithm assumes ascending keys:</span>
<a name="l02139"></a>02139     <span class="keywordflow">if</span> (staticData-&gt;first().y() &lt; staticData-&gt;last().y())
<a name="l02140"></a>02140     {
<a name="l02141"></a>02141       <span class="keywordtype">int</span> size = staticData-&gt;size();
<a name="l02142"></a>02142       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size/2; ++i)
<a name="l02143"></a>02143         qSwap((*staticData)[i], (*staticData)[size-1-i]);
<a name="l02144"></a>02144     }
<a name="l02145"></a>02145     <span class="keywordflow">if</span> (croppedData-&gt;first().y() &lt; croppedData-&gt;last().y())
<a name="l02146"></a>02146     {
<a name="l02147"></a>02147       <span class="keywordtype">int</span> size = croppedData-&gt;size();
<a name="l02148"></a>02148       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size/2; ++i)
<a name="l02149"></a>02149         qSwap((*croppedData)[i], (*croppedData)[size-1-i]);
<a name="l02150"></a>02150     }
<a name="l02151"></a>02151     <span class="comment">// crop lower bound:</span>
<a name="l02152"></a>02152     <span class="keywordflow">if</span> (staticData-&gt;first().y() &gt; croppedData-&gt;first().y()) <span class="comment">// other one must be cropped</span>
<a name="l02153"></a>02153       qSwap(staticData, croppedData);
<a name="l02154"></a>02154     <span class="keywordtype">int</span> lowBound = findIndexAboveY(croppedData, staticData-&gt;first().y());
<a name="l02155"></a>02155     <span class="keywordflow">if</span> (lowBound == -1) <span class="keywordflow">return</span> QPolygonF(); <span class="comment">// key ranges have no overlap</span>
<a name="l02156"></a>02156     croppedData-&gt;remove(0, lowBound);
<a name="l02157"></a>02157     <span class="comment">// set lowest point of cropped data to fit exactly key position of first static data</span>
<a name="l02158"></a>02158     <span class="comment">// point via linear interpolation:</span>
<a name="l02159"></a>02159     <span class="keywordflow">if</span> (croppedData-&gt;size() &lt; 2) <span class="keywordflow">return</span> QPolygonF(); <span class="comment">// need at least two points for interpolation</span>
<a name="l02160"></a>02160     <span class="keywordtype">double</span> slope;
<a name="l02161"></a>02161     <span class="keywordflow">if</span> (croppedData-&gt;at(1).y()-croppedData-&gt;at(0).y() != 0) <span class="comment">// avoid division by zero in step plots</span>
<a name="l02162"></a>02162       slope = (croppedData-&gt;at(1).x()-croppedData-&gt;at(0).x())/(croppedData-&gt;at(1).y()-croppedData-&gt;at(0).y());
<a name="l02163"></a>02163     <span class="keywordflow">else</span>
<a name="l02164"></a>02164       slope = 0;
<a name="l02165"></a>02165     (*croppedData)[0].setX(croppedData-&gt;at(0).x()+slope*(staticData-&gt;first().y()-croppedData-&gt;at(0).y()));
<a name="l02166"></a>02166     (*croppedData)[0].setY(staticData-&gt;first().y());
<a name="l02167"></a>02167     
<a name="l02168"></a>02168     <span class="comment">// crop upper bound:</span>
<a name="l02169"></a>02169     <span class="keywordflow">if</span> (staticData-&gt;last().y() &lt; croppedData-&gt;last().y()) <span class="comment">// other one must be cropped</span>
<a name="l02170"></a>02170       qSwap(staticData, croppedData);
<a name="l02171"></a>02171     <span class="keywordtype">int</span> highBound = findIndexBelowY(croppedData, staticData-&gt;last().y());
<a name="l02172"></a>02172     <span class="keywordflow">if</span> (highBound == -1) <span class="keywordflow">return</span> QPolygonF(); <span class="comment">// key ranges have no overlap</span>
<a name="l02173"></a>02173     croppedData-&gt;remove(highBound+1, croppedData-&gt;size()-(highBound+1));
<a name="l02174"></a>02174     <span class="comment">// set highest point of cropped data to fit exactly key position of last static data</span>
<a name="l02175"></a>02175     <span class="comment">// point via linear interpolation:</span>
<a name="l02176"></a>02176     <span class="keywordflow">if</span> (croppedData-&gt;size() &lt; 2) <span class="keywordflow">return</span> QPolygonF(); <span class="comment">// need at least two points for interpolation</span>
<a name="l02177"></a>02177     <span class="keywordtype">int</span> li = croppedData-&gt;size()-1; <span class="comment">// last index</span>
<a name="l02178"></a>02178     <span class="keywordflow">if</span> (croppedData-&gt;at(li).y()-croppedData-&gt;at(li-1).y() != 0) <span class="comment">// avoid division by zero in step plots</span>
<a name="l02179"></a>02179       slope = (croppedData-&gt;at(li).x()-croppedData-&gt;at(li-1).x())/(croppedData-&gt;at(li).y()-croppedData-&gt;at(li-1).y());
<a name="l02180"></a>02180     <span class="keywordflow">else</span>
<a name="l02181"></a>02181       slope = 0;
<a name="l02182"></a>02182     (*croppedData)[li].setX(croppedData-&gt;at(li-1).x()+slope*(staticData-&gt;last().y()-croppedData-&gt;at(li-1).y()));
<a name="l02183"></a>02183     (*croppedData)[li].setY(staticData-&gt;last().y());
<a name="l02184"></a>02184   }
<a name="l02185"></a>02185   
<a name="l02186"></a>02186   <span class="comment">// return joined:</span>
<a name="l02187"></a>02187   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=otherData.size()-1; i&gt;=0; --i) <span class="comment">// insert reversed, otherwise the polygon will be twisted</span>
<a name="l02188"></a>02188     thisData &lt;&lt; otherData.at(i);
<a name="l02189"></a>02189   <span class="keywordflow">return</span> QPolygonF(thisData);
<a name="l02190"></a>02190 }
<a name="l02191"></a>02191 
<a name="l02199"></a>02199 <span class="keywordtype">int</span> QCPGraph::findIndexAboveX(<span class="keyword">const</span> QVector&lt;QPointF&gt; *data, <span class="keywordtype">double</span> x)<span class="keyword"> const</span>
<a name="l02200"></a>02200 <span class="keyword"></span>{
<a name="l02201"></a>02201   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=data-&gt;size()-1; i&gt;=0; --i)
<a name="l02202"></a>02202   {
<a name="l02203"></a>02203     <span class="keywordflow">if</span> (data-&gt;at(i).x() &lt; x)
<a name="l02204"></a>02204     {
<a name="l02205"></a>02205       <span class="keywordflow">if</span> (i&lt;data-&gt;size()-1)
<a name="l02206"></a>02206         <span class="keywordflow">return</span> i+1;
<a name="l02207"></a>02207       <span class="keywordflow">else</span>
<a name="l02208"></a>02208         <span class="keywordflow">return</span> data-&gt;size()-1;
<a name="l02209"></a>02209     }
<a name="l02210"></a>02210   }
<a name="l02211"></a>02211   <span class="keywordflow">return</span> -1;
<a name="l02212"></a>02212 }
<a name="l02213"></a>02213 
<a name="l02221"></a>02221 <span class="keywordtype">int</span> QCPGraph::findIndexBelowX(<span class="keyword">const</span> QVector&lt;QPointF&gt; *data, <span class="keywordtype">double</span> x)<span class="keyword"> const</span>
<a name="l02222"></a>02222 <span class="keyword"></span>{
<a name="l02223"></a>02223   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;data-&gt;size(); ++i)
<a name="l02224"></a>02224   {
<a name="l02225"></a>02225     <span class="keywordflow">if</span> (data-&gt;at(i).x() &gt; x)
<a name="l02226"></a>02226     {
<a name="l02227"></a>02227       <span class="keywordflow">if</span> (i&gt;0)
<a name="l02228"></a>02228         <span class="keywordflow">return</span> i-1;
<a name="l02229"></a>02229       <span class="keywordflow">else</span>
<a name="l02230"></a>02230         <span class="keywordflow">return</span> 0;
<a name="l02231"></a>02231     }
<a name="l02232"></a>02232   }
<a name="l02233"></a>02233   <span class="keywordflow">return</span> -1;
<a name="l02234"></a>02234 }
<a name="l02235"></a>02235 
<a name="l02243"></a>02243 <span class="keywordtype">int</span> QCPGraph::findIndexAboveY(<span class="keyword">const</span> QVector&lt;QPointF&gt; *data, <span class="keywordtype">double</span> y)<span class="keyword"> const</span>
<a name="l02244"></a>02244 <span class="keyword"></span>{
<a name="l02245"></a>02245   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;data-&gt;size(); ++i)
<a name="l02246"></a>02246   {
<a name="l02247"></a>02247     <span class="keywordflow">if</span> (data-&gt;at(i).y() &lt; y)
<a name="l02248"></a>02248     {
<a name="l02249"></a>02249       <span class="keywordflow">if</span> (i&gt;0)
<a name="l02250"></a>02250         <span class="keywordflow">return</span> i-1;
<a name="l02251"></a>02251       <span class="keywordflow">else</span>
<a name="l02252"></a>02252         <span class="keywordflow">return</span> 0;
<a name="l02253"></a>02253     }
<a name="l02254"></a>02254   }
<a name="l02255"></a>02255   <span class="keywordflow">return</span> -1;
<a name="l02256"></a>02256 }
<a name="l02257"></a>02257 
<a name="l02264"></a>02264 <span class="keywordtype">double</span> QCPGraph::pointDistance(<span class="keyword">const</span> QPointF &amp;pixelPoint)<span class="keyword"> const</span>
<a name="l02265"></a>02265 <span class="keyword"></span>{
<a name="l02266"></a>02266   <span class="keywordflow">if</span> (mData-&gt;isEmpty())
<a name="l02267"></a>02267   {
<a name="l02268"></a>02268     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;requested point distance on graph&quot;</span> &lt;&lt; mName &lt;&lt; <span class="stringliteral">&quot;without data&quot;</span>;
<a name="l02269"></a>02269     <span class="keywordflow">return</span> 500;
<a name="l02270"></a>02270   }
<a name="l02271"></a>02271   <span class="keywordflow">if</span> (mData-&gt;size() == 1)
<a name="l02272"></a>02272   {
<a name="l02273"></a>02273     QPointF dataPoint = coordsToPixels(mData-&gt;constBegin().key(), mData-&gt;constBegin().value().value);
<a name="l02274"></a>02274     <span class="keywordflow">return</span> QVector2D(dataPoint-pixelPoint).length();
<a name="l02275"></a>02275   }
<a name="l02276"></a>02276   
<a name="l02277"></a>02277   <span class="keywordflow">if</span> (mLineStyle == lsNone &amp;&amp; mScatterStyle == ssNone)
<a name="l02278"></a>02278     <span class="keywordflow">return</span> 500;
<a name="l02279"></a>02279   
<a name="l02280"></a>02280   <span class="comment">// calculate minimum distances to graph representation:</span>
<a name="l02281"></a>02281   <span class="keywordflow">if</span> (mLineStyle == lsNone)
<a name="l02282"></a>02282   {
<a name="l02283"></a>02283     <span class="comment">// no line displayed, only calculate distance to scatter points:</span>
<a name="l02284"></a>02284     QVector&lt;QCPData&gt; *pointData = <span class="keyword">new</span> QVector&lt;QCPData&gt;;
<a name="l02285"></a>02285     getScatterPlotData(pointData);
<a name="l02286"></a>02286     <span class="keywordtype">double</span> minDistSqr = std::numeric_limits&lt;double&gt;::max();
<a name="l02287"></a>02287     QPointF ptA;
<a name="l02288"></a>02288     QPointF ptB = coordsToPixels(pointData-&gt;at(0).key, pointData-&gt;at(0).value); <span class="comment">// getScatterPlotData returns in plot coordinates, so transform to pixels</span>
<a name="l02289"></a>02289     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;pointData-&gt;size(); ++i)
<a name="l02290"></a>02290     {
<a name="l02291"></a>02291       ptA = ptB;
<a name="l02292"></a>02292       ptB = coordsToPixels(pointData-&gt;at(i).key, pointData-&gt;at(i).value);
<a name="l02293"></a>02293       <span class="keywordtype">double</span> currentDistSqr = distSqrToLine(ptA, ptB, pixelPoint);
<a name="l02294"></a>02294       <span class="keywordflow">if</span> (currentDistSqr &lt; minDistSqr)
<a name="l02295"></a>02295         minDistSqr = currentDistSqr;
<a name="l02296"></a>02296     }
<a name="l02297"></a>02297     <span class="keyword">delete</span> pointData;
<a name="l02298"></a>02298     <span class="keywordflow">return</span> sqrt(minDistSqr);
<a name="l02299"></a>02299   } <span class="keywordflow">else</span>
<a name="l02300"></a>02300   {
<a name="l02301"></a>02301     <span class="comment">// line displayed calculate distance to line segments:</span>
<a name="l02302"></a>02302     QVector&lt;QPointF&gt; *lineData = <span class="keyword">new</span> QVector&lt;QPointF&gt;;
<a name="l02303"></a>02303     getPlotData(lineData, 0); <span class="comment">// unlike with getScatterPlotData we get pixel coordinates here</span>
<a name="l02304"></a>02304     <span class="keywordtype">double</span> minDistSqr = std::numeric_limits&lt;double&gt;::max();
<a name="l02305"></a>02305     <span class="keywordflow">if</span> (mLineStyle == lsImpulse)
<a name="l02306"></a>02306     {
<a name="l02307"></a>02307       <span class="comment">// impulse plot differs from other line styles in that the lineData points are only pairwise connected:</span>
<a name="l02308"></a>02308       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;lineData-&gt;size()-1; i+=2) <span class="comment">// iterate pairs</span>
<a name="l02309"></a>02309       {
<a name="l02310"></a>02310         <span class="keywordtype">double</span> currentDistSqr = distSqrToLine(lineData-&gt;at(i), lineData-&gt;at(i+1), pixelPoint);
<a name="l02311"></a>02311         <span class="keywordflow">if</span> (currentDistSqr &lt; minDistSqr)
<a name="l02312"></a>02312           minDistSqr = currentDistSqr;
<a name="l02313"></a>02313       }
<a name="l02314"></a>02314     } <span class="keywordflow">else</span> 
<a name="l02315"></a>02315     {
<a name="l02316"></a>02316       <span class="comment">// all other line plots (line and step) connect points directly:</span>
<a name="l02317"></a>02317       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;lineData-&gt;size()-1; ++i)
<a name="l02318"></a>02318       {
<a name="l02319"></a>02319         <span class="keywordtype">double</span> currentDistSqr = distSqrToLine(lineData-&gt;at(i), lineData-&gt;at(i+1), pixelPoint);
<a name="l02320"></a>02320         <span class="keywordflow">if</span> (currentDistSqr &lt; minDistSqr)
<a name="l02321"></a>02321           minDistSqr = currentDistSqr;
<a name="l02322"></a>02322       }
<a name="l02323"></a>02323     }
<a name="l02324"></a>02324     <span class="keyword">delete</span> lineData;
<a name="l02325"></a>02325     <span class="keywordflow">return</span> sqrt(minDistSqr);
<a name="l02326"></a>02326   }
<a name="l02327"></a>02327 }
<a name="l02328"></a>02328 
<a name="l02334"></a>02334 <span class="keywordtype">double</span> QCPGraph::distSqrToLine(QPointF ptA, QPointF ptB, QPointF point)<span class="keyword"> const</span>
<a name="l02335"></a>02335 <span class="keyword"></span>{
<a name="l02336"></a>02336   QVector2D a(ptA);
<a name="l02337"></a>02337   QVector2D b(ptB);
<a name="l02338"></a>02338   QVector2D p(point);
<a name="l02339"></a>02339   QVector2D v(b-a);
<a name="l02340"></a>02340   <span class="keywordtype">double</span> mu = (QVector2D::dotProduct(p, v)-QVector2D::dotProduct(a, v))/v.lengthSquared();
<a name="l02341"></a>02341   <span class="keywordflow">if</span> (mu &lt;= 0)
<a name="l02342"></a>02342     <span class="keywordflow">return</span> (a-p).lengthSquared();
<a name="l02343"></a>02343   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mu &gt;= 1)
<a name="l02344"></a>02344     <span class="keywordflow">return</span> (b-p).lengthSquared();
<a name="l02345"></a>02345   <span class="keywordflow">else</span>
<a name="l02346"></a>02346     <span class="keywordflow">return</span> ((a + mu*v)-p).lengthSquared();
<a name="l02347"></a>02347 }
<a name="l02348"></a>02348 
<a name="l02356"></a>02356 <span class="keywordtype">int</span> QCPGraph::findIndexBelowY(<span class="keyword">const</span> QVector&lt;QPointF&gt; *data, <span class="keywordtype">double</span> y)<span class="keyword"> const</span>
<a name="l02357"></a>02357 <span class="keyword"></span>{
<a name="l02358"></a>02358   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=data-&gt;size()-1; i&gt;=0; --i)
<a name="l02359"></a>02359   {
<a name="l02360"></a>02360     <span class="keywordflow">if</span> (data-&gt;at(i).y() &gt; y)
<a name="l02361"></a>02361     {
<a name="l02362"></a>02362       <span class="keywordflow">if</span> (i&lt;data-&gt;size()-1)
<a name="l02363"></a>02363         <span class="keywordflow">return</span> i+1;
<a name="l02364"></a>02364       <span class="keywordflow">else</span>
<a name="l02365"></a>02365         <span class="keywordflow">return</span> data-&gt;size()-1;
<a name="l02366"></a>02366     }
<a name="l02367"></a>02367   }
<a name="l02368"></a>02368   <span class="keywordflow">return</span> -1;
<a name="l02369"></a>02369 }
<a name="l02370"></a>02370 
<a name="l02371"></a>02371 <span class="comment">/* inherits documentation from base class */</span>
<a name="l02372"></a>02372 QCPRange QCPGraph::getKeyRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain)<span class="keyword"> const</span>
<a name="l02373"></a>02373 <span class="keyword"></span>{
<a name="l02374"></a>02374   <span class="comment">// just call the specialized version which takes an additional argument whether error bars</span>
<a name="l02375"></a>02375   <span class="comment">// should also be taken into consideration for range calculation. We set this to true here.</span>
<a name="l02376"></a>02376   <span class="keywordflow">return</span> getKeyRange(validRange, inSignDomain, <span class="keyword">true</span>);
<a name="l02377"></a>02377 }
<a name="l02378"></a>02378 
<a name="l02379"></a>02379 <span class="comment">/* inherits documentation from base class */</span>
<a name="l02380"></a>02380 QCPRange QCPGraph::getValueRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain)<span class="keyword"> const</span>
<a name="l02381"></a>02381 <span class="keyword"></span>{
<a name="l02382"></a>02382   <span class="comment">// just call the specialized version which takes an additional argument whether error bars</span>
<a name="l02383"></a>02383   <span class="comment">// should also be taken into consideration for range calculation. We set this to true here.</span>
<a name="l02384"></a>02384   <span class="keywordflow">return</span> getValueRange(validRange, inSignDomain, <span class="keyword">true</span>);
<a name="l02385"></a>02385 }
<a name="l02386"></a>02386 
<a name="l02392"></a>02392 QCPRange QCPGraph::getKeyRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain, <span class="keywordtype">bool</span> includeErrors)<span class="keyword"> const</span>
<a name="l02393"></a>02393 <span class="keyword"></span>{
<a name="l02394"></a>02394   QCPRange range;
<a name="l02395"></a>02395   <span class="keywordtype">bool</span> haveLower = <span class="keyword">false</span>;
<a name="l02396"></a>02396   <span class="keywordtype">bool</span> haveUpper = <span class="keyword">false</span>;
<a name="l02397"></a>02397   
<a name="l02398"></a>02398   <span class="keywordtype">double</span> current, currentErrorMinus, currentErrorPlus;
<a name="l02399"></a>02399   
<a name="l02400"></a>02400   <span class="keywordflow">if</span> (inSignDomain == sdBoth) <span class="comment">// range may be anywhere</span>
<a name="l02401"></a>02401   {
<a name="l02402"></a>02402     QCPDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l02403"></a>02403     <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l02404"></a>02404     {
<a name="l02405"></a>02405       current = it.value().key;
<a name="l02406"></a>02406       currentErrorMinus = (includeErrors ? it.value().keyErrorMinus : 0);
<a name="l02407"></a>02407       currentErrorPlus = (includeErrors ? it.value().keyErrorPlus : 0);
<a name="l02408"></a>02408       <span class="keywordflow">if</span> (current-currentErrorMinus &lt; range.lower || !haveLower)
<a name="l02409"></a>02409       {
<a name="l02410"></a>02410         range.lower = current-currentErrorMinus;
<a name="l02411"></a>02411         haveLower = <span class="keyword">true</span>;
<a name="l02412"></a>02412       }
<a name="l02413"></a>02413       <span class="keywordflow">if</span> (current+currentErrorPlus &gt; range.upper || !haveUpper)
<a name="l02414"></a>02414       {
<a name="l02415"></a>02415         range.upper = current+currentErrorPlus;
<a name="l02416"></a>02416         haveUpper = <span class="keyword">true</span>;
<a name="l02417"></a>02417       }
<a name="l02418"></a>02418       ++it;
<a name="l02419"></a>02419     }
<a name="l02420"></a>02420   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inSignDomain == sdNegative) <span class="comment">// range may only be in the negative sign domain</span>
<a name="l02421"></a>02421   {
<a name="l02422"></a>02422     QCPDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l02423"></a>02423     <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l02424"></a>02424     {
<a name="l02425"></a>02425       current = it.value().key;
<a name="l02426"></a>02426       currentErrorMinus = (includeErrors ? it.value().keyErrorMinus : 0);
<a name="l02427"></a>02427       currentErrorPlus = (includeErrors ? it.value().keyErrorPlus : 0);
<a name="l02428"></a>02428       <span class="keywordflow">if</span> ((current-currentErrorMinus &lt; range.lower || !haveLower) &amp;&amp; current-currentErrorMinus &lt; 0)
<a name="l02429"></a>02429       {
<a name="l02430"></a>02430         range.lower = current-currentErrorMinus;
<a name="l02431"></a>02431         haveLower = <span class="keyword">true</span>;
<a name="l02432"></a>02432       }
<a name="l02433"></a>02433       <span class="keywordflow">if</span> ((current+currentErrorPlus &gt; range.upper || !haveUpper) &amp;&amp; current+currentErrorPlus &lt; 0)
<a name="l02434"></a>02434       {
<a name="l02435"></a>02435         range.upper = current+currentErrorPlus;
<a name="l02436"></a>02436         haveUpper = <span class="keyword">true</span>;
<a name="l02437"></a>02437       }
<a name="l02438"></a>02438       <span class="keywordflow">if</span> (includeErrors) <span class="comment">// in case point is in valid sign domain but errobars stretch beyond it, we still want to geht that point.</span>
<a name="l02439"></a>02439       {
<a name="l02440"></a>02440         <span class="keywordflow">if</span> ((current &lt; range.lower || !haveLower) &amp;&amp; current &lt; 0)
<a name="l02441"></a>02441         {
<a name="l02442"></a>02442           range.lower = current;
<a name="l02443"></a>02443           haveLower = <span class="keyword">true</span>;
<a name="l02444"></a>02444         }
<a name="l02445"></a>02445         <span class="keywordflow">if</span> ((current &gt; range.upper || !haveUpper) &amp;&amp; current &lt; 0)
<a name="l02446"></a>02446         {
<a name="l02447"></a>02447           range.upper = current;
<a name="l02448"></a>02448           haveUpper = <span class="keyword">true</span>;
<a name="l02449"></a>02449         }
<a name="l02450"></a>02450       }
<a name="l02451"></a>02451       ++it;
<a name="l02452"></a>02452     }
<a name="l02453"></a>02453   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inSignDomain == sdPositive) <span class="comment">// range may only be in the positive sign domain</span>
<a name="l02454"></a>02454   {
<a name="l02455"></a>02455     QCPDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l02456"></a>02456     <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l02457"></a>02457     {
<a name="l02458"></a>02458       current = it.value().key;
<a name="l02459"></a>02459       currentErrorMinus = (includeErrors ? it.value().keyErrorMinus : 0);
<a name="l02460"></a>02460       currentErrorPlus = (includeErrors ? it.value().keyErrorPlus : 0);
<a name="l02461"></a>02461       <span class="keywordflow">if</span> ((current-currentErrorMinus &lt; range.lower || !haveLower) &amp;&amp; current-currentErrorMinus &gt; 0)
<a name="l02462"></a>02462       {
<a name="l02463"></a>02463         range.lower = current-currentErrorMinus;
<a name="l02464"></a>02464         haveLower = <span class="keyword">true</span>;
<a name="l02465"></a>02465       }
<a name="l02466"></a>02466       <span class="keywordflow">if</span> ((current+currentErrorPlus &gt; range.upper || !haveUpper) &amp;&amp; current+currentErrorPlus &gt; 0)
<a name="l02467"></a>02467       {
<a name="l02468"></a>02468         range.upper = current+currentErrorPlus;
<a name="l02469"></a>02469         haveUpper = <span class="keyword">true</span>;
<a name="l02470"></a>02470       }
<a name="l02471"></a>02471       <span class="keywordflow">if</span> (includeErrors) <span class="comment">// in case point is in valid sign domain but errobars stretch beyond it, we still want to get that point.</span>
<a name="l02472"></a>02472       {
<a name="l02473"></a>02473         <span class="keywordflow">if</span> ((current &lt; range.lower || !haveLower) &amp;&amp; current &gt; 0)
<a name="l02474"></a>02474         {
<a name="l02475"></a>02475           range.lower = current;
<a name="l02476"></a>02476           haveLower = <span class="keyword">true</span>;
<a name="l02477"></a>02477         }
<a name="l02478"></a>02478         <span class="keywordflow">if</span> ((current &gt; range.upper || !haveUpper) &amp;&amp; current &gt; 0)
<a name="l02479"></a>02479         {
<a name="l02480"></a>02480           range.upper = current;
<a name="l02481"></a>02481           haveUpper = <span class="keyword">true</span>;
<a name="l02482"></a>02482         }
<a name="l02483"></a>02483       }
<a name="l02484"></a>02484       ++it;
<a name="l02485"></a>02485     }
<a name="l02486"></a>02486   }
<a name="l02487"></a>02487   
<a name="l02488"></a>02488   validRange = haveLower &amp;&amp; haveUpper;
<a name="l02489"></a>02489   <span class="keywordflow">return</span> range;
<a name="l02490"></a>02490 }
<a name="l02491"></a>02491 
<a name="l02497"></a>02497 QCPRange QCPGraph::getValueRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain, <span class="keywordtype">bool</span> includeErrors)<span class="keyword"> const</span>
<a name="l02498"></a>02498 <span class="keyword"></span>{
<a name="l02499"></a>02499   QCPRange range;
<a name="l02500"></a>02500   <span class="keywordtype">bool</span> haveLower = <span class="keyword">false</span>;
<a name="l02501"></a>02501   <span class="keywordtype">bool</span> haveUpper = <span class="keyword">false</span>;
<a name="l02502"></a>02502   
<a name="l02503"></a>02503   <span class="keywordtype">double</span> current, currentErrorMinus, currentErrorPlus;
<a name="l02504"></a>02504   
<a name="l02505"></a>02505   <span class="keywordflow">if</span> (inSignDomain == sdBoth) <span class="comment">// range may be anywhere</span>
<a name="l02506"></a>02506   {
<a name="l02507"></a>02507     QCPDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l02508"></a>02508     <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l02509"></a>02509     {
<a name="l02510"></a>02510       current = it.value().value;
<a name="l02511"></a>02511       currentErrorMinus = (includeErrors ? it.value().valueErrorMinus : 0);
<a name="l02512"></a>02512       currentErrorPlus = (includeErrors ? it.value().valueErrorPlus : 0);
<a name="l02513"></a>02513       <span class="keywordflow">if</span> (current-currentErrorMinus &lt; range.lower || !haveLower)
<a name="l02514"></a>02514       {
<a name="l02515"></a>02515         range.lower = current-currentErrorMinus;
<a name="l02516"></a>02516         haveLower = <span class="keyword">true</span>;
<a name="l02517"></a>02517       }
<a name="l02518"></a>02518       <span class="keywordflow">if</span> (current+currentErrorPlus &gt; range.upper || !haveUpper)
<a name="l02519"></a>02519       {
<a name="l02520"></a>02520         range.upper = current+currentErrorPlus;
<a name="l02521"></a>02521         haveUpper = <span class="keyword">true</span>;
<a name="l02522"></a>02522       }
<a name="l02523"></a>02523       ++it;
<a name="l02524"></a>02524     }
<a name="l02525"></a>02525   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inSignDomain == sdNegative) <span class="comment">// range may only be in the negative sign domain</span>
<a name="l02526"></a>02526   {
<a name="l02527"></a>02527     QCPDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l02528"></a>02528     <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l02529"></a>02529     {
<a name="l02530"></a>02530       current = it.value().value;
<a name="l02531"></a>02531       currentErrorMinus = (includeErrors ? it.value().valueErrorMinus : 0);
<a name="l02532"></a>02532       currentErrorPlus = (includeErrors ? it.value().valueErrorPlus : 0);
<a name="l02533"></a>02533       <span class="keywordflow">if</span> ((current-currentErrorMinus &lt; range.lower || !haveLower) &amp;&amp; current-currentErrorMinus &lt; 0)
<a name="l02534"></a>02534       {
<a name="l02535"></a>02535         range.lower = current-currentErrorMinus;
<a name="l02536"></a>02536         haveLower = <span class="keyword">true</span>;
<a name="l02537"></a>02537       }
<a name="l02538"></a>02538       <span class="keywordflow">if</span> ((current+currentErrorPlus &gt; range.upper || !haveUpper) &amp;&amp; current+currentErrorPlus &lt; 0)
<a name="l02539"></a>02539       {
<a name="l02540"></a>02540         range.upper = current+currentErrorPlus;
<a name="l02541"></a>02541         haveUpper = <span class="keyword">true</span>;
<a name="l02542"></a>02542       }
<a name="l02543"></a>02543       <span class="keywordflow">if</span> (includeErrors) <span class="comment">// in case point is in valid sign domain but errobars stretch beyond it, we still want to get that point.</span>
<a name="l02544"></a>02544       {
<a name="l02545"></a>02545         <span class="keywordflow">if</span> ((current &lt; range.lower || !haveLower) &amp;&amp; current &lt; 0)
<a name="l02546"></a>02546         {
<a name="l02547"></a>02547           range.lower = current;
<a name="l02548"></a>02548           haveLower = <span class="keyword">true</span>;
<a name="l02549"></a>02549         }
<a name="l02550"></a>02550         <span class="keywordflow">if</span> ((current &gt; range.upper || !haveUpper) &amp;&amp; current &lt; 0)
<a name="l02551"></a>02551         {
<a name="l02552"></a>02552           range.upper = current;
<a name="l02553"></a>02553           haveUpper = <span class="keyword">true</span>;
<a name="l02554"></a>02554         }
<a name="l02555"></a>02555       }
<a name="l02556"></a>02556       ++it;
<a name="l02557"></a>02557     }
<a name="l02558"></a>02558   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inSignDomain == sdPositive) <span class="comment">// range may only be in the positive sign domain</span>
<a name="l02559"></a>02559   {
<a name="l02560"></a>02560     QCPDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l02561"></a>02561     <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l02562"></a>02562     {
<a name="l02563"></a>02563       current = it.value().value;
<a name="l02564"></a>02564       currentErrorMinus = (includeErrors ? it.value().valueErrorMinus : 0);
<a name="l02565"></a>02565       currentErrorPlus = (includeErrors ? it.value().valueErrorPlus : 0);
<a name="l02566"></a>02566       <span class="keywordflow">if</span> ((current-currentErrorMinus &lt; range.lower || !haveLower) &amp;&amp; current-currentErrorMinus &gt; 0)
<a name="l02567"></a>02567       {
<a name="l02568"></a>02568         range.lower = current-currentErrorMinus;
<a name="l02569"></a>02569         haveLower = <span class="keyword">true</span>;
<a name="l02570"></a>02570       }
<a name="l02571"></a>02571       <span class="keywordflow">if</span> ((current+currentErrorPlus &gt; range.upper || !haveUpper) &amp;&amp; current+currentErrorPlus &gt; 0)
<a name="l02572"></a>02572       {
<a name="l02573"></a>02573         range.upper = current+currentErrorPlus;
<a name="l02574"></a>02574         haveUpper = <span class="keyword">true</span>;
<a name="l02575"></a>02575       }
<a name="l02576"></a>02576       <span class="keywordflow">if</span> (includeErrors) <span class="comment">// in case point is in valid sign domain but errobars stretch beyond it, we still want to geht that point.</span>
<a name="l02577"></a>02577       {
<a name="l02578"></a>02578         <span class="keywordflow">if</span> ((current &lt; range.lower || !haveLower) &amp;&amp; current &gt; 0)
<a name="l02579"></a>02579         {
<a name="l02580"></a>02580           range.lower = current;
<a name="l02581"></a>02581           haveLower = <span class="keyword">true</span>;
<a name="l02582"></a>02582         }
<a name="l02583"></a>02583         <span class="keywordflow">if</span> ((current &gt; range.upper || !haveUpper) &amp;&amp; current &gt; 0)
<a name="l02584"></a>02584         {
<a name="l02585"></a>02585           range.upper = current;
<a name="l02586"></a>02586           haveUpper = <span class="keyword">true</span>;
<a name="l02587"></a>02587         }
<a name="l02588"></a>02588       }
<a name="l02589"></a>02589       ++it;
<a name="l02590"></a>02590     }
<a name="l02591"></a>02591   }
<a name="l02592"></a>02592   
<a name="l02593"></a>02593   validRange = haveLower &amp;&amp; haveUpper;
<a name="l02594"></a>02594   <span class="keywordflow">return</span> range;
<a name="l02595"></a>02595 }
<a name="l02596"></a>02596 
<a name="l02597"></a>02597 
<a name="l02598"></a>02598 <span class="comment">// ================================================================================</span>
<a name="l02599"></a>02599 <span class="comment">// =================== QCPRange</span>
<a name="l02600"></a>02600 <span class="comment">// ================================================================================</span>
<a name="l02616"></a>02616 <span class="comment"></span><span class="keyword">const</span> <span class="keywordtype">double</span> QCPRange::minRange = 1e-280;
<a name="l02617"></a>02617 
<a name="l02626"></a>02626 <span class="keyword">const</span> <span class="keywordtype">double</span> QCPRange::maxRange = 1e250;
<a name="l02627"></a>02627 
<a name="l02631"></a>02631 QCPRange::QCPRange() :
<a name="l02632"></a>02632   lower(0),
<a name="l02633"></a>02633   upper(0)
<a name="l02634"></a>02634 {
<a name="l02635"></a>02635 }
<a name="l02636"></a>02636 
<a name="l02640"></a>02640 QCPRange::QCPRange(<span class="keywordtype">double</span> lower, <span class="keywordtype">double</span> upper)
<a name="l02641"></a>02641 {
<a name="l02642"></a>02642   this-&gt;lower = lower;
<a name="l02643"></a>02643   this-&gt;upper = upper;
<a name="l02644"></a>02644   normalize();
<a name="l02645"></a>02645 }
<a name="l02646"></a>02646 
<a name="l02650"></a>02650 <span class="keywordtype">double</span> QCPRange::size()<span class="keyword"> const</span>
<a name="l02651"></a>02651 <span class="keyword"></span>{
<a name="l02652"></a>02652   <span class="keywordflow">return</span> upper-lower;
<a name="l02653"></a>02653 }
<a name="l02654"></a>02654 
<a name="l02658"></a>02658 <span class="keywordtype">double</span> QCPRange::center()<span class="keyword"> const</span>
<a name="l02659"></a>02659 <span class="keyword"></span>{
<a name="l02660"></a>02660   <span class="keywordflow">return</span> (upper+lower)*0.5;
<a name="l02661"></a>02661 }
<a name="l02662"></a>02662 
<a name="l02667"></a>02667 <span class="keywordtype">void</span> QCPRange::normalize()
<a name="l02668"></a>02668 {
<a name="l02669"></a>02669   <span class="keywordflow">if</span> (lower &gt; upper)
<a name="l02670"></a>02670     qSwap(lower, upper);
<a name="l02671"></a>02671 }
<a name="l02672"></a>02672 
<a name="l02685"></a>02685 QCPRange QCPRange::sanitizedForLogScale()<span class="keyword"> const</span>
<a name="l02686"></a>02686 <span class="keyword"></span>{
<a name="l02687"></a>02687   <span class="keywordtype">double</span> rangeFac = 1e-3;
<a name="l02688"></a>02688   QCPRange sanitizedRange(lower, upper);
<a name="l02689"></a>02689   sanitizedRange.normalize();
<a name="l02690"></a>02690   <span class="comment">// can&#39;t have range spanning negative and positive values in log plot, so change range to fix it</span>
<a name="l02691"></a>02691   <span class="comment">//if (qFuzzyCompare(sanitizedRange.lower+1, 1) &amp;&amp; !qFuzzyCompare(sanitizedRange.upper+1, 1))</span>
<a name="l02692"></a>02692   <span class="keywordflow">if</span> (sanitizedRange.lower == 0.0 &amp;&amp; sanitizedRange.upper != 0.0)
<a name="l02693"></a>02693   {
<a name="l02694"></a>02694     <span class="comment">// case lower is 0</span>
<a name="l02695"></a>02695     <span class="keywordflow">if</span> (rangeFac &lt; sanitizedRange.upper*rangeFac)
<a name="l02696"></a>02696       sanitizedRange.lower = rangeFac;
<a name="l02697"></a>02697     <span class="keywordflow">else</span>
<a name="l02698"></a>02698       sanitizedRange.lower = sanitizedRange.upper*rangeFac;
<a name="l02699"></a>02699   } <span class="comment">//else if (!qFuzzyCompare(lower+1, 1) &amp;&amp; qFuzzyCompare(upper+1, 1))</span>
<a name="l02700"></a>02700   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sanitizedRange.lower != 0.0 &amp;&amp; sanitizedRange.upper == 0.0)
<a name="l02701"></a>02701   {
<a name="l02702"></a>02702     <span class="comment">// case upper is 0</span>
<a name="l02703"></a>02703     <span class="keywordflow">if</span> (-rangeFac &gt; sanitizedRange.lower*rangeFac)
<a name="l02704"></a>02704       sanitizedRange.upper = -rangeFac;
<a name="l02705"></a>02705     <span class="keywordflow">else</span>
<a name="l02706"></a>02706       sanitizedRange.upper = sanitizedRange.lower*rangeFac;
<a name="l02707"></a>02707   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sanitizedRange.lower &lt; 0 &amp;&amp; sanitizedRange.upper &gt; 0)
<a name="l02708"></a>02708   {
<a name="l02709"></a>02709     <span class="comment">// find out whether negative or positive interval is wider to decide which sign domain will be chosen</span>
<a name="l02710"></a>02710     <span class="keywordflow">if</span> (-sanitizedRange.lower &gt; sanitizedRange.upper)
<a name="l02711"></a>02711     {
<a name="l02712"></a>02712       <span class="comment">// negative is wider, do same as in case upper is 0</span>
<a name="l02713"></a>02713       <span class="keywordflow">if</span> (-rangeFac &gt; sanitizedRange.lower*rangeFac)
<a name="l02714"></a>02714         sanitizedRange.upper = -rangeFac;
<a name="l02715"></a>02715       <span class="keywordflow">else</span>
<a name="l02716"></a>02716         sanitizedRange.upper = sanitizedRange.lower*rangeFac;
<a name="l02717"></a>02717     } <span class="keywordflow">else</span>
<a name="l02718"></a>02718     {
<a name="l02719"></a>02719       <span class="comment">// positive is wider, do same as in case lower is 0</span>
<a name="l02720"></a>02720       <span class="keywordflow">if</span> (rangeFac &lt; sanitizedRange.upper*rangeFac)
<a name="l02721"></a>02721         sanitizedRange.lower = rangeFac;
<a name="l02722"></a>02722       <span class="keywordflow">else</span>
<a name="l02723"></a>02723         sanitizedRange.lower = sanitizedRange.upper*rangeFac;
<a name="l02724"></a>02724     }
<a name="l02725"></a>02725   }
<a name="l02726"></a>02726   <span class="comment">// due to normalization, case lower&gt;0 &amp;&amp; upper&lt;0 should never occur, because that implies upper&lt;lower</span>
<a name="l02727"></a>02727   <span class="keywordflow">return</span> sanitizedRange;
<a name="l02728"></a>02728 }
<a name="l02729"></a>02729 
<a name="l02734"></a>02734 QCPRange QCPRange::sanitizedForLinScale()<span class="keyword"> const</span>
<a name="l02735"></a>02735 <span class="keyword"></span>{
<a name="l02736"></a>02736   QCPRange sanitizedRange(lower, upper);
<a name="l02737"></a>02737   sanitizedRange.normalize();
<a name="l02738"></a>02738   <span class="keywordflow">return</span> sanitizedRange;
<a name="l02739"></a>02739 }
<a name="l02740"></a>02740 
<a name="l02744"></a>02744 <span class="keywordtype">bool</span> QCPRange::contains(<span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l02745"></a>02745 <span class="keyword"></span>{
<a name="l02746"></a>02746   <span class="keywordflow">return</span> value &gt;= lower &amp;&amp; value &lt;= upper;
<a name="l02747"></a>02747 }
<a name="l02748"></a>02748 
<a name="l02757"></a>02757 <span class="keywordtype">bool</span> QCPRange::validRange(<span class="keywordtype">double</span> lower, <span class="keywordtype">double</span> upper)
<a name="l02758"></a>02758 {
<a name="l02759"></a>02759   <span class="comment">/*</span>
<a name="l02760"></a>02760 <span class="comment">  return (lower &gt; -maxRange &amp;&amp;</span>
<a name="l02761"></a>02761 <span class="comment">          upper &lt; maxRange &amp;&amp;</span>
<a name="l02762"></a>02762 <span class="comment">          fabs(lower-upper) &gt; minRange &amp;&amp;</span>
<a name="l02763"></a>02763 <span class="comment">          (lower &lt; -minRange || lower &gt; minRange) &amp;&amp;</span>
<a name="l02764"></a>02764 <span class="comment">          (upper &lt; -minRange || upper &gt; minRange));</span>
<a name="l02765"></a>02765 <span class="comment">          */</span>
<a name="l02766"></a>02766   <span class="keywordflow">return</span> (lower &gt; -maxRange &amp;&amp;
<a name="l02767"></a>02767           upper &lt; maxRange &amp;&amp;
<a name="l02768"></a>02768           fabs(lower-upper) &gt; minRange &amp;&amp;
<a name="l02769"></a>02769           fabs(lower-upper) &lt; maxRange);
<a name="l02770"></a>02770 }
<a name="l02771"></a>02771 
<a name="l02781"></a>02781 <span class="keywordtype">bool</span> QCPRange::validRange(<span class="keyword">const</span> QCPRange &amp;range)
<a name="l02782"></a>02782 {
<a name="l02783"></a>02783   <span class="comment">/*</span>
<a name="l02784"></a>02784 <span class="comment">  return (range.lower &gt; -maxRange &amp;&amp;</span>
<a name="l02785"></a>02785 <span class="comment">          range.upper &lt; maxRange &amp;&amp;</span>
<a name="l02786"></a>02786 <span class="comment">          fabs(range.lower-range.upper) &gt; minRange &amp;&amp;</span>
<a name="l02787"></a>02787 <span class="comment">          fabs(range.lower-range.upper) &lt; maxRange &amp;&amp;</span>
<a name="l02788"></a>02788 <span class="comment">          (range.lower &lt; -minRange || range.lower &gt; minRange) &amp;&amp;</span>
<a name="l02789"></a>02789 <span class="comment">          (range.upper &lt; -minRange || range.upper &gt; minRange));</span>
<a name="l02790"></a>02790 <span class="comment">          */</span>
<a name="l02791"></a>02791   <span class="keywordflow">return</span> (range.lower &gt; -maxRange &amp;&amp;
<a name="l02792"></a>02792           range.upper &lt; maxRange &amp;&amp;
<a name="l02793"></a>02793           fabs(range.lower-range.upper) &gt; minRange &amp;&amp;
<a name="l02794"></a>02794           fabs(range.lower-range.upper) &lt; maxRange);
<a name="l02795"></a>02795 }
<a name="l02796"></a>02796 
<a name="l02797"></a>02797 
<a name="l02798"></a>02798 <span class="comment">// ================================================================================</span>
<a name="l02799"></a>02799 <span class="comment">// =================== QCPLegend</span>
<a name="l02800"></a>02800 <span class="comment">// ================================================================================</span>
<a name="l02801"></a>02801 
<a name="l02808"></a>02808 <span class="comment">/* start of documentation of signals */</span>
<a name="l02809"></a>02809 
<a name="l02817"></a>02817 <span class="comment">/* end of documentation of signals */</span>
<a name="l02818"></a>02818 
<a name="l02825"></a>02825 QCPLegend::QCPLegend(QCustomPlot *parentPlot) : 
<a name="l02826"></a>02826   QObject(parentPlot),
<a name="l02827"></a>02827   mParentPlot(parentPlot)
<a name="l02828"></a>02828 {
<a name="l02829"></a>02829   setVisible(<span class="keyword">true</span>);
<a name="l02830"></a>02830   setBorderPen(QPen(Qt::black));
<a name="l02831"></a>02831   setIconBorderPen(Qt::NoPen);
<a name="l02832"></a>02832   setBrush(QBrush(Qt::white));
<a name="l02833"></a>02833   setFont(parentPlot-&gt;font());
<a name="l02834"></a>02834   setTextColor(Qt::black);
<a name="l02835"></a>02835   setPositionStyle(psTopRight);
<a name="l02836"></a>02836   setSize(100, 28);
<a name="l02837"></a>02837   setMinimumSize(100, 0);
<a name="l02838"></a>02838   setAutoSize(<span class="keyword">true</span>);
<a name="l02839"></a>02839   
<a name="l02840"></a>02840   setMargin(12, 12, 12, 12);
<a name="l02841"></a>02841   setPadding(8, 8, 3, 3);
<a name="l02842"></a>02842   setIconSize(32, 18);
<a name="l02843"></a>02843   setItemSpacing(3);
<a name="l02844"></a>02844   setIconTextPadding(7);
<a name="l02845"></a>02845   
<a name="l02846"></a>02846   setSelectedFont(parentPlot-&gt;font());
<a name="l02847"></a>02847   setSelectedTextColor(Qt::blue);
<a name="l02848"></a>02848   QPen selBorder;
<a name="l02849"></a>02849   selBorder.setColor(Qt::blue);
<a name="l02850"></a>02850   selBorder.setWidth(2);
<a name="l02851"></a>02851   setSelectedBorderPen(selBorder);
<a name="l02852"></a>02852   QPen selIcon;
<a name="l02853"></a>02853   selIcon.setColor(Qt::blue);
<a name="l02854"></a>02854   selIcon.setWidth(2);
<a name="l02855"></a>02855   setSelectedIconBorderPen(selIcon);
<a name="l02856"></a>02856   setSelectedBrush(brush());
<a name="l02857"></a>02857   setSelectable(spLegendBox | spItems);
<a name="l02858"></a>02858   setSelected(spNone);
<a name="l02859"></a>02859 }
<a name="l02860"></a>02860 
<a name="l02861"></a>02861 QCPLegend::~QCPLegend()
<a name="l02862"></a>02862 {
<a name="l02863"></a>02863   clearItems();
<a name="l02864"></a>02864 }
<a name="l02865"></a>02865 
<a name="l02869"></a>02869 <span class="keywordtype">void</span> QCPLegend::setBorderPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l02870"></a>02870 {
<a name="l02871"></a>02871   mBorderPen = pen;
<a name="l02872"></a>02872 }
<a name="l02873"></a>02873 
<a name="l02877"></a>02877 <span class="keywordtype">void</span> QCPLegend::setBrush(<span class="keyword">const</span> QBrush &amp;brush)
<a name="l02878"></a>02878 {
<a name="l02879"></a>02879   mBrush = brush;
<a name="l02880"></a>02880 }
<a name="l02881"></a>02881 
<a name="l02891"></a>02891 <span class="keywordtype">void</span> QCPLegend::setFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l02892"></a>02892 {
<a name="l02893"></a>02893   mFont = font;
<a name="l02894"></a>02894   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l02895"></a>02895     mItems.at(i)-&gt;setFont(mFont);
<a name="l02896"></a>02896 }
<a name="l02897"></a>02897 
<a name="l02907"></a>02907 <span class="keywordtype">void</span> QCPLegend::setTextColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l02908"></a>02908 {
<a name="l02909"></a>02909   mTextColor = color;
<a name="l02910"></a>02910   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l02911"></a>02911     mItems.at(i)-&gt;setTextColor(color);
<a name="l02912"></a>02912 }
<a name="l02913"></a>02913 
<a name="l02921"></a>02921 <span class="keywordtype">void</span> QCPLegend::setPositionStyle(PositionStyle legendPositionStyle)
<a name="l02922"></a>02922 {
<a name="l02923"></a>02923   mPositionStyle = legendPositionStyle;
<a name="l02924"></a>02924 }
<a name="l02925"></a>02925 
<a name="l02930"></a>02930 <span class="keywordtype">void</span> QCPLegend::setPosition(<span class="keyword">const</span> QPoint &amp;pixelPosition)
<a name="l02931"></a>02931 {
<a name="l02932"></a>02932   mPosition = pixelPosition;
<a name="l02933"></a>02933 }
<a name="l02934"></a>02934 
<a name="l02944"></a>02944 <span class="keywordtype">void</span> QCPLegend::setAutoSize(<span class="keywordtype">bool</span> on)
<a name="l02945"></a>02945 {
<a name="l02946"></a>02946   mAutoSize = on;
<a name="l02947"></a>02947 }
<a name="l02948"></a>02948 
<a name="l02958"></a>02958 <span class="keywordtype">void</span> QCPLegend::setSize(<span class="keyword">const</span> QSize &amp;size)
<a name="l02959"></a>02959 {
<a name="l02960"></a>02960   mSize = size;
<a name="l02961"></a>02961 }
<a name="l02962"></a>02962 
<a name="l02965"></a>02965 <span class="keywordtype">void</span> QCPLegend::setSize(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
<a name="l02966"></a>02966 {
<a name="l02967"></a>02967   mSize = QSize(width, height);
<a name="l02968"></a>02968 }
<a name="l02969"></a>02969 
<a name="l02981"></a>02981 <span class="keywordtype">void</span> QCPLegend::setMinimumSize(<span class="keyword">const</span> QSize &amp;size)
<a name="l02982"></a>02982 {
<a name="l02983"></a>02983   mMinimumSize = size;
<a name="l02984"></a>02984 }
<a name="l02985"></a>02985 
<a name="l02988"></a>02988 <span class="keywordtype">void</span> QCPLegend::setMinimumSize(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
<a name="l02989"></a>02989 {
<a name="l02990"></a>02990   mMinimumSize = QSize(width, height);
<a name="l02991"></a>02991 }
<a name="l02992"></a>02992 
<a name="l02996"></a>02996 <span class="keywordtype">void</span> QCPLegend::setVisible(<span class="keywordtype">bool</span> on)
<a name="l02997"></a>02997 {
<a name="l02998"></a>02998   mVisible = on;
<a name="l02999"></a>02999 }
<a name="l03000"></a>03000 
<a name="l03006"></a>03006 <span class="keywordtype">void</span> QCPLegend::setPaddingLeft(<span class="keywordtype">int</span> padding)
<a name="l03007"></a>03007 {
<a name="l03008"></a>03008   mPaddingLeft = padding;
<a name="l03009"></a>03009 }
<a name="l03010"></a>03010 
<a name="l03016"></a>03016 <span class="keywordtype">void</span> QCPLegend::setPaddingRight(<span class="keywordtype">int</span> padding)
<a name="l03017"></a>03017 {
<a name="l03018"></a>03018   mPaddingRight = padding;
<a name="l03019"></a>03019 }
<a name="l03020"></a>03020 
<a name="l03026"></a>03026 <span class="keywordtype">void</span> QCPLegend::setPaddingTop(<span class="keywordtype">int</span> padding)
<a name="l03027"></a>03027 {
<a name="l03028"></a>03028   mPaddingTop = padding;
<a name="l03029"></a>03029 }
<a name="l03030"></a>03030 
<a name="l03036"></a>03036 <span class="keywordtype">void</span> QCPLegend::setPaddingBottom(<span class="keywordtype">int</span> padding)
<a name="l03037"></a>03037 {
<a name="l03038"></a>03038   mPaddingBottom = padding;
<a name="l03039"></a>03039 }
<a name="l03040"></a>03040 
<a name="l03046"></a>03046 <span class="keywordtype">void</span> QCPLegend::setPadding(<span class="keywordtype">int</span> left, <span class="keywordtype">int</span> right, <span class="keywordtype">int</span> top, <span class="keywordtype">int</span> bottom)
<a name="l03047"></a>03047 {
<a name="l03048"></a>03048   mPaddingLeft = left;
<a name="l03049"></a>03049   mPaddingRight = right;
<a name="l03050"></a>03050   mPaddingTop = top;
<a name="l03051"></a>03051   mPaddingBottom = bottom;
<a name="l03052"></a>03052 }
<a name="l03053"></a>03053 
<a name="l03058"></a>03058 <span class="keywordtype">void</span> QCPLegend::setMarginLeft(<span class="keywordtype">int</span> margin)
<a name="l03059"></a>03059 {
<a name="l03060"></a>03060   mMarginLeft = margin;
<a name="l03061"></a>03061 }
<a name="l03062"></a>03062 
<a name="l03067"></a>03067 <span class="keywordtype">void</span> QCPLegend::setMarginRight(<span class="keywordtype">int</span> margin)
<a name="l03068"></a>03068 {
<a name="l03069"></a>03069   mMarginRight = margin;
<a name="l03070"></a>03070 }
<a name="l03071"></a>03071 
<a name="l03076"></a>03076 <span class="keywordtype">void</span> QCPLegend::setMarginTop(<span class="keywordtype">int</span> margin)
<a name="l03077"></a>03077 {
<a name="l03078"></a>03078   mMarginTop = margin;
<a name="l03079"></a>03079 }
<a name="l03080"></a>03080 
<a name="l03085"></a>03085 <span class="keywordtype">void</span> QCPLegend::setMarginBottom(<span class="keywordtype">int</span> margin)
<a name="l03086"></a>03086 {
<a name="l03087"></a>03087   mMarginBottom = margin;
<a name="l03088"></a>03088 }
<a name="l03089"></a>03089 
<a name="l03094"></a>03094 <span class="keywordtype">void</span> QCPLegend::setMargin(<span class="keywordtype">int</span> left, <span class="keywordtype">int</span> right, <span class="keywordtype">int</span> top, <span class="keywordtype">int</span> bottom)
<a name="l03095"></a>03095 {
<a name="l03096"></a>03096   mMarginLeft = left;
<a name="l03097"></a>03097   mMarginRight = right;
<a name="l03098"></a>03098   mMarginTop = top;
<a name="l03099"></a>03099   mMarginBottom = bottom;
<a name="l03100"></a>03100 }
<a name="l03101"></a>03101 
<a name="l03107"></a>03107 <span class="keywordtype">void</span> QCPLegend::setItemSpacing(<span class="keywordtype">int</span> spacing)
<a name="l03108"></a>03108 {
<a name="l03109"></a>03109   mItemSpacing = spacing;
<a name="l03110"></a>03110 }
<a name="l03111"></a>03111 
<a name="l03117"></a>03117 <span class="keywordtype">void</span> QCPLegend::setIconSize(<span class="keyword">const</span> QSize &amp;size)
<a name="l03118"></a>03118 {
<a name="l03119"></a>03119   mIconSize = size;
<a name="l03120"></a>03120 }
<a name="l03121"></a>03121 
<a name="l03124"></a>03124 <span class="keywordtype">void</span> QCPLegend::setIconSize(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
<a name="l03125"></a>03125 {
<a name="l03126"></a>03126   mIconSize.setWidth(width);
<a name="l03127"></a>03127   mIconSize.setHeight(height);
<a name="l03128"></a>03128 }
<a name="l03129"></a>03129 
<a name="l03138"></a>03138 <span class="keywordtype">void</span> QCPLegend::setIconTextPadding(<span class="keywordtype">int</span> padding)
<a name="l03139"></a>03139 {
<a name="l03140"></a>03140   mIconTextPadding = padding;
<a name="l03141"></a>03141 }
<a name="l03142"></a>03142 
<a name="l03150"></a>03150 <span class="keywordtype">void</span> QCPLegend::setIconBorderPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l03151"></a>03151 {
<a name="l03152"></a>03152   mIconBorderPen = pen;
<a name="l03153"></a>03153 }
<a name="l03154"></a>03154 
<a name="l03165"></a>03165 <span class="keywordtype">void</span> QCPLegend::setSelectable(<span class="keyword">const</span> SelectableParts &amp;selectable)
<a name="l03166"></a>03166 {
<a name="l03167"></a>03167   mSelectable = selectable;
<a name="l03168"></a>03168 }
<a name="l03169"></a>03169 
<a name="l03191"></a>03191 <span class="keywordtype">void</span> QCPLegend::setSelected(<span class="keyword">const</span> SelectableParts &amp;selected)
<a name="l03192"></a>03192 {
<a name="l03193"></a>03193   <span class="keywordflow">if</span> (mSelected != selected)
<a name="l03194"></a>03194   {
<a name="l03195"></a>03195     <span class="keywordflow">if</span> (!selected.testFlag(spItems) &amp;&amp; mSelected.testFlag(spItems)) <span class="comment">// some items are selected, but new selection state doesn&#39;t contain spItems, so deselect them</span>
<a name="l03196"></a>03196     {
<a name="l03197"></a>03197       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l03198"></a>03198         mItems.at(i)-&gt;setSelected(<span class="keyword">false</span>);
<a name="l03199"></a>03199       mSelected = selected;
<a name="l03200"></a>03200       <span class="comment">// not necessary to emit selectionChanged here because this will have happened for the last setSelected(false) on mItems already, via updateSelectionState()</span>
<a name="l03201"></a>03201     } <span class="keywordflow">else</span>
<a name="l03202"></a>03202     {
<a name="l03203"></a>03203       mSelected = selected;
<a name="l03204"></a>03204       emit selectionChanged(mSelected);
<a name="l03205"></a>03205     }
<a name="l03206"></a>03206   }
<a name="l03207"></a>03207 }
<a name="l03208"></a>03208 
<a name="l03215"></a>03215 <span class="keywordtype">void</span> QCPLegend::setSelectedBorderPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l03216"></a>03216 {
<a name="l03217"></a>03217   mSelectedBorderPen = pen;
<a name="l03218"></a>03218 }
<a name="l03219"></a>03219 
<a name="l03225"></a>03225 <span class="keywordtype">void</span> QCPLegend::setSelectedIconBorderPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l03226"></a>03226 {
<a name="l03227"></a>03227   mSelectedIconBorderPen = pen;
<a name="l03228"></a>03228 }
<a name="l03229"></a>03229 
<a name="l03236"></a>03236 <span class="keywordtype">void</span> QCPLegend::setSelectedBrush(<span class="keyword">const</span> QBrush &amp;brush)
<a name="l03237"></a>03237 {
<a name="l03238"></a>03238   mSelectedBrush = brush;
<a name="l03239"></a>03239 }
<a name="l03240"></a>03240 
<a name="l03248"></a>03248 <span class="keywordtype">void</span> QCPLegend::setSelectedFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l03249"></a>03249 {
<a name="l03250"></a>03250   mSelectedFont = font;
<a name="l03251"></a>03251   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l03252"></a>03252     mItems.at(i)-&gt;setSelectedFont(font);
<a name="l03253"></a>03253 }
<a name="l03254"></a>03254 
<a name="l03262"></a>03262 <span class="keywordtype">void</span> QCPLegend::setSelectedTextColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l03263"></a>03263 {
<a name="l03264"></a>03264   mSelectedTextColor = color;
<a name="l03265"></a>03265   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l03266"></a>03266     mItems.at(i)-&gt;setSelectedTextColor(color);
<a name="l03267"></a>03267 }
<a name="l03268"></a>03268 
<a name="l03274"></a>03274 QCPAbstractLegendItem *QCPLegend::item(<span class="keywordtype">int</span> index)<span class="keyword"> const</span>
<a name="l03275"></a>03275 <span class="keyword"></span>{
<a name="l03276"></a>03276   <span class="keywordflow">if</span> (index &gt;= 0 &amp;&amp; index &lt; mItems.size())
<a name="l03277"></a>03277     <span class="keywordflow">return</span> mItems[index];
<a name="l03278"></a>03278   <span class="keywordflow">else</span>
<a name="l03279"></a>03279     <span class="keywordflow">return</span> 0;
<a name="l03280"></a>03280 }
<a name="l03281"></a>03281 
<a name="l03288"></a>03288 QCPPlottableLegendItem *QCPLegend::itemWithPlottable(<span class="keyword">const</span> QCPAbstractPlottable *plottable)<span class="keyword"> const</span>
<a name="l03289"></a>03289 <span class="keyword"></span>{
<a name="l03290"></a>03290   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l03291"></a>03291   {
<a name="l03292"></a>03292     <span class="keywordflow">if</span> (QCPPlottableLegendItem *pli = qobject_cast&lt;QCPPlottableLegendItem*&gt;(mItems.at(i)))
<a name="l03293"></a>03293     {
<a name="l03294"></a>03294       <span class="keywordflow">if</span> (pli-&gt;plottable() == plottable)
<a name="l03295"></a>03295         <span class="keywordflow">return</span> pli;
<a name="l03296"></a>03296     }
<a name="l03297"></a>03297   }
<a name="l03298"></a>03298   <span class="keywordflow">return</span> 0;
<a name="l03299"></a>03299 }
<a name="l03300"></a>03300 
<a name="l03305"></a>03305 <span class="keywordtype">int</span> QCPLegend::itemCount()<span class="keyword"> const</span>
<a name="l03306"></a>03306 <span class="keyword"></span>{
<a name="l03307"></a>03307   <span class="keywordflow">return</span> mItems.size();
<a name="l03308"></a>03308 }
<a name="l03309"></a>03309 
<a name="l03313"></a>03313 <span class="keywordtype">bool</span> QCPLegend::hasItem(QCPAbstractLegendItem *item)<span class="keyword"> const</span>
<a name="l03314"></a>03314 <span class="keyword"></span>{
<a name="l03315"></a>03315   <span class="keywordflow">return</span> mItems.contains(item);
<a name="l03316"></a>03316 }
<a name="l03317"></a>03317 
<a name="l03324"></a>03324 <span class="keywordtype">bool</span> QCPLegend::hasItemWithPlottable(<span class="keyword">const</span> QCPAbstractPlottable *plottable)<span class="keyword"> const</span>
<a name="l03325"></a>03325 <span class="keyword"></span>{
<a name="l03326"></a>03326   <span class="keywordflow">return</span> itemWithPlottable(plottable);
<a name="l03327"></a>03327 }
<a name="l03328"></a>03328 
<a name="l03336"></a>03336 <span class="keywordtype">bool</span> QCPLegend::addItem(QCPAbstractLegendItem *item)
<a name="l03337"></a>03337 {
<a name="l03338"></a>03338   <span class="keywordflow">if</span> (!mItems.contains(item))
<a name="l03339"></a>03339   {
<a name="l03340"></a>03340     mItems.append(item);
<a name="l03341"></a>03341     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03342"></a>03342   } <span class="keywordflow">else</span>
<a name="l03343"></a>03343     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03344"></a>03344 }
<a name="l03345"></a>03345 
<a name="l03353"></a>03353 <span class="keywordtype">bool</span> QCPLegend::removeItem(<span class="keywordtype">int</span> index)
<a name="l03354"></a>03354 {
<a name="l03355"></a>03355   <span class="keywordflow">if</span> (index &gt;= 0 &amp;&amp; index &lt; mItems.size())
<a name="l03356"></a>03356   {
<a name="l03357"></a>03357     mItemBoundingBoxes.remove(mItems.at(index));
<a name="l03358"></a>03358     <span class="keyword">delete</span> mItems.at(index);
<a name="l03359"></a>03359     mItems.removeAt(index);
<a name="l03360"></a>03360     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03361"></a>03361   } <span class="keywordflow">else</span>
<a name="l03362"></a>03362     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03363"></a>03363 }
<a name="l03364"></a>03364 
<a name="l03373"></a>03373 <span class="keywordtype">bool</span> QCPLegend::removeItem(QCPAbstractLegendItem *item)
<a name="l03374"></a>03374 {
<a name="l03375"></a>03375   <span class="keywordflow">return</span> removeItem(mItems.indexOf(item));
<a name="l03376"></a>03376 }
<a name="l03377"></a>03377 
<a name="l03381"></a>03381 <span class="keywordtype">void</span> QCPLegend::clearItems()
<a name="l03382"></a>03382 {
<a name="l03383"></a>03383   qDeleteAll(mItems);
<a name="l03384"></a>03384   mItems.clear();
<a name="l03385"></a>03385   mItemBoundingBoxes.clear();
<a name="l03386"></a>03386 }
<a name="l03387"></a>03387 
<a name="l03388"></a>03388 
<a name="l03395"></a>03395 QList&lt;QCPAbstractLegendItem *&gt; QCPLegend::selectedItems()<span class="keyword"> const</span>
<a name="l03396"></a>03396 <span class="keyword"></span>{
<a name="l03397"></a>03397   QList&lt;QCPAbstractLegendItem*&gt; result;
<a name="l03398"></a>03398   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l03399"></a>03399   {
<a name="l03400"></a>03400     <span class="keywordflow">if</span> (mItems.at(i)-&gt;selected())
<a name="l03401"></a>03401       result.append(mItems.at(i));
<a name="l03402"></a>03402   }
<a name="l03403"></a>03403   <span class="keywordflow">return</span> result;
<a name="l03404"></a>03404 }
<a name="l03405"></a>03405 
<a name="l03411"></a>03411 <span class="keywordtype">void</span>  QCPLegend::reArrange()
<a name="l03412"></a>03412 {
<a name="l03413"></a>03413   <span class="keywordflow">if</span> (mAutoSize)
<a name="l03414"></a>03414   {
<a name="l03415"></a>03415     calculateAutoSize();
<a name="l03416"></a>03416   }
<a name="l03417"></a>03417   calculateAutoPosition();
<a name="l03418"></a>03418 }
<a name="l03419"></a>03419 
<a name="l03425"></a>03425 <span class="keywordtype">bool</span> QCPLegend::selectTestLegend(<span class="keyword">const</span> QPoint pos)<span class="keyword"> const</span>
<a name="l03426"></a>03426 <span class="keyword"></span>{
<a name="l03427"></a>03427   <span class="keywordflow">return</span> QRect(mPosition, mSize).contains(pos);
<a name="l03428"></a>03428 }
<a name="l03429"></a>03429 
<a name="l03436"></a>03436 QCPAbstractLegendItem *QCPLegend::selectTestItem(<span class="keyword">const</span> QPoint pos)<span class="keyword"> const</span>
<a name="l03437"></a>03437 <span class="keyword"></span>{
<a name="l03438"></a>03438   QMap&lt;QCPAbstractLegendItem*, QRect&gt;::const_iterator it;
<a name="l03439"></a>03439   <span class="keywordflow">for</span> (it = mItemBoundingBoxes.constBegin(); it != mItemBoundingBoxes.constEnd(); ++it)
<a name="l03440"></a>03440   {
<a name="l03441"></a>03441     <span class="keywordflow">if</span> (it.value().contains(pos) &amp;&amp; mItems.contains(it.key()))
<a name="l03442"></a>03442       <span class="keywordflow">return</span> it.key();
<a name="l03443"></a>03443   }
<a name="l03444"></a>03444   <span class="keywordflow">return</span> 0;
<a name="l03445"></a>03445 }
<a name="l03446"></a>03446 
<a name="l03459"></a>03459 <span class="keywordtype">void</span> QCPLegend::updateSelectionState()
<a name="l03460"></a>03460 {
<a name="l03461"></a>03461   <span class="keywordtype">bool</span> hasSelections = <span class="keyword">false</span>;
<a name="l03462"></a>03462   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l03463"></a>03463   {
<a name="l03464"></a>03464     <span class="keywordflow">if</span> (mItems.at(i)-&gt;selected())
<a name="l03465"></a>03465     {
<a name="l03466"></a>03466       hasSelections = <span class="keyword">true</span>;
<a name="l03467"></a>03467       <span class="keywordflow">break</span>;
<a name="l03468"></a>03468     }
<a name="l03469"></a>03469   }
<a name="l03470"></a>03470   
<a name="l03471"></a>03471   <span class="comment">// in the following we don&#39;t use setSelected because it would cause unnecessary</span>
<a name="l03472"></a>03472   <span class="comment">// logic looping through items if spItems isn&#39;t set in the new state. (look at setSelected and you&#39;ll understand)</span>
<a name="l03473"></a>03473   <span class="keywordflow">if</span> (hasSelections &amp;&amp; !mSelected.testFlag(spItems))
<a name="l03474"></a>03474   {
<a name="l03475"></a>03475     mSelected |= spItems;
<a name="l03476"></a>03476     emit selectionChanged(mSelected);
<a name="l03477"></a>03477   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!hasSelections &amp;&amp; mSelected.testFlag(spItems))
<a name="l03478"></a>03478   {
<a name="l03479"></a>03479     mSelected &amp;= ~spItems;
<a name="l03480"></a>03480     emit selectionChanged(mSelected);
<a name="l03481"></a>03481   }
<a name="l03482"></a>03482 }
<a name="l03483"></a>03483 
<a name="l03497"></a>03497 <span class="keywordtype">bool</span> QCPLegend::handleLegendSelection(QMouseEvent *event, <span class="keywordtype">bool</span> additiveSelection, <span class="keywordtype">bool</span> &amp;modified)
<a name="l03498"></a>03498 {
<a name="l03499"></a>03499   modified = <span class="keyword">false</span>;
<a name="l03500"></a>03500   <span class="keywordtype">bool</span> selectionFound = <span class="keyword">false</span>;
<a name="l03501"></a>03501   
<a name="l03502"></a>03502   <span class="keywordflow">if</span> (event &amp;&amp; selectTestLegend(event-&gt;pos())) <span class="comment">// clicked inside legend somewhere</span>
<a name="l03503"></a>03503   {
<a name="l03504"></a>03504     QCPAbstractLegendItem *ali = selectTestItem(event-&gt;pos());
<a name="l03505"></a>03505     <span class="keywordflow">if</span> (selectable().testFlag(QCPLegend::spItems) &amp;&amp; ali &amp;&amp; ali-&gt;selectable()) <span class="comment">// items shall be selectable and item ali was clicked </span>
<a name="l03506"></a>03506     {
<a name="l03507"></a>03507       selectionFound = <span class="keyword">true</span>;
<a name="l03508"></a>03508       <span class="comment">// deselect legend box:</span>
<a name="l03509"></a>03509       <span class="keywordflow">if</span> (!additiveSelection &amp;&amp; selected().testFlag(QCPLegend::spLegendBox) &amp;&amp; selectable().testFlag(QCPLegend::spLegendBox))
<a name="l03510"></a>03510         setSelected(selected() &amp; ~QCPLegend::spLegendBox);
<a name="l03511"></a>03511       <span class="comment">// first select clicked item:</span>
<a name="l03512"></a>03512       <span class="keywordflow">if</span> (!ali-&gt;selected() || additiveSelection) <span class="comment">// if additive selection, we toggle selection on and off per click</span>
<a name="l03513"></a>03513       {
<a name="l03514"></a>03514         modified = <span class="keyword">true</span>;
<a name="l03515"></a>03515         ali-&gt;setSelected(!ali-&gt;selected());
<a name="l03516"></a>03516       }
<a name="l03517"></a>03517       <span class="comment">// finally, deselect all other items (if we had deselected all first, the selectionChanged signal of QCPLegend might have been emitted twice):</span>
<a name="l03518"></a>03518       <span class="keywordflow">if</span> (!additiveSelection)
<a name="l03519"></a>03519       {
<a name="l03520"></a>03520         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;itemCount(); ++i)
<a name="l03521"></a>03521         {
<a name="l03522"></a>03522           <span class="keywordflow">if</span> (item(i) != ali &amp;&amp; item(i)-&gt;selected() &amp;&amp; item(i)-&gt;selectable())
<a name="l03523"></a>03523           {
<a name="l03524"></a>03524             modified = <span class="keyword">true</span>;
<a name="l03525"></a>03525             item(i)-&gt;setSelected(<span class="keyword">false</span>);
<a name="l03526"></a>03526           }
<a name="l03527"></a>03527         }
<a name="l03528"></a>03528       }
<a name="l03529"></a>03529     } <span class="keywordflow">else</span> <span class="comment">// no specific item clicked or items not selectable</span>
<a name="l03530"></a>03530     {
<a name="l03531"></a>03531       <span class="comment">// if items actually were selectable, this means none were clicked, deselect them:</span>
<a name="l03532"></a>03532       <span class="keywordflow">if</span> (selectable().testFlag(QCPLegend::spItems) &amp;&amp; selected().testFlag(QCPLegend::spItems) &amp;&amp; !additiveSelection)
<a name="l03533"></a>03533       {
<a name="l03534"></a>03534         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;itemCount(); ++i)
<a name="l03535"></a>03535         {
<a name="l03536"></a>03536           <span class="keywordflow">if</span> (item(i)-&gt;selectable())
<a name="l03537"></a>03537             item(i)-&gt;setSelected(<span class="keyword">false</span>);
<a name="l03538"></a>03538         }
<a name="l03539"></a>03539         modified = <span class="keyword">true</span>;
<a name="l03540"></a>03540       }
<a name="l03541"></a>03541       <span class="comment">// if legend box is selectable, select it:</span>
<a name="l03542"></a>03542       <span class="keywordflow">if</span> (selectable().testFlag(QCPLegend::spLegendBox))
<a name="l03543"></a>03543       {
<a name="l03544"></a>03544         <span class="keywordflow">if</span> (!selected().testFlag(QCPLegend::spLegendBox) || additiveSelection)
<a name="l03545"></a>03545         {
<a name="l03546"></a>03546           selectionFound = <span class="keyword">true</span>;
<a name="l03547"></a>03547           setSelected(selected() ^ QCPLegend::spLegendBox); <span class="comment">// xor because we always toggle</span>
<a name="l03548"></a>03548           modified = <span class="keyword">true</span>;
<a name="l03549"></a>03549         }
<a name="l03550"></a>03550       }
<a name="l03551"></a>03551     }
<a name="l03552"></a>03552   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (selected() != QCPLegend::spNone &amp;&amp; selectable() != QCPLegend::spNone &amp;&amp; !additiveSelection) <span class="comment">// legend not clicked, deselect it if selectable allows that (and all child items)</span>
<a name="l03553"></a>03553   {
<a name="l03554"></a>03554     <span class="comment">// only deselect parts that are allowed to be changed by user according to selectable()</span>
<a name="l03555"></a>03555     <span class="comment">// deselect child items (and automatically removes spItems from selected state of legend, if last item gets deselected):</span>
<a name="l03556"></a>03556     <span class="keywordflow">if</span> (selectable().testFlag(spItems)) 
<a name="l03557"></a>03557     {
<a name="l03558"></a>03558       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;itemCount(); ++i)
<a name="l03559"></a>03559       {
<a name="l03560"></a>03560         <span class="keywordflow">if</span> (item(i)-&gt;selected() &amp;&amp; item(i)-&gt;selectable())
<a name="l03561"></a>03561         {
<a name="l03562"></a>03562           item(i)-&gt;setSelected(<span class="keyword">false</span>);
<a name="l03563"></a>03563           modified = <span class="keyword">true</span>;
<a name="l03564"></a>03564         }
<a name="l03565"></a>03565       }
<a name="l03566"></a>03566     }
<a name="l03567"></a>03567     <span class="comment">// only deselect parts that are allowed to be changed (are selectable). Don&#39;t forcibly remove</span>
<a name="l03568"></a>03568     <span class="comment">// spItems, because some selected items might not be selectable, i.e. allowed to be deselected</span>
<a name="l03569"></a>03569     <span class="comment">// by user interaction. If that&#39;s not the case, spItems will have been removed from selected()</span>
<a name="l03570"></a>03570     <span class="comment">// state in previous loop by individual setSelected(false) calls on the items anyway.</span>
<a name="l03571"></a>03571     QCPLegend::SelectableParts newState = selected() &amp; ~(selectable()&amp;~spItems);
<a name="l03572"></a>03572     <span class="keywordflow">if</span> (newState != selected())
<a name="l03573"></a>03573     {
<a name="l03574"></a>03574       setSelected(newState);
<a name="l03575"></a>03575       modified = <span class="keyword">true</span>;
<a name="l03576"></a>03576     }
<a name="l03577"></a>03577   }
<a name="l03578"></a>03578   
<a name="l03579"></a>03579   <span class="keywordflow">return</span> selectionFound;
<a name="l03580"></a>03580 }
<a name="l03581"></a>03581 
<a name="l03587"></a>03587 QPen QCPLegend::getBorderPen()<span class="keyword"> const</span>
<a name="l03588"></a>03588 <span class="keyword"></span>{
<a name="l03589"></a>03589   <span class="keywordflow">return</span> mSelected.testFlag(spLegendBox) ? mSelectedBorderPen : mBorderPen;
<a name="l03590"></a>03590 }
<a name="l03591"></a>03591 
<a name="l03597"></a>03597 QBrush QCPLegend::getBrush()<span class="keyword"> const</span>
<a name="l03598"></a>03598 <span class="keyword"></span>{
<a name="l03599"></a>03599   <span class="keywordflow">return</span> mSelected.testFlag(spLegendBox) ? mSelectedBrush : mBrush;
<a name="l03600"></a>03600 }
<a name="l03601"></a>03601 
<a name="l03606"></a>03606 <span class="keywordtype">void</span> QCPLegend::draw(QPainter *painter)
<a name="l03607"></a>03607 {
<a name="l03608"></a>03608   <span class="keywordflow">if</span> (!mVisible) <span class="keywordflow">return</span>;
<a name="l03609"></a>03609   painter-&gt;save();
<a name="l03610"></a>03610   painter-&gt;setBrush(getBrush());
<a name="l03611"></a>03611   painter-&gt;setPen(getBorderPen());
<a name="l03612"></a>03612   <span class="comment">// draw background rect:</span>
<a name="l03613"></a>03613   painter-&gt;drawRect(QRect(mPosition, mSize));
<a name="l03614"></a>03614   <span class="comment">// draw legend items:</span>
<a name="l03615"></a>03615   painter-&gt;setClipRect(QRect(mPosition, mSize).adjusted(1, 1, 0, 0));
<a name="l03616"></a>03616   painter-&gt;setPen(QPen());
<a name="l03617"></a>03617   painter-&gt;setBrush(Qt::NoBrush);
<a name="l03618"></a>03618   <span class="keywordtype">int</span> currentTop = mPosition.y()+mPaddingTop;
<a name="l03619"></a>03619   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l03620"></a>03620   {
<a name="l03621"></a>03621     QSize itemSize = mItems.at(i)-&gt;size(QSize(mSize.width(), 0));
<a name="l03622"></a>03622     QRect itemRect = QRect(QPoint(mPosition.x()+mPaddingLeft, currentTop), itemSize);
<a name="l03623"></a>03623     mItemBoundingBoxes.insert(mItems.at(i), itemRect);
<a name="l03624"></a>03624     painter-&gt;save(); <span class="comment">// item might be user subclass, so we save painter outside its draw function - just in case</span>
<a name="l03625"></a>03625     mItems.at(i)-&gt;draw(painter, itemRect);
<a name="l03626"></a>03626     painter-&gt;restore();
<a name="l03627"></a>03627     currentTop += itemSize.height()+mItemSpacing;
<a name="l03628"></a>03628   }
<a name="l03629"></a>03629   painter-&gt;restore();
<a name="l03630"></a>03630 }
<a name="l03631"></a>03631 
<a name="l03638"></a>03638 <span class="keywordtype">void</span> QCPLegend::calculateAutoSize()
<a name="l03639"></a>03639 {
<a name="l03640"></a>03640   <span class="keywordtype">int</span> width = mMinimumSize.width()-mPaddingLeft-mPaddingRight; <span class="comment">// start with minimum width and only expand from there</span>
<a name="l03641"></a>03641   <span class="keywordtype">int</span> currentTop;
<a name="l03642"></a>03642   <span class="keywordtype">bool</span> repeat = <span class="keyword">true</span>;
<a name="l03643"></a>03643   <span class="keywordtype">int</span> repeatCount = 0;
<a name="l03644"></a>03644   <span class="keywordflow">while</span> (repeat &amp;&amp; repeatCount &lt; 3) <span class="comment">// repeat until we find self-consistent width (usually 2 runs)</span>
<a name="l03645"></a>03645   {
<a name="l03646"></a>03646     repeat = <span class="keyword">false</span>;
<a name="l03647"></a>03647     currentTop = mPaddingTop;
<a name="l03648"></a>03648     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mItems.size(); ++i)
<a name="l03649"></a>03649     {
<a name="l03650"></a>03650       QSize s = mItems.at(i)-&gt;size(QSize(width, 0));
<a name="l03651"></a>03651       currentTop += s.height();
<a name="l03652"></a>03652       <span class="keywordflow">if</span> (i &lt; mItems.size()-1) <span class="comment">// vertical spacer for all but last item</span>
<a name="l03653"></a>03653         currentTop += mItemSpacing;
<a name="l03654"></a>03654       <span class="keywordflow">if</span> (width &lt; s.width())
<a name="l03655"></a>03655       {
<a name="l03656"></a>03656         width = s.width();
<a name="l03657"></a>03657         repeat = <span class="keyword">true</span>; <span class="comment">// changed width, so need a new run with new width to let other items adapt their height to that new width</span>
<a name="l03658"></a>03658       }
<a name="l03659"></a>03659     }
<a name="l03660"></a>03660     repeatCount++;
<a name="l03661"></a>03661   }
<a name="l03662"></a>03662   <span class="keywordflow">if</span> (repeat)
<a name="l03663"></a>03663     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;hit repeat limit for iterative width calculation&quot;</span>;
<a name="l03664"></a>03664   currentTop += mPaddingBottom;
<a name="l03665"></a>03665   width += mPaddingLeft+mPaddingRight;
<a name="l03666"></a>03666   
<a name="l03667"></a>03667   mSize.setWidth(width);
<a name="l03668"></a>03668   <span class="keywordflow">if</span> (currentTop &gt; mMinimumSize.height())
<a name="l03669"></a>03669     mSize.setHeight(currentTop);
<a name="l03670"></a>03670   <span class="keywordflow">else</span>
<a name="l03671"></a>03671     mSize.setHeight(mMinimumSize.height());
<a name="l03672"></a>03672 }
<a name="l03673"></a>03673 
<a name="l03678"></a>03678 <span class="keywordtype">void</span> QCPLegend::calculateAutoPosition()
<a name="l03679"></a>03679 {
<a name="l03680"></a>03680   <span class="keywordflow">if</span> (mPositionStyle == psTopLeft)
<a name="l03681"></a>03681   {
<a name="l03682"></a>03682     mPosition = mParentPlot-&gt;mAxisRect.topLeft() + QPoint(mMarginLeft, mMarginTop);
<a name="l03683"></a>03683   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPositionStyle == psTop)
<a name="l03684"></a>03684   {
<a name="l03685"></a>03685     mPosition = mParentPlot-&gt;mAxisRect.topLeft() + QPoint(mParentPlot-&gt;mAxisRect.width()/2.0-mSize.width()/2.0, mMarginTop);
<a name="l03686"></a>03686   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPositionStyle == psTopRight)
<a name="l03687"></a>03687   {
<a name="l03688"></a>03688     mPosition = mParentPlot-&gt;mAxisRect.topRight() + QPoint(-mMarginRight-mSize.width(), mMarginTop);
<a name="l03689"></a>03689   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPositionStyle == psRight)
<a name="l03690"></a>03690   {
<a name="l03691"></a>03691     mPosition = mParentPlot-&gt;mAxisRect.topRight() + QPoint(-mMarginRight-mSize.width(), mParentPlot-&gt;mAxisRect.height()/2.0-mSize.height()/2.0);
<a name="l03692"></a>03692   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPositionStyle == psBottomRight)
<a name="l03693"></a>03693   {
<a name="l03694"></a>03694     mPosition = mParentPlot-&gt;mAxisRect.bottomRight() + QPoint(-mMarginRight-mSize.width(), -mMarginBottom-mSize.height());
<a name="l03695"></a>03695   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPositionStyle == psBottom)
<a name="l03696"></a>03696   {
<a name="l03697"></a>03697     mPosition = mParentPlot-&gt;mAxisRect.bottomLeft() + QPoint(mParentPlot-&gt;mAxisRect.width()/2.0-mSize.width()/2.0, -mMarginBottom-mSize.height());
<a name="l03698"></a>03698   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPositionStyle == psBottomLeft)
<a name="l03699"></a>03699   {
<a name="l03700"></a>03700     mPosition = mParentPlot-&gt;mAxisRect.bottomLeft() + QPoint(mMarginLeft, -mMarginBottom-mSize.height());
<a name="l03701"></a>03701   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mPositionStyle == psLeft)
<a name="l03702"></a>03702   {
<a name="l03703"></a>03703     mPosition = mParentPlot-&gt;mAxisRect.topLeft() + QPoint(mMarginLeft, mParentPlot-&gt;mAxisRect.height()/2.0-mSize.height()/2.0);
<a name="l03704"></a>03704   }
<a name="l03705"></a>03705 }
<a name="l03706"></a>03706 
<a name="l03707"></a>03707 
<a name="l03708"></a>03708 <span class="comment">// ================================================================================</span>
<a name="l03709"></a>03709 <span class="comment">// =================== QCPAxis</span>
<a name="l03710"></a>03710 <span class="comment">// ================================================================================</span>
<a name="l03711"></a>03711 
<a name="l03720"></a>03720 <span class="comment">/* start of documentation of signals */</span>
<a name="l03721"></a>03721 
<a name="l03750"></a>03750 <span class="comment">/* end of documentation of signals */</span>
<a name="l03751"></a>03751 
<a name="l03755"></a>03755 QCPAxis::QCPAxis(QCustomPlot *parentPlot, AxisType type) :
<a name="l03756"></a>03756   QObject(parentPlot)
<a name="l03757"></a>03757 {
<a name="l03758"></a>03758   mParentPlot = parentPlot;
<a name="l03759"></a>03759   mTickVector = <span class="keyword">new</span> QVector&lt;double&gt;;
<a name="l03760"></a>03760   mSubTickVector = <span class="keyword">new</span> QVector&lt;double&gt;;
<a name="l03761"></a>03761   mTickVectorLabels = <span class="keyword">new</span> QVector&lt;QString&gt;;
<a name="l03762"></a>03762   setAxisType(type);
<a name="l03763"></a>03763   setAxisRect(parentPlot-&gt;axisRect()); 
<a name="l03764"></a>03764   setScaleType(stLinear);
<a name="l03765"></a>03765   setScaleLogBase(10);
<a name="l03766"></a>03766   
<a name="l03767"></a>03767   setVisible(<span class="keyword">true</span>);
<a name="l03768"></a>03768   setRange(0, 5);
<a name="l03769"></a>03769   setRangeReversed(<span class="keyword">false</span>);
<a name="l03770"></a>03770   
<a name="l03771"></a>03771   setTicks(<span class="keyword">true</span>);
<a name="l03772"></a>03772   setTickStep(1);
<a name="l03773"></a>03773   setAutoTickCount(6);
<a name="l03774"></a>03774   setAutoTicks(<span class="keyword">true</span>);
<a name="l03775"></a>03775   setAutoTickLabels(<span class="keyword">true</span>);
<a name="l03776"></a>03776   setAutoTickStep(<span class="keyword">true</span>);
<a name="l03777"></a>03777   setTickLabelFont(parentPlot-&gt;font());
<a name="l03778"></a>03778   setTickLabelColor(Qt::black);
<a name="l03779"></a>03779   setTickLength(5);
<a name="l03780"></a>03780   setTickPen(QPen(Qt::black));
<a name="l03781"></a>03781   setTickLabels(<span class="keyword">true</span>);
<a name="l03782"></a>03782   setTickLabelType(ltNumber);
<a name="l03783"></a>03783   setTickLabelRotation(0);
<a name="l03784"></a>03784   setDateTimeFormat(<span class="stringliteral">&quot;hh:mm:ss\ndd.MM.yy&quot;</span>);
<a name="l03785"></a>03785   setNumberFormat(<span class="stringliteral">&quot;gbd&quot;</span>);
<a name="l03786"></a>03786   setNumberPrecision(6);
<a name="l03787"></a>03787   setLabel(<span class="stringliteral">&quot;&quot;</span>);
<a name="l03788"></a>03788   setLabelFont(parentPlot-&gt;font());
<a name="l03789"></a>03789   setLabelColor(Qt::black);
<a name="l03790"></a>03790   
<a name="l03791"></a>03791   setAutoSubTicks(<span class="keyword">true</span>);
<a name="l03792"></a>03792   setSubTickCount(4);
<a name="l03793"></a>03793   setSubTickLength(2);
<a name="l03794"></a>03794   setSubTickPen(QPen(Qt::black));
<a name="l03795"></a>03795   
<a name="l03796"></a>03796   QPen gPen;
<a name="l03797"></a>03797   gPen.setColor(QColor(200,200,200));
<a name="l03798"></a>03798   gPen.setStyle(Qt::DotLine);
<a name="l03799"></a>03799   setGridPen(gPen);
<a name="l03800"></a>03800   setGrid(<span class="keyword">true</span>);
<a name="l03801"></a>03801   QPen subgPen;
<a name="l03802"></a>03802   subgPen.setColor(QColor(220,220,220));
<a name="l03803"></a>03803   subgPen.setStyle(Qt::DotLine);
<a name="l03804"></a>03804   setSubGridPen(subgPen);
<a name="l03805"></a>03805   setSubGrid(<span class="keyword">false</span>);
<a name="l03806"></a>03806   QPen zlinePen;
<a name="l03807"></a>03807   zlinePen.setColor(QColor(200,200,200));
<a name="l03808"></a>03808   setZeroLinePen(zlinePen);
<a name="l03809"></a>03809   setBasePen(QPen(Qt::black));
<a name="l03810"></a>03810   
<a name="l03811"></a>03811   setSelected(spNone);
<a name="l03812"></a>03812   setSelectable(spAxis | spTickLabels | spAxisLabel);
<a name="l03813"></a>03813   QFont selTickLabelFont = tickLabelFont();
<a name="l03814"></a>03814   selTickLabelFont.setBold(<span class="keyword">true</span>);
<a name="l03815"></a>03815   setSelectedTickLabelFont(selTickLabelFont);
<a name="l03816"></a>03816   QFont selLabelFont = labelFont();
<a name="l03817"></a>03817   selLabelFont.setBold(<span class="keyword">true</span>);
<a name="l03818"></a>03818   setSelectedLabelFont(selLabelFont);
<a name="l03819"></a>03819   setSelectedTickLabelColor(Qt::blue);
<a name="l03820"></a>03820   setSelectedLabelColor(Qt::blue);
<a name="l03821"></a>03821   QPen blueThickPen;
<a name="l03822"></a>03822   blueThickPen.setColor(Qt::blue);
<a name="l03823"></a>03823   blueThickPen.setWidth(2);
<a name="l03824"></a>03824   setSelectedBasePen(blueThickPen);
<a name="l03825"></a>03825   setSelectedTickPen(blueThickPen);
<a name="l03826"></a>03826   setSelectedSubTickPen(blueThickPen);
<a name="l03827"></a>03827   
<a name="l03828"></a>03828   setPadding(0);
<a name="l03829"></a>03829   <span class="keywordflow">if</span> (type == atTop)
<a name="l03830"></a>03830   {
<a name="l03831"></a>03831     setTickLabelPadding(3);
<a name="l03832"></a>03832     setLabelPadding(6);
<a name="l03833"></a>03833   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == atRight)
<a name="l03834"></a>03834   {
<a name="l03835"></a>03835     setTickLabelPadding(7);
<a name="l03836"></a>03836     setLabelPadding(12);
<a name="l03837"></a>03837   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == atBottom)
<a name="l03838"></a>03838   {
<a name="l03839"></a>03839     setTickLabelPadding(3);
<a name="l03840"></a>03840     setLabelPadding(3);
<a name="l03841"></a>03841   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == atLeft)
<a name="l03842"></a>03842   {
<a name="l03843"></a>03843     setTickLabelPadding(5);
<a name="l03844"></a>03844     setLabelPadding(10);
<a name="l03845"></a>03845   }
<a name="l03846"></a>03846 }
<a name="l03847"></a>03847 
<a name="l03848"></a>03848 QCPAxis::~QCPAxis()
<a name="l03849"></a>03849 {
<a name="l03850"></a>03850   <span class="keyword">delete</span> mTickVector;
<a name="l03851"></a>03851   <span class="keyword">delete</span> mTickVectorLabels;
<a name="l03852"></a>03852   <span class="keyword">delete</span> mSubTickVector;
<a name="l03853"></a>03853 }
<a name="l03854"></a>03854 
<a name="l03859"></a>03859 QString QCPAxis::numberFormat()<span class="keyword"> const</span>
<a name="l03860"></a>03860 <span class="keyword"></span>{
<a name="l03861"></a>03861   QString result;
<a name="l03862"></a>03862   result.append(mNumberFormatChar);
<a name="l03863"></a>03863   <span class="keywordflow">if</span> (mNumberBeautifulPowers)
<a name="l03864"></a>03864   {
<a name="l03865"></a>03865     result.append(<span class="stringliteral">&quot;b&quot;</span>);
<a name="l03866"></a>03866     <span class="keywordflow">if</span> (mNumberMultiplyCross)
<a name="l03867"></a>03867       result.append(<span class="stringliteral">&quot;c&quot;</span>);
<a name="l03868"></a>03868   }
<a name="l03869"></a>03869   <span class="keywordflow">return</span> result;
<a name="l03870"></a>03870 }
<a name="l03871"></a>03871 
<a name="l03878"></a>03878 <span class="keywordtype">void</span> QCPAxis::setAxisType(AxisType type)
<a name="l03879"></a>03879 {
<a name="l03880"></a>03880   mAxisType = type;
<a name="l03881"></a>03881   mOrientation = (type == atBottom || type == atTop) ? Qt::Horizontal : Qt::Vertical;
<a name="l03882"></a>03882 }
<a name="l03883"></a>03883 
<a name="l03891"></a>03891 <span class="keywordtype">void</span> QCPAxis::setAxisRect(<span class="keyword">const</span> QRect &amp;rect)
<a name="l03892"></a>03892 {
<a name="l03893"></a>03893   mAxisRect = rect;
<a name="l03894"></a>03894 }
<a name="l03895"></a>03895 
<a name="l03909"></a>03909 <span class="keywordtype">void</span> QCPAxis::setScaleType(ScaleType type)
<a name="l03910"></a>03910 {
<a name="l03911"></a>03911   mScaleType = type;
<a name="l03912"></a>03912   <span class="keywordflow">if</span> (mScaleType == stLogarithmic)
<a name="l03913"></a>03913     mRange = mRange.sanitizedForLogScale();
<a name="l03914"></a>03914 }
<a name="l03915"></a>03915 
<a name="l03923"></a>03923 <span class="keywordtype">void</span> QCPAxis::setScaleLogBase(<span class="keywordtype">double</span> base)
<a name="l03924"></a>03924 {
<a name="l03925"></a>03925   <span class="keywordflow">if</span> (base &gt; 1)
<a name="l03926"></a>03926   {
<a name="l03927"></a>03927     mScaleLogBase = base;
<a name="l03928"></a>03928     mScaleLogBaseLogInv = 1.0/log(mScaleLogBase); <span class="comment">// buffer for faster baseLog() calculation</span>
<a name="l03929"></a>03929   } <span class="keywordflow">else</span>
<a name="l03930"></a>03930     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;Invalid logarithmic scale base (must be greater 1):&quot;</span> &lt;&lt; base;
<a name="l03931"></a>03931 }
<a name="l03932"></a>03932 
<a name="l03941"></a>03941 <span class="keywordtype">void</span> QCPAxis::setRange(<span class="keyword">const</span> QCPRange &amp;range)
<a name="l03942"></a>03942 {
<a name="l03943"></a>03943   <span class="keywordflow">if</span> (range.lower == mRange.lower &amp;&amp; range.upper == mRange.upper)
<a name="l03944"></a>03944     <span class="keywordflow">return</span>;
<a name="l03945"></a>03945   
<a name="l03946"></a>03946   <span class="keywordflow">if</span> (!QCPRange::validRange(range)) <span class="keywordflow">return</span>;
<a name="l03947"></a>03947   <span class="keywordflow">if</span> (mScaleType == stLogarithmic)
<a name="l03948"></a>03948   {
<a name="l03949"></a>03949     mRange = range.sanitizedForLogScale();
<a name="l03950"></a>03950   } <span class="keywordflow">else</span>
<a name="l03951"></a>03951   {
<a name="l03952"></a>03952     mRange = range.sanitizedForLinScale();
<a name="l03953"></a>03953   }
<a name="l03954"></a>03954   emit rangeChanged(mRange);
<a name="l03955"></a>03955 }
<a name="l03956"></a>03956 
<a name="l03967"></a>03967 <span class="keywordtype">void</span> QCPAxis::setSelectable(<span class="keyword">const</span> SelectableParts &amp;selectable)
<a name="l03968"></a>03968 {
<a name="l03969"></a>03969   mSelectable = selectable;
<a name="l03970"></a>03970 }
<a name="l03971"></a>03971 
<a name="l03988"></a>03988 <span class="keywordtype">void</span> QCPAxis::setSelected(<span class="keyword">const</span> SelectableParts &amp;selected)
<a name="l03989"></a>03989 {
<a name="l03990"></a>03990   <span class="keywordflow">if</span> (mSelected != selected)
<a name="l03991"></a>03991   {
<a name="l03992"></a>03992     mSelected = selected;
<a name="l03993"></a>03993     emit selectionChanged(mSelected);
<a name="l03994"></a>03994   }
<a name="l03995"></a>03995 }
<a name="l03996"></a>03996 
<a name="l04005"></a>04005 <span class="keywordtype">void</span> QCPAxis::setRange(<span class="keywordtype">double</span> lower, <span class="keywordtype">double</span> upper)
<a name="l04006"></a>04006 {
<a name="l04007"></a>04007   <span class="keywordflow">if</span> (lower == mRange.lower &amp;&amp; upper == mRange.upper)
<a name="l04008"></a>04008     <span class="keywordflow">return</span>;
<a name="l04009"></a>04009   
<a name="l04010"></a>04010   <span class="keywordflow">if</span> (!QCPRange::validRange(lower, upper)) <span class="keywordflow">return</span>;
<a name="l04011"></a>04011   mRange.lower = lower;
<a name="l04012"></a>04012   mRange.upper = upper;
<a name="l04013"></a>04013   <span class="keywordflow">if</span> (mScaleType == stLogarithmic)
<a name="l04014"></a>04014   {
<a name="l04015"></a>04015     mRange = mRange.sanitizedForLogScale();
<a name="l04016"></a>04016   } <span class="keywordflow">else</span>
<a name="l04017"></a>04017   {
<a name="l04018"></a>04018     mRange = mRange.sanitizedForLinScale();
<a name="l04019"></a>04019   }
<a name="l04020"></a>04020   emit rangeChanged(mRange);
<a name="l04021"></a>04021 }
<a name="l04022"></a>04022 
<a name="l04036"></a>04036 <span class="keywordtype">void</span> QCPAxis::setRange(<span class="keywordtype">double</span> position, <span class="keywordtype">double</span> size, Qt::AlignmentFlag alignment)
<a name="l04037"></a>04037 {
<a name="l04038"></a>04038   <span class="keywordflow">if</span> (alignment == Qt::AlignLeft)
<a name="l04039"></a>04039     setRange(position, position+size);
<a name="l04040"></a>04040   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (alignment == Qt::AlignRight)
<a name="l04041"></a>04041     setRange(position-size, position);
<a name="l04042"></a>04042   <span class="keywordflow">else</span> <span class="comment">// alignment == Qt::AlignCenter</span>
<a name="l04043"></a>04043     setRange(position-size/2.0, position+size/2.0);
<a name="l04044"></a>04044 }
<a name="l04045"></a>04045 
<a name="l04050"></a>04050 <span class="keywordtype">void</span> QCPAxis::setRangeLower(<span class="keywordtype">double</span> lower)
<a name="l04051"></a>04051 {
<a name="l04052"></a>04052   <span class="keywordflow">if</span> (mRange.lower == lower)
<a name="l04053"></a>04053     <span class="keywordflow">return</span>;
<a name="l04054"></a>04054   
<a name="l04055"></a>04055   mRange.lower = lower;
<a name="l04056"></a>04056   <span class="keywordflow">if</span> (mScaleType == stLogarithmic)
<a name="l04057"></a>04057   {
<a name="l04058"></a>04058     mRange = mRange.sanitizedForLogScale();
<a name="l04059"></a>04059   } <span class="keywordflow">else</span>
<a name="l04060"></a>04060   {
<a name="l04061"></a>04061     mRange = mRange.sanitizedForLinScale();
<a name="l04062"></a>04062   }
<a name="l04063"></a>04063   emit rangeChanged(mRange);
<a name="l04064"></a>04064 }
<a name="l04065"></a>04065 
<a name="l04070"></a>04070 <span class="keywordtype">void</span> QCPAxis::setRangeUpper(<span class="keywordtype">double</span> upper)
<a name="l04071"></a>04071 {
<a name="l04072"></a>04072   <span class="keywordflow">if</span> (mRange.upper == upper)
<a name="l04073"></a>04073     <span class="keywordflow">return</span>;
<a name="l04074"></a>04074   
<a name="l04075"></a>04075   mRange.upper = upper;
<a name="l04076"></a>04076   <span class="keywordflow">if</span> (mScaleType == stLogarithmic)
<a name="l04077"></a>04077   {
<a name="l04078"></a>04078     mRange = mRange.sanitizedForLogScale();
<a name="l04079"></a>04079   } <span class="keywordflow">else</span>
<a name="l04080"></a>04080   {
<a name="l04081"></a>04081     mRange = mRange.sanitizedForLinScale();
<a name="l04082"></a>04082   }
<a name="l04083"></a>04083   emit rangeChanged(mRange);
<a name="l04084"></a>04084 }
<a name="l04085"></a>04085 
<a name="l04093"></a>04093 <span class="keywordtype">void</span> QCPAxis::setRangeReversed(<span class="keywordtype">bool</span> reversed)
<a name="l04094"></a>04094 {
<a name="l04095"></a>04095   mRangeReversed = reversed;
<a name="l04096"></a>04096 }
<a name="l04097"></a>04097 
<a name="l04103"></a>04103 <span class="keywordtype">void</span> QCPAxis::setVisible(<span class="keywordtype">bool</span> on)
<a name="l04104"></a>04104 {
<a name="l04105"></a>04105   mVisible = on;
<a name="l04106"></a>04106 }
<a name="l04107"></a>04107 
<a name="l04112"></a>04112 <span class="keywordtype">void</span> QCPAxis::setGrid(<span class="keywordtype">bool</span> show)
<a name="l04113"></a>04113 {
<a name="l04114"></a>04114   mGrid = show;
<a name="l04115"></a>04115 }
<a name="l04116"></a>04116 
<a name="l04121"></a>04121 <span class="keywordtype">void</span> QCPAxis::setSubGrid(<span class="keywordtype">bool</span> show)
<a name="l04122"></a>04122 {
<a name="l04123"></a>04123   mSubGrid = show;
<a name="l04124"></a>04124 }
<a name="l04125"></a>04125 
<a name="l04138"></a>04138 <span class="keywordtype">void</span> QCPAxis::setAutoTicks(<span class="keywordtype">bool</span> on)
<a name="l04139"></a>04139 {
<a name="l04140"></a>04140   mAutoTicks = on;
<a name="l04141"></a>04141 }
<a name="l04142"></a>04142 
<a name="l04147"></a>04147 <span class="keywordtype">void</span> QCPAxis::setAutoTickCount(<span class="keywordtype">int</span> approximateCount)
<a name="l04148"></a>04148 {
<a name="l04149"></a>04149   mAutoTickCount = approximateCount;
<a name="l04150"></a>04150 }
<a name="l04151"></a>04151 
<a name="l04164"></a>04164 <span class="keywordtype">void</span> QCPAxis::setAutoTickLabels(<span class="keywordtype">bool</span> on)
<a name="l04165"></a>04165 {
<a name="l04166"></a>04166   mAutoTickLabels = on;
<a name="l04167"></a>04167 }
<a name="l04168"></a>04168 
<a name="l04179"></a>04179 <span class="keywordtype">void</span> QCPAxis::setAutoTickStep(<span class="keywordtype">bool</span> on)
<a name="l04180"></a>04180 {
<a name="l04181"></a>04181   mAutoTickStep = on;
<a name="l04182"></a>04182 }
<a name="l04183"></a>04183 
<a name="l04190"></a>04190 <span class="keywordtype">void</span> QCPAxis::setAutoSubTicks(<span class="keywordtype">bool</span> on)
<a name="l04191"></a>04191 {
<a name="l04192"></a>04192   mAutoSubTicks = on;
<a name="l04193"></a>04193 }
<a name="l04194"></a>04194 
<a name="l04199"></a>04199 <span class="keywordtype">void</span> QCPAxis::setTicks(<span class="keywordtype">bool</span> show)
<a name="l04200"></a>04200 {
<a name="l04201"></a>04201   mTicks = show;
<a name="l04202"></a>04202 }
<a name="l04203"></a>04203 
<a name="l04207"></a>04207 <span class="keywordtype">void</span> QCPAxis::setTickLabels(<span class="keywordtype">bool</span> show)
<a name="l04208"></a>04208 {
<a name="l04209"></a>04209   mTickLabels = show;
<a name="l04210"></a>04210 }
<a name="l04211"></a>04211 
<a name="l04216"></a>04216 <span class="keywordtype">void</span> QCPAxis::setTickLabelPadding(<span class="keywordtype">int</span> padding)
<a name="l04217"></a>04217 {
<a name="l04218"></a>04218   mTickLabelPadding = padding;
<a name="l04219"></a>04219 }
<a name="l04220"></a>04220 
<a name="l04231"></a>04231 <span class="keywordtype">void</span> QCPAxis::setTickLabelType(LabelType type)
<a name="l04232"></a>04232 {
<a name="l04233"></a>04233   mTickLabelType = type;
<a name="l04234"></a>04234 }
<a name="l04235"></a>04235 
<a name="l04241"></a>04241 <span class="keywordtype">void</span> QCPAxis::setTickLabelFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l04242"></a>04242 {
<a name="l04243"></a>04243   mTickLabelFont = font;
<a name="l04244"></a>04244 }
<a name="l04245"></a>04245 
<a name="l04251"></a>04251 <span class="keywordtype">void</span> QCPAxis::setTickLabelColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l04252"></a>04252 {
<a name="l04253"></a>04253   mTickLabelColor = color;
<a name="l04254"></a>04254 }
<a name="l04255"></a>04255 
<a name="l04261"></a>04261 <span class="keywordtype">void</span> QCPAxis::setTickLabelRotation(<span class="keywordtype">double</span> degrees)
<a name="l04262"></a>04262 {
<a name="l04263"></a>04263   mTickLabelRotation = qBound(-90.0, degrees, 90.0);
<a name="l04264"></a>04264 }
<a name="l04265"></a>04265 
<a name="l04271"></a>04271 <span class="keywordtype">void</span> QCPAxis::setDateTimeFormat(<span class="keyword">const</span> QString &amp;format)
<a name="l04272"></a>04272 {
<a name="l04273"></a>04273   mDateTimeFormat = format;
<a name="l04274"></a>04274 }
<a name="l04275"></a>04275 
<a name="l04312"></a>04312 <span class="keywordtype">void</span> QCPAxis::setNumberFormat(<span class="keyword">const</span> QString &amp;formatCode)
<a name="l04313"></a>04313 {
<a name="l04314"></a>04314   <span class="keywordflow">if</span> (formatCode.length() &lt; 1) <span class="keywordflow">return</span>;
<a name="l04315"></a>04315   
<a name="l04316"></a>04316   <span class="comment">// interpret first char as number format char:</span>
<a name="l04317"></a>04317   QString allowedFormatChars = <span class="stringliteral">&quot;eEfgG&quot;</span>;
<a name="l04318"></a>04318   <span class="keywordflow">if</span> (allowedFormatChars.contains(formatCode.at(0)))
<a name="l04319"></a>04319   {
<a name="l04320"></a>04320     mNumberFormatChar = formatCode.at(0).toAscii();
<a name="l04321"></a>04321   } <span class="keywordflow">else</span>
<a name="l04322"></a>04322   {
<a name="l04323"></a>04323     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;Invalid number format code (first char not in &#39;eEfgG&#39;):&quot;</span> &lt;&lt; formatCode;
<a name="l04324"></a>04324     <span class="keywordflow">return</span>;
<a name="l04325"></a>04325   }
<a name="l04326"></a>04326   <span class="keywordflow">if</span> (formatCode.length() &lt; 2)
<a name="l04327"></a>04327   {
<a name="l04328"></a>04328     mNumberBeautifulPowers = <span class="keyword">false</span>;
<a name="l04329"></a>04329     mNumberMultiplyCross = <span class="keyword">false</span>;
<a name="l04330"></a>04330     <span class="keywordflow">return</span>;
<a name="l04331"></a>04331   }
<a name="l04332"></a>04332   
<a name="l04333"></a>04333   <span class="comment">// interpret second char as indicator for beautiful decimal powers:</span>
<a name="l04334"></a>04334   <span class="keywordflow">if</span> (formatCode.at(1) == <span class="charliteral">&#39;b&#39;</span> &amp;&amp; (mNumberFormatChar == <span class="charliteral">&#39;e&#39;</span> || mNumberFormatChar == <span class="charliteral">&#39;g&#39;</span>))
<a name="l04335"></a>04335   {
<a name="l04336"></a>04336     mNumberBeautifulPowers = <span class="keyword">true</span>;
<a name="l04337"></a>04337   } <span class="keywordflow">else</span>
<a name="l04338"></a>04338   {
<a name="l04339"></a>04339     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;Invalid number format code (second char not &#39;b&#39; or first char neither &#39;e&#39; nor &#39;g&#39;):&quot;</span> &lt;&lt; formatCode;
<a name="l04340"></a>04340     <span class="keywordflow">return</span>;
<a name="l04341"></a>04341   }
<a name="l04342"></a>04342   <span class="keywordflow">if</span> (formatCode.length() &lt; 3)
<a name="l04343"></a>04343   {
<a name="l04344"></a>04344     mNumberMultiplyCross = <span class="keyword">false</span>;
<a name="l04345"></a>04345     <span class="keywordflow">return</span>;
<a name="l04346"></a>04346   }
<a name="l04347"></a>04347   
<a name="l04348"></a>04348   <span class="comment">// interpret third char as indicator for dot or cross multiplication symbol:</span>
<a name="l04349"></a>04349   <span class="keywordflow">if</span> (formatCode.at(2) == <span class="charliteral">&#39;c&#39;</span>)
<a name="l04350"></a>04350   {
<a name="l04351"></a>04351     mNumberMultiplyCross = <span class="keyword">true</span>;
<a name="l04352"></a>04352   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formatCode.at(2) == <span class="charliteral">&#39;d&#39;</span>)
<a name="l04353"></a>04353   {
<a name="l04354"></a>04354     mNumberMultiplyCross = <span class="keyword">false</span>;
<a name="l04355"></a>04355   } <span class="keywordflow">else</span>
<a name="l04356"></a>04356   {
<a name="l04357"></a>04357     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;Invalid number format code (third char neither &#39;c&#39; nor &#39;d&#39;):&quot;</span> &lt;&lt; formatCode;
<a name="l04358"></a>04358     <span class="keywordflow">return</span>;
<a name="l04359"></a>04359   }
<a name="l04360"></a>04360 }
<a name="l04361"></a>04361 
<a name="l04373"></a>04373 <span class="keywordtype">void</span> QCPAxis::setNumberPrecision(<span class="keywordtype">int</span> precision)
<a name="l04374"></a>04374 {
<a name="l04375"></a>04375   mNumberPrecision = precision;
<a name="l04376"></a>04376 }
<a name="l04377"></a>04377 
<a name="l04383"></a>04383 <span class="keywordtype">void</span> QCPAxis::setTickStep(<span class="keywordtype">double</span> step)
<a name="l04384"></a>04384 {
<a name="l04385"></a>04385   mTickStep = step;
<a name="l04386"></a>04386 }
<a name="l04387"></a>04387 
<a name="l04402"></a>04402 <span class="keywordtype">void</span> QCPAxis::setTickVector(QVector&lt;double&gt; *vec, <span class="keywordtype">bool</span> copy)
<a name="l04403"></a>04403 {
<a name="l04404"></a>04404   <span class="keywordflow">if</span> (copy)
<a name="l04405"></a>04405   {
<a name="l04406"></a>04406     *mTickVector = *vec;
<a name="l04407"></a>04407   } <span class="keywordflow">else</span>
<a name="l04408"></a>04408   {
<a name="l04409"></a>04409     <span class="keyword">delete</span> mTickVector;
<a name="l04410"></a>04410     mTickVector = vec;
<a name="l04411"></a>04411   }
<a name="l04412"></a>04412 }
<a name="l04413"></a>04413 
<a name="l04429"></a>04429 <span class="keywordtype">void</span> QCPAxis::setTickVectorLabels(QVector&lt;QString&gt; *vec, <span class="keywordtype">bool</span> copy)
<a name="l04430"></a>04430 {
<a name="l04431"></a>04431   <span class="keywordflow">if</span> (copy)
<a name="l04432"></a>04432   {
<a name="l04433"></a>04433     *mTickVectorLabels = *vec;
<a name="l04434"></a>04434   } <span class="keywordflow">else</span>
<a name="l04435"></a>04435   {
<a name="l04436"></a>04436     <span class="keyword">delete</span> mTickVectorLabels;
<a name="l04437"></a>04437     mTickVectorLabels = vec;
<a name="l04438"></a>04438   }
<a name="l04439"></a>04439 }
<a name="l04440"></a>04440 
<a name="l04448"></a>04448 <span class="keywordtype">void</span> QCPAxis::setTickLength(<span class="keywordtype">int</span> inside, <span class="keywordtype">int</span> outside)
<a name="l04449"></a>04449 {
<a name="l04450"></a>04450   mTickLengthIn = inside;
<a name="l04451"></a>04451   mTickLengthOut = outside;
<a name="l04452"></a>04452 }
<a name="l04453"></a>04453 
<a name="l04463"></a>04463 <span class="keywordtype">void</span> QCPAxis::setSubTickCount(<span class="keywordtype">int</span> count)
<a name="l04464"></a>04464 {
<a name="l04465"></a>04465   mSubTickCount = count;
<a name="l04466"></a>04466 }
<a name="l04467"></a>04467 
<a name="l04475"></a>04475 <span class="keywordtype">void</span> QCPAxis::setSubTickLength(<span class="keywordtype">int</span> inside, <span class="keywordtype">int</span> outside)
<a name="l04476"></a>04476 {
<a name="l04477"></a>04477   mSubTickLengthIn = inside;
<a name="l04478"></a>04478   mSubTickLengthOut = outside;
<a name="l04479"></a>04479 }
<a name="l04480"></a>04480 
<a name="l04486"></a>04486 <span class="keywordtype">void</span> QCPAxis::setBasePen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l04487"></a>04487 {
<a name="l04488"></a>04488   mBasePen = pen;
<a name="l04489"></a>04489 }
<a name="l04490"></a>04490 
<a name="l04495"></a>04495 <span class="keywordtype">void</span> QCPAxis::setGridPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l04496"></a>04496 {
<a name="l04497"></a>04497   mGridPen = pen;
<a name="l04498"></a>04498 }
<a name="l04499"></a>04499 
<a name="l04505"></a>04505 <span class="keywordtype">void</span> QCPAxis::setSubGridPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l04506"></a>04506 {
<a name="l04507"></a>04507   mSubGridPen = pen;
<a name="l04508"></a>04508 }
<a name="l04509"></a>04509 
<a name="l04517"></a>04517 <span class="keywordtype">void</span> QCPAxis::setZeroLinePen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l04518"></a>04518 {
<a name="l04519"></a>04519   mZeroLinePen = pen;
<a name="l04520"></a>04520 }
<a name="l04521"></a>04521 
<a name="l04526"></a>04526 <span class="keywordtype">void</span> QCPAxis::setTickPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l04527"></a>04527 {
<a name="l04528"></a>04528   mTickPen = pen;
<a name="l04529"></a>04529 }
<a name="l04530"></a>04530 
<a name="l04535"></a>04535 <span class="keywordtype">void</span> QCPAxis::setSubTickPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l04536"></a>04536 {
<a name="l04537"></a>04537   mSubTickPen = pen;
<a name="l04538"></a>04538 }
<a name="l04539"></a>04539 
<a name="l04545"></a>04545 <span class="keywordtype">void</span> QCPAxis::setLabelFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l04546"></a>04546 {
<a name="l04547"></a>04547   mLabelFont = font;
<a name="l04548"></a>04548 }
<a name="l04549"></a>04549 
<a name="l04555"></a>04555 <span class="keywordtype">void</span> QCPAxis::setLabelColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l04556"></a>04556 {
<a name="l04557"></a>04557   mLabelColor = color;
<a name="l04558"></a>04558 }
<a name="l04559"></a>04559 
<a name="l04563"></a>04563 <span class="keywordtype">void</span> QCPAxis::setLabel(<span class="keyword">const</span> QString &amp;str)
<a name="l04564"></a>04564 {
<a name="l04565"></a>04565   mLabel = str;
<a name="l04566"></a>04566 }
<a name="l04567"></a>04567 
<a name="l04572"></a>04572 <span class="keywordtype">void</span> QCPAxis::setLabelPadding(<span class="keywordtype">int</span> padding)
<a name="l04573"></a>04573 {
<a name="l04574"></a>04574   mLabelPadding = padding;
<a name="l04575"></a>04575 }
<a name="l04576"></a>04576 
<a name="l04590"></a>04590 <span class="keywordtype">void</span> QCPAxis::setPadding(<span class="keywordtype">int</span> padding)
<a name="l04591"></a>04591 {
<a name="l04592"></a>04592   mPadding = padding;
<a name="l04593"></a>04593 }
<a name="l04594"></a>04594 
<a name="l04600"></a>04600 <span class="keywordtype">void</span> QCPAxis::setSelectedTickLabelFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l04601"></a>04601 {
<a name="l04602"></a>04602   mSelectedTickLabelFont = font;
<a name="l04603"></a>04603 }
<a name="l04604"></a>04604 
<a name="l04610"></a>04610 <span class="keywordtype">void</span> QCPAxis::setSelectedLabelFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l04611"></a>04611 {
<a name="l04612"></a>04612   mSelectedLabelFont = font;
<a name="l04613"></a>04613 }
<a name="l04614"></a>04614 
<a name="l04620"></a>04620 <span class="keywordtype">void</span> QCPAxis::setSelectedTickLabelColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l04621"></a>04621 {
<a name="l04622"></a>04622   mSelectedTickLabelColor = color;
<a name="l04623"></a>04623 }
<a name="l04624"></a>04624 
<a name="l04630"></a>04630 <span class="keywordtype">void</span> QCPAxis::setSelectedLabelColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l04631"></a>04631 {
<a name="l04632"></a>04632   mSelectedLabelColor = color;
<a name="l04633"></a>04633 }
<a name="l04634"></a>04634 
<a name="l04640"></a>04640 <span class="keywordtype">void</span> QCPAxis::setSelectedBasePen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l04641"></a>04641 {
<a name="l04642"></a>04642   mSelectedBasePen = pen;
<a name="l04643"></a>04643 }
<a name="l04644"></a>04644 
<a name="l04650"></a>04650 <span class="keywordtype">void</span> QCPAxis::setSelectedTickPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l04651"></a>04651 {
<a name="l04652"></a>04652   mSelectedTickPen = pen;
<a name="l04653"></a>04653 }
<a name="l04654"></a>04654 
<a name="l04660"></a>04660 <span class="keywordtype">void</span> QCPAxis::setSelectedSubTickPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l04661"></a>04661 {
<a name="l04662"></a>04662   mSelectedSubTickPen = pen;
<a name="l04663"></a>04663 }
<a name="l04664"></a>04664 
<a name="l04672"></a>04672 <span class="keywordtype">void</span> QCPAxis::moveRange(<span class="keywordtype">double</span> diff)
<a name="l04673"></a>04673 {
<a name="l04674"></a>04674   <span class="keywordflow">if</span> (mScaleType == stLinear)
<a name="l04675"></a>04675   {
<a name="l04676"></a>04676     mRange.lower += diff;
<a name="l04677"></a>04677     mRange.upper += diff;
<a name="l04678"></a>04678   } <span class="keywordflow">else</span> <span class="comment">// mScaleType == stLogarithmic</span>
<a name="l04679"></a>04679   {
<a name="l04680"></a>04680     mRange.lower *= diff;
<a name="l04681"></a>04681     mRange.upper *= diff;
<a name="l04682"></a>04682   }
<a name="l04683"></a>04683   emit rangeChanged(mRange);
<a name="l04684"></a>04684 }
<a name="l04685"></a>04685 
<a name="l04692"></a>04692 <span class="keywordtype">void</span> QCPAxis::scaleRange(<span class="keywordtype">double</span> factor, <span class="keywordtype">double</span> center)
<a name="l04693"></a>04693 {
<a name="l04694"></a>04694   
<a name="l04695"></a>04695   <span class="keywordflow">if</span> (mScaleType == stLinear)
<a name="l04696"></a>04696   {
<a name="l04697"></a>04697     QCPRange newRange;
<a name="l04698"></a>04698     newRange.lower = (mRange.lower-center)*factor + center;
<a name="l04699"></a>04699     newRange.upper = (mRange.upper-center)*factor + center;
<a name="l04700"></a>04700     <span class="keywordflow">if</span> (QCPRange::validRange(newRange))
<a name="l04701"></a>04701       mRange = newRange.sanitizedForLinScale();
<a name="l04702"></a>04702   } <span class="keywordflow">else</span> <span class="comment">// mScaleType == stLogarithmic</span>
<a name="l04703"></a>04703   {
<a name="l04704"></a>04704     <span class="keywordflow">if</span> ((mRange.upper &lt; 0 &amp;&amp; center &lt; 0) || (mRange.upper &gt; 0 &amp;&amp; center &gt; 0)) <span class="comment">// make sure center has same sign as range</span>
<a name="l04705"></a>04705     {
<a name="l04706"></a>04706       QCPRange newRange;
<a name="l04707"></a>04707       newRange.lower = pow(mRange.lower/center, factor)*center;
<a name="l04708"></a>04708       newRange.upper = pow(mRange.upper/center, factor)*center;
<a name="l04709"></a>04709       <span class="keywordflow">if</span> (QCPRange::validRange(newRange))
<a name="l04710"></a>04710         mRange = newRange.sanitizedForLogScale();
<a name="l04711"></a>04711     } <span class="keywordflow">else</span>
<a name="l04712"></a>04712       qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;center of scaling operation doesn&#39;t lie in same logarithmic sign domain as range:&quot;</span> &lt;&lt; center;
<a name="l04713"></a>04713   }
<a name="l04714"></a>04714   emit rangeChanged(mRange);
<a name="l04715"></a>04715 }
<a name="l04716"></a>04716 
<a name="l04725"></a>04725 <span class="keywordtype">void</span> QCPAxis::setScaleRatio(<span class="keyword">const</span> QCPAxis *otherAxis, <span class="keywordtype">double</span> ratio)
<a name="l04726"></a>04726 {
<a name="l04727"></a>04727   <span class="keywordtype">int</span> otherPixelSize, ownPixelSize;
<a name="l04728"></a>04728   
<a name="l04729"></a>04729   <span class="keywordflow">if</span> (otherAxis-&gt;orientation() == Qt::Horizontal)
<a name="l04730"></a>04730     otherPixelSize = otherAxis-&gt;mAxisRect.width();
<a name="l04731"></a>04731   <span class="keywordflow">else</span>
<a name="l04732"></a>04732     otherPixelSize = otherAxis-&gt;mAxisRect.height();
<a name="l04733"></a>04733   
<a name="l04734"></a>04734   <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l04735"></a>04735     ownPixelSize = mAxisRect.width();
<a name="l04736"></a>04736   <span class="keywordflow">else</span>
<a name="l04737"></a>04737     ownPixelSize = mAxisRect.height();
<a name="l04738"></a>04738   
<a name="l04739"></a>04739   <span class="keywordtype">double</span> newRangeSize = ratio*otherAxis-&gt;mRange.size()*ownPixelSize/(double)otherPixelSize;
<a name="l04740"></a>04740   setRange(range().center(), newRangeSize, Qt::AlignCenter);
<a name="l04741"></a>04741 }
<a name="l04742"></a>04742 
<a name="l04746"></a>04746 <span class="keywordtype">double</span> QCPAxis::pixelToCoord(<span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l04747"></a>04747 <span class="keyword"></span>{
<a name="l04748"></a>04748   <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l04749"></a>04749   {
<a name="l04750"></a>04750     <span class="keywordflow">if</span> (mScaleType == stLinear)
<a name="l04751"></a>04751     {
<a name="l04752"></a>04752       <span class="keywordflow">if</span> (mRangeReversed)
<a name="l04753"></a>04753         <span class="keywordflow">return</span> -(value-mAxisRect.left())/(<span class="keywordtype">double</span>)mAxisRect.width()*mRange.size()+mRange.upper;
<a name="l04754"></a>04754       <span class="keywordflow">else</span>
<a name="l04755"></a>04755         <span class="keywordflow">return</span> (value-mAxisRect.left())/(<span class="keywordtype">double</span>)mAxisRect.width()*mRange.size()+mRange.lower;
<a name="l04756"></a>04756     } <span class="keywordflow">else</span> <span class="comment">// mScaleType == stLogarithmic</span>
<a name="l04757"></a>04757     {
<a name="l04758"></a>04758       <span class="keywordflow">if</span> (mRangeReversed)
<a name="l04759"></a>04759         <span class="keywordflow">return</span> pow(mRange.upper/mRange.lower, (mAxisRect.left()-value)/(<span class="keywordtype">double</span>)mAxisRect.width())*mRange.upper;
<a name="l04760"></a>04760       <span class="keywordflow">else</span>
<a name="l04761"></a>04761         <span class="keywordflow">return</span> pow(mRange.upper/mRange.lower, (value-mAxisRect.left())/(<span class="keywordtype">double</span>)mAxisRect.width())*mRange.lower;
<a name="l04762"></a>04762     }
<a name="l04763"></a>04763   } <span class="keywordflow">else</span> <span class="comment">// orientation() == Qt::Vertical</span>
<a name="l04764"></a>04764   {
<a name="l04765"></a>04765     <span class="keywordflow">if</span> (mScaleType == stLinear)
<a name="l04766"></a>04766     {
<a name="l04767"></a>04767       <span class="keywordflow">if</span> (mRangeReversed)
<a name="l04768"></a>04768         <span class="keywordflow">return</span> -(mAxisRect.bottom()-value)/(<span class="keywordtype">double</span>)mAxisRect.height()*mRange.size()+mRange.upper;
<a name="l04769"></a>04769       <span class="keywordflow">else</span>
<a name="l04770"></a>04770         <span class="keywordflow">return</span> (mAxisRect.bottom()-value)/(<span class="keywordtype">double</span>)mAxisRect.height()*mRange.size()+mRange.lower;
<a name="l04771"></a>04771     } <span class="keywordflow">else</span> <span class="comment">// mScaleType == stLogarithmic</span>
<a name="l04772"></a>04772     {
<a name="l04773"></a>04773       <span class="keywordflow">if</span> (mRangeReversed)
<a name="l04774"></a>04774         <span class="keywordflow">return</span> pow(mRange.upper/mRange.lower, (value-mAxisRect.bottom())/(<span class="keywordtype">double</span>)mAxisRect.height())*mRange.upper;
<a name="l04775"></a>04775       <span class="keywordflow">else</span>
<a name="l04776"></a>04776         <span class="keywordflow">return</span> pow(mRange.upper/mRange.lower, (mAxisRect.bottom()-value)/(<span class="keywordtype">double</span>)mAxisRect.height())*mRange.lower;
<a name="l04777"></a>04777     }
<a name="l04778"></a>04778   }
<a name="l04779"></a>04779 }
<a name="l04780"></a>04780 
<a name="l04784"></a>04784 <span class="keywordtype">double</span> QCPAxis::coordToPixel(<span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l04785"></a>04785 <span class="keyword"></span>{
<a name="l04786"></a>04786   <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l04787"></a>04787   {
<a name="l04788"></a>04788     <span class="keywordflow">if</span> (mScaleType == stLinear)
<a name="l04789"></a>04789     {
<a name="l04790"></a>04790       <span class="keywordflow">if</span> (mRangeReversed)
<a name="l04791"></a>04791         <span class="keywordflow">return</span> (mRange.upper-value)/mRange.size()*mAxisRect.width()+mAxisRect.left();
<a name="l04792"></a>04792       <span class="keywordflow">else</span>
<a name="l04793"></a>04793         <span class="keywordflow">return</span> (value-mRange.lower)/mRange.size()*mAxisRect.width()+mAxisRect.left();
<a name="l04794"></a>04794     } <span class="keywordflow">else</span> <span class="comment">// mScaleType == stLogarithmic</span>
<a name="l04795"></a>04795     {
<a name="l04796"></a>04796       <span class="keywordflow">if</span> (value &gt;= 0 &amp;&amp; mRange.upper &lt; 0) <span class="comment">// invalid value for logarithmic scale, just draw it outside visible range</span>
<a name="l04797"></a>04797         <span class="keywordflow">return</span> mRangeReversed ? mAxisRect.left()-200 : mAxisRect.right()+200;
<a name="l04798"></a>04798       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt;= 0 &amp;&amp; mRange.upper &gt; 0) <span class="comment">// invalid value for logarithmic scale, just draw it outside visible range</span>
<a name="l04799"></a>04799         <span class="keywordflow">return</span> mRangeReversed ? mAxisRect.right()+200 : mAxisRect.left()-200;
<a name="l04800"></a>04800       <span class="keywordflow">else</span>
<a name="l04801"></a>04801       {
<a name="l04802"></a>04802         <span class="keywordflow">if</span> (mRangeReversed)
<a name="l04803"></a>04803           <span class="keywordflow">return</span> baseLog(mRange.upper/value)/baseLog(mRange.upper/mRange.lower)*mAxisRect.width()+mAxisRect.left();
<a name="l04804"></a>04804         <span class="keywordflow">else</span>
<a name="l04805"></a>04805           <span class="keywordflow">return</span> baseLog(value/mRange.lower)/baseLog(mRange.upper/mRange.lower)*mAxisRect.width()+mAxisRect.left();
<a name="l04806"></a>04806       }
<a name="l04807"></a>04807     }
<a name="l04808"></a>04808   } <span class="keywordflow">else</span> <span class="comment">// orientation() == Qt::Vertical</span>
<a name="l04809"></a>04809   {
<a name="l04810"></a>04810     <span class="keywordflow">if</span> (mScaleType == stLinear)
<a name="l04811"></a>04811     {
<a name="l04812"></a>04812       <span class="keywordflow">if</span> (mRangeReversed)
<a name="l04813"></a>04813         <span class="keywordflow">return</span> mAxisRect.bottom()-(mRange.upper-value)/mRange.size()*mAxisRect.height();
<a name="l04814"></a>04814       <span class="keywordflow">else</span>
<a name="l04815"></a>04815         <span class="keywordflow">return</span> mAxisRect.bottom()-(value-mRange.lower)/mRange.size()*mAxisRect.height();
<a name="l04816"></a>04816     } <span class="keywordflow">else</span> <span class="comment">// mScaleType == stLogarithmic</span>
<a name="l04817"></a>04817     {     
<a name="l04818"></a>04818       <span class="keywordflow">if</span> (value &gt;= 0 &amp;&amp; mRange.upper &lt; 0) <span class="comment">// invalid value for logarithmic scale, just draw it outside visible range</span>
<a name="l04819"></a>04819         <span class="keywordflow">return</span> mRangeReversed ? mAxisRect.bottom()+200 : mAxisRect.top()-200;
<a name="l04820"></a>04820       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt;= 0 &amp;&amp; mRange.upper &gt; 0) <span class="comment">// invalid value for logarithmic scale, just draw it outside visible range</span>
<a name="l04821"></a>04821         <span class="keywordflow">return</span> mRangeReversed ? mAxisRect.top()-200 : mAxisRect.bottom()+200;
<a name="l04822"></a>04822       <span class="keywordflow">else</span>
<a name="l04823"></a>04823       {
<a name="l04824"></a>04824         <span class="keywordflow">if</span> (mRangeReversed)
<a name="l04825"></a>04825           <span class="keywordflow">return</span> mAxisRect.bottom()-baseLog(mRange.upper/value)/baseLog(mRange.upper/mRange.lower)*mAxisRect.height();
<a name="l04826"></a>04826         <span class="keywordflow">else</span>
<a name="l04827"></a>04827           <span class="keywordflow">return</span> mAxisRect.bottom()-baseLog(value/mRange.lower)/baseLog(mRange.upper/mRange.lower)*mAxisRect.height();
<a name="l04828"></a>04828       }
<a name="l04829"></a>04829     }
<a name="l04830"></a>04830   }
<a name="l04831"></a>04831 }
<a name="l04832"></a>04832 
<a name="l04842"></a>04842 QCPAxis::SelectablePart QCPAxis::selectTest(QPoint pos)<span class="keyword"> const</span>
<a name="l04843"></a>04843 <span class="keyword"></span>{
<a name="l04844"></a>04844   <span class="keywordflow">if</span> (!mVisible)
<a name="l04845"></a>04845     <span class="keywordflow">return</span> spNone;
<a name="l04846"></a>04846   
<a name="l04847"></a>04847   <span class="keywordflow">if</span> (mAxisSelectionBox.contains(pos))
<a name="l04848"></a>04848     <span class="keywordflow">return</span> spAxis;
<a name="l04849"></a>04849   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mTickLabelsSelectionBox.contains(pos))
<a name="l04850"></a>04850     <span class="keywordflow">return</span> spTickLabels;
<a name="l04851"></a>04851   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mLabelSelectionBox.contains(pos))
<a name="l04852"></a>04852     <span class="keywordflow">return</span> spAxisLabel;
<a name="l04853"></a>04853   <span class="keywordflow">else</span>
<a name="l04854"></a>04854     <span class="keywordflow">return</span> spNone;
<a name="l04855"></a>04855 }
<a name="l04856"></a>04856 
<a name="l04865"></a>04865 <span class="keywordtype">void</span> QCPAxis::generateTickVectors()
<a name="l04866"></a>04866 {
<a name="l04867"></a>04867   <span class="keywordflow">if</span> ((!mTicks &amp;&amp; !mTickLabels &amp;&amp; !mGrid) || mRange.size() &lt;= 0) <span class="keywordflow">return</span>;
<a name="l04868"></a>04868   
<a name="l04869"></a>04869   <span class="comment">// fill tick vectors, either by auto generating or by notifying user to fill the vectors himself</span>
<a name="l04870"></a>04870   <span class="keywordflow">if</span> (mAutoTicks)
<a name="l04871"></a>04871   {
<a name="l04872"></a>04872     generateAutoTicks();
<a name="l04873"></a>04873   } <span class="keywordflow">else</span>
<a name="l04874"></a>04874   {
<a name="l04875"></a>04875     emit ticksRequest();
<a name="l04876"></a>04876   }
<a name="l04877"></a>04877   
<a name="l04878"></a>04878   <span class="keywordflow">if</span> (mTickVector-&gt;isEmpty())
<a name="l04879"></a>04879   {
<a name="l04880"></a>04880     mSubTickVector-&gt;clear();
<a name="l04881"></a>04881     <span class="keywordflow">return</span>;
<a name="l04882"></a>04882   }
<a name="l04883"></a>04883   
<a name="l04884"></a>04884   <span class="comment">// generate subticks between ticks:</span>
<a name="l04885"></a>04885   mSubTickVector-&gt;resize((mTickVector-&gt;size()-1)*mSubTickCount);
<a name="l04886"></a>04886   <span class="keywordflow">if</span> (mSubTickCount &gt; 0)
<a name="l04887"></a>04887   {
<a name="l04888"></a>04888     <span class="keywordtype">double</span> subTickStep = 0;
<a name="l04889"></a>04889     <span class="keywordtype">double</span> subTickPosition = 0;
<a name="l04890"></a>04890     <span class="keywordtype">int</span> subTickIndex = 0;
<a name="l04891"></a>04891     <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;
<a name="l04892"></a>04892     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;mTickVector-&gt;size(); ++i)
<a name="l04893"></a>04893     {
<a name="l04894"></a>04894       subTickStep = (mTickVector-&gt;at(i)-mTickVector-&gt;at(i-1))/(<span class="keywordtype">double</span>)(mSubTickCount+1);
<a name="l04895"></a>04895       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=1; k&lt;=mSubTickCount; ++k)
<a name="l04896"></a>04896       {
<a name="l04897"></a>04897         subTickPosition = mTickVector-&gt;at(i-1) + k*subTickStep;
<a name="l04898"></a>04898         <span class="keywordflow">if</span> (subTickPosition &lt; mRange.lower)
<a name="l04899"></a>04899           <span class="keywordflow">continue</span>;
<a name="l04900"></a>04900         <span class="keywordflow">if</span> (subTickPosition &gt; mRange.upper)
<a name="l04901"></a>04901         {
<a name="l04902"></a>04902           done = <span class="keyword">true</span>;
<a name="l04903"></a>04903           <span class="keywordflow">break</span>;
<a name="l04904"></a>04904         }
<a name="l04905"></a>04905         (*mSubTickVector)[subTickIndex] = subTickPosition;
<a name="l04906"></a>04906         subTickIndex++;
<a name="l04907"></a>04907       }
<a name="l04908"></a>04908       <span class="keywordflow">if</span> (done) <span class="keywordflow">break</span>;
<a name="l04909"></a>04909     }
<a name="l04910"></a>04910     mSubTickVector-&gt;resize(subTickIndex);
<a name="l04911"></a>04911   }
<a name="l04912"></a>04912 
<a name="l04913"></a>04913   <span class="comment">// generate tick labels according to tick positions:</span>
<a name="l04914"></a>04914   mExponentialChar = mParentPlot-&gt;locale().exponential();   <span class="comment">// will be needed when drawing the numbers generated here, in drawTickLabel()</span>
<a name="l04915"></a>04915   mPositiveSignChar = mParentPlot-&gt;locale().positiveSign(); <span class="comment">// will be needed when drawing the numbers generated here, in drawTickLabel()</span>
<a name="l04916"></a>04916   <span class="keywordflow">if</span> (mAutoTickLabels)
<a name="l04917"></a>04917   {
<a name="l04918"></a>04918     <span class="keywordtype">int</span> vecsize = mTickVector-&gt;size();
<a name="l04919"></a>04919     mTickVectorLabels-&gt;resize(vecsize);
<a name="l04920"></a>04920     <span class="keywordflow">if</span> (mTickLabelType == ltNumber)
<a name="l04921"></a>04921     {
<a name="l04922"></a>04922       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;vecsize; ++i)
<a name="l04923"></a>04923         (*mTickVectorLabels)[i] = mParentPlot-&gt;locale().toString(mTickVector-&gt;at(i), mNumberFormatChar, mNumberPrecision);
<a name="l04924"></a>04924     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mTickLabelType == ltDateTime)
<a name="l04925"></a>04925     {
<a name="l04926"></a>04926       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;vecsize; ++i)
<a name="l04927"></a>04927       {
<a name="l04928"></a>04928 <span class="preprocessor">#if QT_VERSION &lt; QT_VERSION_CHECK(4, 7, 0) // use fromMSecsSinceEpoch function if available, to gain sub-second accuracy on tick labels (e.g. for format &quot;hh:mm:ss:zzz&quot;)</span>
<a name="l04929"></a>04929 <span class="preprocessor"></span>        (*mTickVectorLabels)[i] = mParentPlot-&gt;locale().toString(QDateTime::fromTime_t(mTickVector-&gt;at(i)), mDateTimeFormat);
<a name="l04930"></a>04930 <span class="preprocessor">#else</span>
<a name="l04931"></a>04931 <span class="preprocessor"></span>        (*mTickVectorLabels)[i] = mParentPlot-&gt;locale().toString(QDateTime::fromMSecsSinceEpoch(mTickVector-&gt;at(i)*1000), mDateTimeFormat);
<a name="l04932"></a>04932 <span class="preprocessor">#endif</span>
<a name="l04933"></a>04933 <span class="preprocessor"></span>      }
<a name="l04934"></a>04934     }
<a name="l04935"></a>04935   } <span class="keywordflow">else</span> <span class="comment">// mAutoTickLabels == false</span>
<a name="l04936"></a>04936   {
<a name="l04937"></a>04937     <span class="keywordflow">if</span> (mAutoTicks) <span class="comment">// ticks generated automatically, but not ticklabels, so emit ticksRequest here for labels</span>
<a name="l04938"></a>04938     {
<a name="l04939"></a>04939       emit ticksRequest();
<a name="l04940"></a>04940     }
<a name="l04941"></a>04941     <span class="comment">// make sure provided tick label vector has correct (minimal) length:</span>
<a name="l04942"></a>04942     <span class="keywordflow">if</span> (mTickVectorLabels-&gt;size() &lt; mTickVector-&gt;size())
<a name="l04943"></a>04943       mTickVectorLabels-&gt;resize(mTickVector-&gt;size());
<a name="l04944"></a>04944   }
<a name="l04945"></a>04945 }
<a name="l04946"></a>04946 
<a name="l04956"></a>04956 <span class="keywordtype">void</span> QCPAxis::generateAutoTicks()
<a name="l04957"></a>04957 {
<a name="l04958"></a>04958   <span class="keywordflow">if</span> (mScaleType == stLinear)
<a name="l04959"></a>04959   {
<a name="l04960"></a>04960     <span class="keywordflow">if</span> (mAutoTickStep)
<a name="l04961"></a>04961     {
<a name="l04962"></a>04962       <span class="comment">// Generate tick positions according to linear scaling:</span>
<a name="l04963"></a>04963       mTickStep = mRange.size()/(double)mAutoTickCount; <span class="comment">// mAutoTickCount ticks on average</span>
<a name="l04964"></a>04964       <span class="keywordtype">double</span> magnitudeFactor = pow((<span class="keywordtype">double</span>)10, (<span class="keywordtype">int</span>)floor(log10(mTickStep))); <span class="comment">// get magnitude factor e.g. 0.01, 1, 10, 1000 etc.</span>
<a name="l04965"></a>04965       <span class="keywordtype">double</span> tickStepMantissa = mTickStep/magnitudeFactor;
<a name="l04966"></a>04966       <span class="keywordflow">if</span> (tickStepMantissa &lt; 5)
<a name="l04967"></a>04967       {
<a name="l04968"></a>04968         <span class="comment">// round digit after decimal point to 0.5</span>
<a name="l04969"></a>04969         mTickStep = (int)(tickStepMantissa*2)/2.0*magnitudeFactor;
<a name="l04970"></a>04970       } <span class="keywordflow">else</span>
<a name="l04971"></a>04971       {
<a name="l04972"></a>04972         <span class="comment">// round to first digit in multiples of 2</span>
<a name="l04973"></a>04973         mTickStep = (int)((tickStepMantissa/10.0)*5)/5.0*10*magnitudeFactor;
<a name="l04974"></a>04974       }
<a name="l04975"></a>04975     }
<a name="l04976"></a>04976     <span class="keywordflow">if</span> (mAutoSubTicks)
<a name="l04977"></a>04977       mSubTickCount = calculateAutoSubTickCount(mTickStep);
<a name="l04978"></a>04978     <span class="comment">// Generate tick positions according to mTickStep:</span>
<a name="l04979"></a>04979     <span class="keywordtype">int</span> firstStep = floor(mRange.lower/mTickStep);
<a name="l04980"></a>04980     <span class="keywordtype">int</span> lastStep = ceil(mRange.upper/mTickStep);
<a name="l04981"></a>04981     <span class="keywordtype">int</span> tickcount = lastStep-firstStep+1;
<a name="l04982"></a>04982     <span class="keywordflow">if</span> (tickcount &lt; 0) tickcount = 0;
<a name="l04983"></a>04983     mTickVector-&gt;resize(tickcount);
<a name="l04984"></a>04984     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;tickcount; ++i)
<a name="l04985"></a>04985     {
<a name="l04986"></a>04986       (*mTickVector)[i] = (firstStep+i)*mTickStep;
<a name="l04987"></a>04987     }
<a name="l04988"></a>04988   } <span class="keywordflow">else</span> <span class="comment">// mScaleType == stLogarithmic</span>
<a name="l04989"></a>04989   {
<a name="l04990"></a>04990     <span class="comment">// Generate tick positions according to logbase scaling:</span>
<a name="l04991"></a>04991     <span class="keywordflow">if</span> (mRange.lower &gt; 0 &amp;&amp; mRange.upper &gt; 0) <span class="comment">// positive range</span>
<a name="l04992"></a>04992     {
<a name="l04993"></a>04993       <span class="keywordtype">double</span> lowerMag = basePow((<span class="keywordtype">int</span>)floor(baseLog(mRange.lower)));
<a name="l04994"></a>04994       <span class="keywordtype">double</span> currentMag = lowerMag;
<a name="l04995"></a>04995       mTickVector-&gt;clear();
<a name="l04996"></a>04996       mTickVector-&gt;append(currentMag);
<a name="l04997"></a>04997       <span class="keywordflow">while</span> (currentMag &lt; mRange.upper &amp;&amp; currentMag &gt; 0) <span class="comment">// currentMag might be zero for ranges ~1e-300, just cancel in that case</span>
<a name="l04998"></a>04998       {
<a name="l04999"></a>04999         currentMag *= mScaleLogBase;
<a name="l05000"></a>05000         mTickVector-&gt;append(currentMag);
<a name="l05001"></a>05001       }
<a name="l05002"></a>05002     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mRange.lower &lt; 0 &amp;&amp; mRange.upper &lt; 0) <span class="comment">// negative range</span>
<a name="l05003"></a>05003     {
<a name="l05004"></a>05004       <span class="keywordtype">double</span> lowerMag = -basePow((<span class="keywordtype">int</span>)ceil(baseLog(-mRange.lower)));
<a name="l05005"></a>05005       <span class="keywordtype">double</span> currentMag = lowerMag;
<a name="l05006"></a>05006       mTickVector-&gt;clear();
<a name="l05007"></a>05007       mTickVector-&gt;append(currentMag);
<a name="l05008"></a>05008       <span class="keywordflow">while</span> (currentMag &lt; mRange.upper &amp;&amp; currentMag &lt; 0) <span class="comment">// currentMag might be zero for ranges ~1e-300, just cancel in that case</span>
<a name="l05009"></a>05009       {
<a name="l05010"></a>05010         currentMag /= mScaleLogBase;
<a name="l05011"></a>05011         mTickVector-&gt;append(currentMag);
<a name="l05012"></a>05012       }
<a name="l05013"></a>05013     } <span class="keywordflow">else</span> <span class="comment">// invalid range for logarithmic scale, because lower and upper have different sign</span>
<a name="l05014"></a>05014     {
<a name="l05015"></a>05015       mTickVector-&gt;clear();
<a name="l05016"></a>05016       qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;Invalid range for logarithmic plot: &quot;</span> &lt;&lt; mRange.lower &lt;&lt; <span class="stringliteral">&quot;-&quot;</span> &lt;&lt; mRange.upper;
<a name="l05017"></a>05017     }
<a name="l05018"></a>05018   }
<a name="l05019"></a>05019 }
<a name="l05020"></a>05020 
<a name="l05034"></a>05034 <span class="keywordtype">int</span> QCPAxis::calculateAutoSubTickCount(<span class="keywordtype">double</span> tickStep)<span class="keyword"> const</span>
<a name="l05035"></a>05035 <span class="keyword"></span>{
<a name="l05036"></a>05036   <span class="keywordtype">int</span> result = mSubTickCount; <span class="comment">// default to current setting, if no proper value can be found</span>
<a name="l05037"></a>05037   
<a name="l05038"></a>05038   <span class="comment">// get mantissa of tickstep:</span>
<a name="l05039"></a>05039   <span class="keywordtype">double</span> magnitudeFactor = pow((<span class="keywordtype">double</span>)10, (<span class="keywordtype">int</span>)floor(log10(tickStep))); <span class="comment">// get magnitude factor e.g. 0.01, 1, 10, 1000 etc.</span>
<a name="l05040"></a>05040   <span class="keywordtype">double</span> tickStepMantissa = tickStep/magnitudeFactor;
<a name="l05041"></a>05041   
<a name="l05042"></a>05042   <span class="comment">// separate integer and fractional part of mantissa:</span>
<a name="l05043"></a>05043   <span class="keywordtype">double</span> epsilon = 0.01;
<a name="l05044"></a>05044   <span class="keywordtype">double</span> intPartf;
<a name="l05045"></a>05045   <span class="keywordtype">int</span> intPart;
<a name="l05046"></a>05046   <span class="keywordtype">double</span> fracPart = modf(tickStepMantissa, &amp;intPartf);
<a name="l05047"></a>05047   intPart = intPartf;
<a name="l05048"></a>05048   
<a name="l05049"></a>05049   <span class="comment">// handle cases with (almost) integer mantissa:</span>
<a name="l05050"></a>05050   <span class="keywordflow">if</span> (fracPart &lt; epsilon || 1.0-fracPart &lt; epsilon)
<a name="l05051"></a>05051   {
<a name="l05052"></a>05052     <span class="keywordflow">if</span> (1.0-fracPart &lt; epsilon)
<a name="l05053"></a>05053       intPart++;
<a name="l05054"></a>05054     <span class="keywordflow">switch</span> (intPart)
<a name="l05055"></a>05055     {
<a name="l05056"></a>05056       <span class="keywordflow">case</span> 1: result = 4; <span class="keywordflow">break</span>; <span class="comment">// 1.0 -&gt; 0.2 substep</span>
<a name="l05057"></a>05057       <span class="keywordflow">case</span> 2: result = 3; <span class="keywordflow">break</span>; <span class="comment">// 2.0 -&gt; 0.5 substep</span>
<a name="l05058"></a>05058       <span class="keywordflow">case</span> 3: result = 2; <span class="keywordflow">break</span>; <span class="comment">// 3.0 -&gt; 1.0 substep</span>
<a name="l05059"></a>05059       <span class="keywordflow">case</span> 4: result = 3; <span class="keywordflow">break</span>; <span class="comment">// 4.0 -&gt; 1.0 substep</span>
<a name="l05060"></a>05060       <span class="keywordflow">case</span> 5: result = 4; <span class="keywordflow">break</span>; <span class="comment">// 5.0 -&gt; 1.0 substep</span>
<a name="l05061"></a>05061       <span class="keywordflow">case</span> 6: result = 2; <span class="keywordflow">break</span>; <span class="comment">// 6.0 -&gt; 2.0 substep</span>
<a name="l05062"></a>05062       <span class="keywordflow">case</span> 7: result = 6; <span class="keywordflow">break</span>; <span class="comment">// 7.0 -&gt; 1.0 substep</span>
<a name="l05063"></a>05063       <span class="keywordflow">case</span> 8: result = 3; <span class="keywordflow">break</span>; <span class="comment">// 8.0 -&gt; 2.0 substep</span>
<a name="l05064"></a>05064       <span class="keywordflow">case</span> 9: result = 2; <span class="keywordflow">break</span>; <span class="comment">// 9.0 -&gt; 3.0 substep</span>
<a name="l05065"></a>05065     }
<a name="l05066"></a>05066   } <span class="keywordflow">else</span>
<a name="l05067"></a>05067   {
<a name="l05068"></a>05068     <span class="comment">// handle cases with significantly fractional mantissa:</span>
<a name="l05069"></a>05069     <span class="keywordflow">if</span> (qAbs(fracPart-0.5) &lt; epsilon) <span class="comment">// *.5 mantissa</span>
<a name="l05070"></a>05070     {
<a name="l05071"></a>05071       <span class="keywordflow">switch</span> (intPart)
<a name="l05072"></a>05072       {
<a name="l05073"></a>05073         <span class="keywordflow">case</span> 1: result = 2; <span class="keywordflow">break</span>; <span class="comment">// 1.5 -&gt; 0.5 substep</span>
<a name="l05074"></a>05074         <span class="keywordflow">case</span> 2: result = 4; <span class="keywordflow">break</span>; <span class="comment">// 2.5 -&gt; 0.5 substep</span>
<a name="l05075"></a>05075         <span class="keywordflow">case</span> 3: result = 4; <span class="keywordflow">break</span>; <span class="comment">// 3.5 -&gt; 0.7 substep</span>
<a name="l05076"></a>05076         <span class="keywordflow">case</span> 4: result = 2; <span class="keywordflow">break</span>; <span class="comment">// 4.5 -&gt; 1.5 substep</span>
<a name="l05077"></a>05077         <span class="keywordflow">case</span> 5: result = 4; <span class="keywordflow">break</span>; <span class="comment">// 5.5 -&gt; 1.1 substep (won&#39;t occur with autoTickStep from here on)</span>
<a name="l05078"></a>05078         <span class="keywordflow">case</span> 6: result = 4; <span class="keywordflow">break</span>; <span class="comment">// 6.5 -&gt; 1.3 substep</span>
<a name="l05079"></a>05079         <span class="keywordflow">case</span> 7: result = 2; <span class="keywordflow">break</span>; <span class="comment">// 7.5 -&gt; 2.5 substep</span>
<a name="l05080"></a>05080         <span class="keywordflow">case</span> 8: result = 4; <span class="keywordflow">break</span>; <span class="comment">// 8.5 -&gt; 1.7 substep</span>
<a name="l05081"></a>05081         <span class="keywordflow">case</span> 9: result = 4; <span class="keywordflow">break</span>; <span class="comment">// 9.5 -&gt; 1.9 substep</span>
<a name="l05082"></a>05082       }
<a name="l05083"></a>05083     }
<a name="l05084"></a>05084     <span class="comment">// if mantissa fraction isnt 0.0 or 0.5, don&#39;t bother finding good sub tick marks, leave default</span>
<a name="l05085"></a>05085   }
<a name="l05086"></a>05086   
<a name="l05087"></a>05087   <span class="keywordflow">return</span> result;
<a name="l05088"></a>05088 }
<a name="l05089"></a>05089 
<a name="l05096"></a>05096 <span class="keywordtype">void</span> QCPAxis::drawGrid(QPainter *painter)
<a name="l05097"></a>05097 {
<a name="l05098"></a>05098   <span class="keywordflow">if</span> (!mVisible || (!mGrid &amp;&amp; mZeroLinePen.style() == Qt::NoPen)) <span class="keywordflow">return</span>;
<a name="l05099"></a>05099   painter-&gt;save();
<a name="l05100"></a>05100   <span class="keywordtype">int</span> lowTick, highTick;
<a name="l05101"></a>05101   visibleTickBounds(lowTick, highTick);
<a name="l05102"></a>05102   <span class="keywordtype">int</span> t; <span class="comment">// helper variable, result of coordinate-to-pixel transforms</span>
<a name="l05103"></a>05103   <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l05104"></a>05104   {
<a name="l05105"></a>05105     <span class="comment">// draw zeroline:</span>
<a name="l05106"></a>05106     <span class="keywordtype">int</span> zeroLineIndex = -1;
<a name="l05107"></a>05107     <span class="keywordflow">if</span> (mZeroLinePen.style() != Qt::NoPen &amp;&amp; mRange.lower &lt; 0 &amp;&amp; mRange.upper &gt; 0)
<a name="l05108"></a>05108     {
<a name="l05109"></a>05109       painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeZeroLine));
<a name="l05110"></a>05110       painter-&gt;setPen(mZeroLinePen);
<a name="l05111"></a>05111       <span class="keywordtype">double</span> epsilon = mRange.size()*1E-6; <span class="comment">// for comparing double to zero</span>
<a name="l05112"></a>05112       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lowTick; i &lt;= highTick; ++i)
<a name="l05113"></a>05113       {
<a name="l05114"></a>05114         <span class="keywordflow">if</span> (fabs(mTickVector-&gt;at(i)) &lt; epsilon)
<a name="l05115"></a>05115         {
<a name="l05116"></a>05116           zeroLineIndex = i;
<a name="l05117"></a>05117           t = coordToPixel(mTickVector-&gt;at(i)); <span class="comment">// x</span>
<a name="l05118"></a>05118           painter-&gt;drawLine(t, mAxisRect.bottom(), t, mAxisRect.top());
<a name="l05119"></a>05119           <span class="keywordflow">break</span>;
<a name="l05120"></a>05120         }
<a name="l05121"></a>05121       }
<a name="l05122"></a>05122     }
<a name="l05123"></a>05123     <span class="comment">// draw grid lines:</span>
<a name="l05124"></a>05124     <span class="keywordflow">if</span> (mGrid)
<a name="l05125"></a>05125     {
<a name="l05126"></a>05126       painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGrid));
<a name="l05127"></a>05127       painter-&gt;setPen(mGridPen);
<a name="l05128"></a>05128       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lowTick; i &lt;= highTick; ++i)
<a name="l05129"></a>05129       {
<a name="l05130"></a>05130         <span class="keywordflow">if</span> (i == zeroLineIndex) <span class="keywordflow">continue</span>; <span class="comment">// don&#39;t draw a gridline on top of the zeroline</span>
<a name="l05131"></a>05131         t = coordToPixel(mTickVector-&gt;at(i)); <span class="comment">// x</span>
<a name="l05132"></a>05132         painter-&gt;drawLine(t, mAxisRect.bottom(), t, mAxisRect.top());
<a name="l05133"></a>05133       }
<a name="l05134"></a>05134     }
<a name="l05135"></a>05135   } <span class="keywordflow">else</span>
<a name="l05136"></a>05136   {
<a name="l05137"></a>05137     <span class="comment">// draw zeroline:</span>
<a name="l05138"></a>05138     <span class="keywordtype">int</span> zeroLineIndex = -1;
<a name="l05139"></a>05139     <span class="keywordflow">if</span> (mZeroLinePen.style() != Qt::NoPen &amp;&amp; mRange.lower &lt; 0 &amp;&amp; mRange.upper &gt; 0)
<a name="l05140"></a>05140     {
<a name="l05141"></a>05141       painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeZeroLine));
<a name="l05142"></a>05142       painter-&gt;setPen(mZeroLinePen);
<a name="l05143"></a>05143       <span class="keywordtype">double</span> epsilon = mRange.size()*1E-6; <span class="comment">// for comparing double to zero</span>
<a name="l05144"></a>05144       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lowTick; i &lt;= highTick; ++i)
<a name="l05145"></a>05145       {
<a name="l05146"></a>05146         <span class="keywordflow">if</span> (fabs(mTickVector-&gt;at(i)) &lt; epsilon)
<a name="l05147"></a>05147         {
<a name="l05148"></a>05148           zeroLineIndex = i;
<a name="l05149"></a>05149           t = coordToPixel(mTickVector-&gt;at(i)); <span class="comment">// y</span>
<a name="l05150"></a>05150           painter-&gt;drawLine(mAxisRect.left(), t, mAxisRect.right(), t);
<a name="l05151"></a>05151           <span class="keywordflow">break</span>;
<a name="l05152"></a>05152         }
<a name="l05153"></a>05153       }
<a name="l05154"></a>05154     }
<a name="l05155"></a>05155     <span class="comment">// draw grid lines:</span>
<a name="l05156"></a>05156     <span class="keywordflow">if</span> (mGrid)
<a name="l05157"></a>05157     {
<a name="l05158"></a>05158       painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGrid));
<a name="l05159"></a>05159       painter-&gt;setPen(mGridPen);
<a name="l05160"></a>05160       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lowTick; i &lt;= highTick; ++i)
<a name="l05161"></a>05161       {
<a name="l05162"></a>05162         <span class="keywordflow">if</span> (i == zeroLineIndex) <span class="keywordflow">continue</span>; <span class="comment">// don&#39;t draw a gridline on top of the zeroline</span>
<a name="l05163"></a>05163         t = coordToPixel(mTickVector-&gt;at(i)); <span class="comment">// y</span>
<a name="l05164"></a>05164         painter-&gt;drawLine(mAxisRect.left(), t, mAxisRect.right(), t);
<a name="l05165"></a>05165       }
<a name="l05166"></a>05166     }
<a name="l05167"></a>05167   }
<a name="l05168"></a>05168   painter-&gt;restore();
<a name="l05169"></a>05169 }
<a name="l05170"></a>05170 
<a name="l05176"></a>05176 <span class="keywordtype">void</span> QCPAxis::drawSubGrid(QPainter *painter)
<a name="l05177"></a>05177 {
<a name="l05178"></a>05178   <span class="keywordflow">if</span> (!mVisible || !mSubGrid || !mGrid) <span class="keywordflow">return</span>;
<a name="l05179"></a>05179   painter-&gt;save();
<a name="l05180"></a>05180   painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeSubGrid));
<a name="l05181"></a>05181   
<a name="l05182"></a>05182   <span class="keywordtype">int</span> t; <span class="comment">// helper variable, result of coordinate-to-pixel transforms</span>
<a name="l05183"></a>05183   painter-&gt;setPen(mSubGridPen);
<a name="l05184"></a>05184   <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l05185"></a>05185   {
<a name="l05186"></a>05186     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mSubTickVector-&gt;size(); ++i)
<a name="l05187"></a>05187     {
<a name="l05188"></a>05188       t = coordToPixel(mSubTickVector-&gt;at(i)); <span class="comment">// x</span>
<a name="l05189"></a>05189       painter-&gt;drawLine(t, mAxisRect.bottom(), t, mAxisRect.top());
<a name="l05190"></a>05190     }
<a name="l05191"></a>05191   } <span class="keywordflow">else</span>
<a name="l05192"></a>05192   {
<a name="l05193"></a>05193     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mSubTickVector-&gt;size(); ++i)
<a name="l05194"></a>05194     {
<a name="l05195"></a>05195       t = coordToPixel(mSubTickVector-&gt;at(i)); <span class="comment">// y</span>
<a name="l05196"></a>05196       painter-&gt;drawLine(mAxisRect.left(), t, mAxisRect.right(), t);
<a name="l05197"></a>05197     }
<a name="l05198"></a>05198   }
<a name="l05199"></a>05199   painter-&gt;restore();
<a name="l05200"></a>05200 }
<a name="l05201"></a>05201 
<a name="l05209"></a>05209 <span class="keywordtype">void</span> QCPAxis::drawAxis(QPainter *painter)
<a name="l05210"></a>05210 {
<a name="l05211"></a>05211   <span class="keywordflow">if</span> (!mVisible) <span class="keywordflow">return</span>;
<a name="l05212"></a>05212   painter-&gt;save();
<a name="l05213"></a>05213   painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeAxes));
<a name="l05214"></a>05214   QPoint origin;
<a name="l05215"></a>05215   <span class="keywordflow">if</span> (mAxisType == atLeft)
<a name="l05216"></a>05216     origin = mAxisRect.bottomLeft();
<a name="l05217"></a>05217   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atRight)
<a name="l05218"></a>05218     origin = mAxisRect.bottomRight();
<a name="l05219"></a>05219   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atTop)
<a name="l05220"></a>05220     origin = mAxisRect.topLeft();
<a name="l05221"></a>05221   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atBottom)
<a name="l05222"></a>05222     origin = mAxisRect.bottomLeft();
<a name="l05223"></a>05223   
<a name="l05224"></a>05224   <span class="keywordtype">int</span> xCor = 0, yCor = 0; <span class="comment">// paint system correction, for pixel exact matches (affects baselines and ticks of top/right axes)</span>
<a name="l05225"></a>05225   <span class="keywordflow">if</span> (mAxisType == atTop)
<a name="l05226"></a>05226     yCor = -1;
<a name="l05227"></a>05227   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atRight)
<a name="l05228"></a>05228     xCor = 1;
<a name="l05229"></a>05229   
<a name="l05230"></a>05230   <span class="keywordtype">int</span> margin = 0;
<a name="l05231"></a>05231   <span class="keywordtype">int</span> lowTick, highTick;
<a name="l05232"></a>05232   visibleTickBounds(lowTick, highTick);
<a name="l05233"></a>05233   <span class="keywordtype">int</span> t; <span class="comment">// helper variable, result of coordinate-to-pixel transforms</span>
<a name="l05234"></a>05234 
<a name="l05235"></a>05235   <span class="comment">// draw baseline:</span>
<a name="l05236"></a>05236   painter-&gt;setPen(getBasePen());
<a name="l05237"></a>05237   <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l05238"></a>05238     painter-&gt;drawLine(origin+QPoint(xCor, yCor), origin+QPoint(mAxisRect.width()+xCor, yCor));
<a name="l05239"></a>05239   <span class="keywordflow">else</span>
<a name="l05240"></a>05240     painter-&gt;drawLine(origin+QPoint(xCor, yCor), origin+QPoint(xCor, -mAxisRect.height()+yCor));
<a name="l05241"></a>05241   
<a name="l05242"></a>05242   <span class="comment">// draw ticks:</span>
<a name="l05243"></a>05243   <span class="keywordflow">if</span> (mTicks)
<a name="l05244"></a>05244   {
<a name="l05245"></a>05245     painter-&gt;setPen(getTickPen());
<a name="l05246"></a>05246     <span class="comment">// direction of ticks (&quot;inward&quot; is right for left axis and left for right axis)</span>
<a name="l05247"></a>05247     <span class="keywordtype">int</span> tickDir = (mAxisType == atBottom || mAxisType == atRight) ? -1 : 1;
<a name="l05248"></a>05248     <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l05249"></a>05249     {
<a name="l05250"></a>05250       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lowTick; i &lt;= highTick; ++i)
<a name="l05251"></a>05251       {
<a name="l05252"></a>05252         t = coordToPixel(mTickVector-&gt;at(i)); <span class="comment">// x</span>
<a name="l05253"></a>05253         painter-&gt;drawLine(t+xCor, origin.y()-mTickLengthOut*tickDir+yCor, t+xCor, origin.y()+mTickLengthIn*tickDir+yCor);
<a name="l05254"></a>05254       }
<a name="l05255"></a>05255     } <span class="keywordflow">else</span>
<a name="l05256"></a>05256     {
<a name="l05257"></a>05257       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lowTick; i &lt;= highTick; ++i)
<a name="l05258"></a>05258       {
<a name="l05259"></a>05259         t = coordToPixel(mTickVector-&gt;at(i)); <span class="comment">// y</span>
<a name="l05260"></a>05260         painter-&gt;drawLine(origin.x()-mTickLengthOut*tickDir+xCor, t+yCor, origin.x()+mTickLengthIn*tickDir+xCor, t+yCor);
<a name="l05261"></a>05261       }
<a name="l05262"></a>05262     }
<a name="l05263"></a>05263   }
<a name="l05264"></a>05264   
<a name="l05265"></a>05265   <span class="comment">// draw subticks:</span>
<a name="l05266"></a>05266   <span class="keywordflow">if</span> (mTicks &amp;&amp; mSubTickCount &gt; 0)
<a name="l05267"></a>05267   {
<a name="l05268"></a>05268     painter-&gt;setPen(getSubTickPen());
<a name="l05269"></a>05269     <span class="comment">// direction of ticks (&quot;inward&quot; is right for left axis and left for right axis)</span>
<a name="l05270"></a>05270     <span class="keywordtype">int</span> tickDir = (mAxisType == atBottom || mAxisType == atRight) ? -1 : 1;
<a name="l05271"></a>05271     <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l05272"></a>05272     {
<a name="l05273"></a>05273       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mSubTickVector-&gt;size(); ++i) <span class="comment">// no need to check bounds because subticks are always only created inside current mRange</span>
<a name="l05274"></a>05274       {
<a name="l05275"></a>05275         t = coordToPixel(mSubTickVector-&gt;at(i));
<a name="l05276"></a>05276         painter-&gt;drawLine(t+xCor, origin.y()-mSubTickLengthOut*tickDir+yCor, t+xCor, origin.y()+mSubTickLengthIn*tickDir+yCor);
<a name="l05277"></a>05277       }
<a name="l05278"></a>05278     } <span class="keywordflow">else</span>
<a name="l05279"></a>05279     {
<a name="l05280"></a>05280       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mSubTickVector-&gt;size(); ++i)
<a name="l05281"></a>05281       {
<a name="l05282"></a>05282         t = coordToPixel(mSubTickVector-&gt;at(i));
<a name="l05283"></a>05283         painter-&gt;drawLine(origin.x()-mSubTickLengthOut*tickDir+xCor, t+yCor, origin.x()+mSubTickLengthIn*tickDir+xCor, t+yCor);
<a name="l05284"></a>05284       }
<a name="l05285"></a>05285     }
<a name="l05286"></a>05286   }
<a name="l05287"></a>05287   margin += qMax(0, qMax(mTickLengthOut, mSubTickLengthOut));
<a name="l05288"></a>05288   
<a name="l05289"></a>05289   <span class="comment">// tick labels:</span>
<a name="l05290"></a>05290   QSize tickLabelsSize(0, 0); <span class="comment">// size of largest tick label, for offset calculation of axis label</span>
<a name="l05291"></a>05291   <span class="keywordflow">if</span> (mTickLabels)
<a name="l05292"></a>05292   {
<a name="l05293"></a>05293     margin += mTickLabelPadding;
<a name="l05294"></a>05294     painter-&gt;setFont(getTickLabelFont());
<a name="l05295"></a>05295     painter-&gt;setPen(QPen(getTickLabelColor()));
<a name="l05296"></a>05296     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lowTick; i &lt;= highTick; ++i)
<a name="l05297"></a>05297     {
<a name="l05298"></a>05298       t = coordToPixel(mTickVector-&gt;at(i));
<a name="l05299"></a>05299       drawTickLabel(painter, t, margin, mTickVectorLabels-&gt;at(i), &amp;tickLabelsSize);
<a name="l05300"></a>05300     }
<a name="l05301"></a>05301   }
<a name="l05302"></a>05302   <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l05303"></a>05303     margin += tickLabelsSize.height();
<a name="l05304"></a>05304   <span class="keywordflow">else</span>
<a name="l05305"></a>05305     margin += tickLabelsSize.width();
<a name="l05306"></a>05306 
<a name="l05307"></a>05307   <span class="comment">// axis label:</span>
<a name="l05308"></a>05308   QRect labelBounds;
<a name="l05309"></a>05309   <span class="keywordflow">if</span> (!mLabel.isEmpty())
<a name="l05310"></a>05310   {
<a name="l05311"></a>05311     margin += mLabelPadding;
<a name="l05312"></a>05312     painter-&gt;setFont(getLabelFont());
<a name="l05313"></a>05313     painter-&gt;setPen(QPen(getLabelColor()));
<a name="l05314"></a>05314     labelBounds = painter-&gt;fontMetrics().boundingRect(0, 0, 0, 0, Qt::TextDontClip, mLabel);
<a name="l05315"></a>05315     <span class="keywordflow">if</span> (mAxisType == atLeft)
<a name="l05316"></a>05316     {
<a name="l05317"></a>05317       QTransform oldTransform = painter-&gt;transform();
<a name="l05318"></a>05318       painter-&gt;translate((origin.x()-margin-labelBounds.height()), origin.y());
<a name="l05319"></a>05319       painter-&gt;rotate(-90);
<a name="l05320"></a>05320       painter-&gt;drawText(0, 0, mAxisRect.height(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, mLabel);
<a name="l05321"></a>05321       painter-&gt;setTransform(oldTransform);
<a name="l05322"></a>05322     }
<a name="l05323"></a>05323     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atRight)
<a name="l05324"></a>05324     {
<a name="l05325"></a>05325       QTransform oldTransform = painter-&gt;transform();
<a name="l05326"></a>05326       painter-&gt;translate((origin.x()+margin+labelBounds.height()), origin.y()-mAxisRect.height());
<a name="l05327"></a>05327       painter-&gt;rotate(90);
<a name="l05328"></a>05328       painter-&gt;drawText(0, 0, mAxisRect.height(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, mLabel);
<a name="l05329"></a>05329       painter-&gt;setTransform(oldTransform);
<a name="l05330"></a>05330     }
<a name="l05331"></a>05331     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atTop)
<a name="l05332"></a>05332       painter-&gt;drawText(origin.x(), origin.y()-margin-labelBounds.height(), mAxisRect.width(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, mLabel);
<a name="l05333"></a>05333     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atBottom)
<a name="l05334"></a>05334       painter-&gt;drawText(origin.x(), origin.y()+margin, mAxisRect.width(), labelBounds.height(), Qt::TextDontClip | Qt::AlignCenter, mLabel);
<a name="l05335"></a>05335   }
<a name="l05336"></a>05336   
<a name="l05337"></a>05337   <span class="comment">// set selection boxes:</span>
<a name="l05338"></a>05338   <span class="keywordtype">int</span> selAxisOutSize = qMax(qMax(mTickLengthOut, mSubTickLengthOut), mParentPlot-&gt;selectionTolerance());
<a name="l05339"></a>05339   <span class="keywordtype">int</span> selAxisInSize = mParentPlot-&gt;selectionTolerance();
<a name="l05340"></a>05340   <span class="keywordtype">int</span> selTickLabelSize = (orientation()==Qt::Horizontal ? tickLabelsSize.height() : tickLabelsSize.width());
<a name="l05341"></a>05341   <span class="keywordtype">int</span> selTickLabelOffset = qMax(mTickLengthOut, mSubTickLengthOut)+mTickLabelPadding;
<a name="l05342"></a>05342   <span class="keywordtype">int</span> selLabelSize = labelBounds.height();
<a name="l05343"></a>05343   <span class="keywordtype">int</span> selLabelOffset = selTickLabelOffset+selTickLabelSize+mLabelPadding;
<a name="l05344"></a>05344   <span class="keywordflow">if</span> (mAxisType == atLeft)
<a name="l05345"></a>05345   {
<a name="l05346"></a>05346     mAxisSelectionBox.setCoords(mAxisRect.left()-selAxisOutSize, mAxisRect.top(), mAxisRect.left()+selAxisInSize, mAxisRect.bottom());
<a name="l05347"></a>05347     mTickLabelsSelectionBox.setCoords(mAxisRect.left()-selTickLabelOffset-selTickLabelSize, mAxisRect.top(), mAxisRect.left()-selTickLabelOffset, mAxisRect.bottom());
<a name="l05348"></a>05348     mLabelSelectionBox.setCoords(mAxisRect.left()-selLabelOffset-selLabelSize, mAxisRect.top(), mAxisRect.left()-selLabelOffset, mAxisRect.bottom());
<a name="l05349"></a>05349   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atRight)
<a name="l05350"></a>05350   {
<a name="l05351"></a>05351     mAxisSelectionBox.setCoords(mAxisRect.right()-selAxisInSize, mAxisRect.top(), mAxisRect.right()+selAxisOutSize, mAxisRect.bottom());
<a name="l05352"></a>05352     mTickLabelsSelectionBox.setCoords(mAxisRect.right()+selTickLabelOffset+selTickLabelSize, mAxisRect.top(), mAxisRect.right()+selTickLabelOffset, mAxisRect.bottom());
<a name="l05353"></a>05353     mLabelSelectionBox.setCoords(mAxisRect.right()+selLabelOffset+selLabelSize, mAxisRect.top(), mAxisRect.right()+selLabelOffset, mAxisRect.bottom());
<a name="l05354"></a>05354   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atTop)
<a name="l05355"></a>05355   {
<a name="l05356"></a>05356     mAxisSelectionBox.setCoords(mAxisRect.left(), mAxisRect.top()-selAxisOutSize, mAxisRect.right(), mAxisRect.top()+selAxisInSize);
<a name="l05357"></a>05357     mTickLabelsSelectionBox.setCoords(mAxisRect.left(), mAxisRect.top()-selTickLabelOffset-selTickLabelSize, mAxisRect.right(), mAxisRect.top()-selTickLabelOffset);
<a name="l05358"></a>05358     mLabelSelectionBox.setCoords(mAxisRect.left(), mAxisRect.top()-selLabelOffset-selLabelSize, mAxisRect.right(), mAxisRect.top()-selLabelOffset);
<a name="l05359"></a>05359   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atBottom)
<a name="l05360"></a>05360   {
<a name="l05361"></a>05361     mAxisSelectionBox.setCoords(mAxisRect.left(), mAxisRect.bottom()-selAxisInSize, mAxisRect.right(), mAxisRect.bottom()+selAxisOutSize);
<a name="l05362"></a>05362     mTickLabelsSelectionBox.setCoords(mAxisRect.left(), mAxisRect.bottom()+selTickLabelOffset+selTickLabelSize, mAxisRect.right(), mAxisRect.bottom()+selTickLabelOffset);
<a name="l05363"></a>05363     mLabelSelectionBox.setCoords(mAxisRect.left(), mAxisRect.bottom()+selLabelOffset+selLabelSize, mAxisRect.right(), mAxisRect.bottom()+selLabelOffset);
<a name="l05364"></a>05364   }
<a name="l05365"></a>05365   <span class="comment">//painter-&gt;drawRects(QVector&lt;QRect&gt;() &lt;&lt; mAxisSelectionBox &lt;&lt; mTickLabelsSelectionBox &lt;&lt; mLabelSelectionBox);</span>
<a name="l05366"></a>05366 
<a name="l05367"></a>05367   painter-&gt;restore();
<a name="l05368"></a>05368 }
<a name="l05369"></a>05369 
<a name="l05391"></a>05391 <span class="keywordtype">void</span> QCPAxis::drawTickLabel(QPainter *painter, <span class="keywordtype">double</span> position, <span class="keywordtype">int</span> distanceToAxis, <span class="keyword">const</span> QString &amp;text, QSize *tickLabelsSize)
<a name="l05392"></a>05392 {
<a name="l05393"></a>05393   <span class="comment">// warning: if you change anything here, also adapt getMaxTickLabelSize() accordingly!</span>
<a name="l05394"></a>05394   
<a name="l05395"></a>05395   <span class="comment">// determine whether beautiful decimal powers should be used</span>
<a name="l05396"></a>05396   <span class="keywordtype">bool</span> useBeautifulPowers = <span class="keyword">false</span>;
<a name="l05397"></a>05397   <span class="keywordtype">int</span> ePos = -1;
<a name="l05398"></a>05398   <span class="keywordflow">if</span> (mAutoTickLabels &amp;&amp; mNumberBeautifulPowers &amp;&amp; mTickLabelType == ltNumber)
<a name="l05399"></a>05399   {
<a name="l05400"></a>05400     ePos = text.indexOf(<span class="charliteral">&#39;e&#39;</span>);
<a name="l05401"></a>05401     <span class="keywordflow">if</span> (ePos &gt; -1)
<a name="l05402"></a>05402       useBeautifulPowers = <span class="keyword">true</span>;
<a name="l05403"></a>05403   }
<a name="l05404"></a>05404   
<a name="l05405"></a>05405   <span class="comment">// calculate text bounding rects and do string preparation for beautiful decimal powers:</span>
<a name="l05406"></a>05406   QRect bounds, baseBounds, expBounds;
<a name="l05407"></a>05407   QString basePart, expPart;
<a name="l05408"></a>05408   QFont bugFixFont(painter-&gt;font());
<a name="l05409"></a>05409   bugFixFont.setPointSizeF(bugFixFont.pointSizeF()+0.05); <span class="comment">// QFontMetrics.boundingRect has a bug for exact point sizes that make the results oscillate due to internal rounding </span>
<a name="l05410"></a>05410   QFont expFont;
<a name="l05411"></a>05411   <span class="keywordflow">if</span> (useBeautifulPowers)
<a name="l05412"></a>05412   {
<a name="l05413"></a>05413     <span class="comment">// split string parts for part of number/symbol that will be drawn normally and part that will be drawn as exponent:</span>
<a name="l05414"></a>05414     basePart = text.left(ePos);
<a name="l05415"></a>05415     <span class="comment">// in log scaling, we want to turn &quot;1*10^n&quot; into &quot;10^n&quot;, else add multiplication sign and decimal base:</span>
<a name="l05416"></a>05416     <span class="keywordflow">if</span> (mScaleType == stLogarithmic &amp;&amp; basePart == <span class="stringliteral">&quot;1&quot;</span>)
<a name="l05417"></a>05417       basePart = <span class="stringliteral">&quot;10&quot;</span>;
<a name="l05418"></a>05418     <span class="keywordflow">else</span>
<a name="l05419"></a>05419       basePart += (mNumberMultiplyCross ? QString(QChar(215)) : QString(QChar(183))) + <span class="stringliteral">&quot;10&quot;</span>;
<a name="l05420"></a>05420     expPart = text.mid(ePos+1);
<a name="l05421"></a>05421     <span class="comment">// clip &quot;+&quot; and leading zeros off expPart:</span>
<a name="l05422"></a>05422     <span class="keywordflow">while</span> (expPart.at(1) == <span class="charliteral">&#39;0&#39;</span> &amp;&amp; expPart.length() &gt; 2) <span class="comment">// length &gt; 2 so we leave one zero when numberFormatChar is &#39;e&#39;</span>
<a name="l05423"></a>05423       expPart.remove(1, 1);
<a name="l05424"></a>05424     <span class="keywordflow">if</span> (expPart.at(0) == mPositiveSignChar)
<a name="l05425"></a>05425       expPart.remove(0, 1);
<a name="l05426"></a>05426     <span class="comment">// prepare smaller font for exponent:</span>
<a name="l05427"></a>05427     expFont = painter-&gt;font();
<a name="l05428"></a>05428     expFont.setPointSize(expFont.pointSize()*0.75);
<a name="l05429"></a>05429     <span class="comment">// calculate bounding rects of base part, exponent part and total one:</span>
<a name="l05430"></a>05430     QFontMetrics fontMetrics(bugFixFont);
<a name="l05431"></a>05431     baseBounds = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip, basePart);
<a name="l05432"></a>05432     QFontMetrics expFontMetrics(expFont);
<a name="l05433"></a>05433     expBounds = expFontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip, expPart);
<a name="l05434"></a>05434     bounds = baseBounds.adjusted(0, 0, expBounds.width(), 0);
<a name="l05435"></a>05435   } <span class="keywordflow">else</span> <span class="comment">// useBeautifulPowers == false</span>
<a name="l05436"></a>05436   {
<a name="l05437"></a>05437     QFontMetrics fontMetrics(bugFixFont);
<a name="l05438"></a>05438     bounds = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip | Qt::AlignHCenter, text);
<a name="l05439"></a>05439   }
<a name="l05440"></a>05440   
<a name="l05441"></a>05441   <span class="comment">// if using rotated tick labels, transform bounding rect, too:</span>
<a name="l05442"></a>05442   QRect rotatedBounds = bounds;
<a name="l05443"></a>05443   <span class="keywordflow">if</span> (!qFuzzyCompare(mTickLabelRotation+1.0, 1.0))
<a name="l05444"></a>05444   {
<a name="l05445"></a>05445     QTransform transform;
<a name="l05446"></a>05446     transform.rotate(mTickLabelRotation);
<a name="l05447"></a>05447     rotatedBounds = transform.mapRect(bounds);
<a name="l05448"></a>05448   }
<a name="l05449"></a>05449   <span class="comment">// expand passed tickLabelsSize if current tick label is larger:</span>
<a name="l05450"></a>05450   <span class="keywordflow">if</span> (rotatedBounds.width() &gt; tickLabelsSize-&gt;width()) 
<a name="l05451"></a>05451     tickLabelsSize-&gt;setWidth(rotatedBounds.width());
<a name="l05452"></a>05452   <span class="keywordflow">if</span> (rotatedBounds.height() &gt; tickLabelsSize-&gt;height())
<a name="l05453"></a>05453     tickLabelsSize-&gt;setHeight(rotatedBounds.height());
<a name="l05454"></a>05454   
<a name="l05455"></a>05455   <span class="comment">/*</span>
<a name="l05456"></a>05456 <span class="comment">    calculate coordinates (non-trivial, for best visual appearance): short explanation for bottom</span>
<a name="l05457"></a>05457 <span class="comment">    axis: The anchor, i.e. the point in the label that is placed horizontally under the</span>
<a name="l05458"></a>05458 <span class="comment">    corresponding tick is always on the label side that is closer to the axis (e.g. the left side</span>
<a name="l05459"></a>05459 <span class="comment">    of the text when we&#39;re rotating clockwise). On that side, the height-edge is halved and the</span>
<a name="l05460"></a>05460 <span class="comment">    resulting median point is defined the anchor. This way, a 90 degree rotated text will be</span>
<a name="l05461"></a>05461 <span class="comment">    centered under the tick (i.e. displaced horizontally by half its height). At the same time, a</span>
<a name="l05462"></a>05462 <span class="comment">    45 degree rotated text will &quot;point toward&quot; its tick, as is typical for rotated tick labels.</span>
<a name="l05463"></a>05463 <span class="comment">  */</span>
<a name="l05464"></a>05464   <span class="keywordtype">bool</span> doRotation = qAbs(mTickLabelRotation) &gt; 0.0001;
<a name="l05465"></a>05465   <span class="keywordtype">double</span> angle = mTickLabelRotation/180.0*M_PI;
<a name="l05466"></a>05466   <span class="keywordtype">int</span> x=0,y=0;
<a name="l05467"></a>05467   <span class="keywordflow">if</span> (mAxisType == atLeft)
<a name="l05468"></a>05468   {
<a name="l05469"></a>05469     <span class="keywordflow">if</span> (doRotation)
<a name="l05470"></a>05470     {
<a name="l05471"></a>05471       <span class="keywordflow">if</span> (mTickLabelRotation &gt; 0)
<a name="l05472"></a>05472       {
<a name="l05473"></a>05473         x = mAxisRect.left()-cos(angle)*bounds.width()-distanceToAxis;
<a name="l05474"></a>05474         y = position-sin(angle)*bounds.width()-cos(angle)*bounds.height()/2.0;
<a name="l05475"></a>05475       } <span class="keywordflow">else</span>
<a name="l05476"></a>05476       {
<a name="l05477"></a>05477         x = mAxisRect.left()-cos(-angle)*bounds.width()-sin(-angle)*bounds.height()-distanceToAxis;
<a name="l05478"></a>05478         y = position+sin(-angle)*bounds.width()-cos(-angle)*bounds.height()/2.0;
<a name="l05479"></a>05479       }
<a name="l05480"></a>05480     } <span class="keywordflow">else</span>
<a name="l05481"></a>05481     {
<a name="l05482"></a>05482       x = mAxisRect.left()-bounds.width()-distanceToAxis;
<a name="l05483"></a>05483       y = position-bounds.height()/2.0;
<a name="l05484"></a>05484     }
<a name="l05485"></a>05485   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atRight)
<a name="l05486"></a>05486   {
<a name="l05487"></a>05487     <span class="keywordflow">if</span> (doRotation)
<a name="l05488"></a>05488     {
<a name="l05489"></a>05489       <span class="keywordflow">if</span> (mTickLabelRotation &gt; 0)
<a name="l05490"></a>05490       {
<a name="l05491"></a>05491         x = mAxisRect.right()+sin(angle)*bounds.height()+distanceToAxis;
<a name="l05492"></a>05492         y = position-cos(angle)*bounds.height()/2.0;
<a name="l05493"></a>05493       } <span class="keywordflow">else</span>
<a name="l05494"></a>05494       {
<a name="l05495"></a>05495         x = mAxisRect.right()+distanceToAxis;
<a name="l05496"></a>05496         y = position-cos(-angle)*bounds.height()/2.0;
<a name="l05497"></a>05497       }
<a name="l05498"></a>05498     } <span class="keywordflow">else</span>
<a name="l05499"></a>05499     {
<a name="l05500"></a>05500       x = mAxisRect.right()+distanceToAxis;
<a name="l05501"></a>05501       y = position-bounds.height()/2.0;
<a name="l05502"></a>05502     }
<a name="l05503"></a>05503   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atTop)
<a name="l05504"></a>05504   {
<a name="l05505"></a>05505     <span class="keywordflow">if</span> (doRotation)
<a name="l05506"></a>05506     {
<a name="l05507"></a>05507       <span class="keywordflow">if</span> (mTickLabelRotation &gt; 0)
<a name="l05508"></a>05508       {
<a name="l05509"></a>05509         x = position-cos(angle)*bounds.width()+sin(angle)*bounds.height()/2.0;
<a name="l05510"></a>05510         y = mAxisRect.top()-sin(angle)*bounds.width()-cos(angle)*bounds.height()-distanceToAxis;
<a name="l05511"></a>05511       } <span class="keywordflow">else</span>
<a name="l05512"></a>05512       {
<a name="l05513"></a>05513         x = position-sin(-angle)*bounds.height()/2.0;
<a name="l05514"></a>05514         y = mAxisRect.top()-cos(-angle)*bounds.height()-distanceToAxis;
<a name="l05515"></a>05515       }
<a name="l05516"></a>05516     } <span class="keywordflow">else</span>
<a name="l05517"></a>05517     {
<a name="l05518"></a>05518       x = position-bounds.width()/2.0;
<a name="l05519"></a>05519       y = mAxisRect.top()-bounds.height()-distanceToAxis;
<a name="l05520"></a>05520     }
<a name="l05521"></a>05521   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAxisType == atBottom)
<a name="l05522"></a>05522   {
<a name="l05523"></a>05523     <span class="keywordflow">if</span> (doRotation)
<a name="l05524"></a>05524     {
<a name="l05525"></a>05525       <span class="keywordflow">if</span> (mTickLabelRotation &gt; 0)
<a name="l05526"></a>05526       {
<a name="l05527"></a>05527         x = position+sin(angle)*bounds.height()/2.0;
<a name="l05528"></a>05528         y = mAxisRect.bottom()+distanceToAxis;
<a name="l05529"></a>05529       } <span class="keywordflow">else</span>
<a name="l05530"></a>05530       {
<a name="l05531"></a>05531         x = position-cos(-angle)*bounds.width()-sin(-angle)*bounds.height()/2.0;
<a name="l05532"></a>05532         y = mAxisRect.bottom()+sin(-angle)*bounds.width()+distanceToAxis;
<a name="l05533"></a>05533       }
<a name="l05534"></a>05534     } <span class="keywordflow">else</span>
<a name="l05535"></a>05535     {
<a name="l05536"></a>05536       x = position-bounds.width()/2.0;
<a name="l05537"></a>05537       y = mAxisRect.bottom()+distanceToAxis;
<a name="l05538"></a>05538     }
<a name="l05539"></a>05539   }
<a name="l05540"></a>05540   
<a name="l05541"></a>05541   <span class="comment">// if label would be partly clipped by widget border on sides, don&#39;t draw it:</span>
<a name="l05542"></a>05542   <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l05543"></a>05543   {
<a name="l05544"></a>05544     <span class="keywordflow">if</span> (x+bounds.width() &gt; mParentPlot-&gt;mViewport.right() ||
<a name="l05545"></a>05545         x &lt; mParentPlot-&gt;mViewport.left())
<a name="l05546"></a>05546       <span class="keywordflow">return</span>;
<a name="l05547"></a>05547   } <span class="keywordflow">else</span>
<a name="l05548"></a>05548   {
<a name="l05549"></a>05549     <span class="keywordflow">if</span> (y+bounds.height() &gt; mParentPlot-&gt;mViewport.bottom() ||
<a name="l05550"></a>05550         y &lt; mParentPlot-&gt;mViewport.top())
<a name="l05551"></a>05551       <span class="keywordflow">return</span>;
<a name="l05552"></a>05552   }
<a name="l05553"></a>05553   
<a name="l05554"></a>05554   <span class="comment">// transform painter to position/rotation:</span>
<a name="l05555"></a>05555   QTransform oldTransform = painter-&gt;transform();
<a name="l05556"></a>05556   painter-&gt;translate(x, y);
<a name="l05557"></a>05557   <span class="keywordflow">if</span> (doRotation)
<a name="l05558"></a>05558     painter-&gt;rotate(mTickLabelRotation);
<a name="l05559"></a>05559   <span class="comment">// draw text:</span>
<a name="l05560"></a>05560   <span class="keywordflow">if</span> (useBeautifulPowers)
<a name="l05561"></a>05561   {
<a name="l05562"></a>05562     <span class="comment">// draw base:</span>
<a name="l05563"></a>05563     painter-&gt;drawText(0, 0, 0, 0, Qt::TextDontClip, basePart);
<a name="l05564"></a>05564     <span class="comment">// draw exponent:</span>
<a name="l05565"></a>05565     QFont normalFont = painter-&gt;font();
<a name="l05566"></a>05566     painter-&gt;setFont(expFont);
<a name="l05567"></a>05567     painter-&gt;drawText(baseBounds.width()+1, 0, expBounds.width(), expBounds.height(), Qt::TextDontClip,  expPart);
<a name="l05568"></a>05568     painter-&gt;setFont(normalFont);
<a name="l05569"></a>05569   } <span class="keywordflow">else</span> <span class="comment">// useBeautifulPowers == false</span>
<a name="l05570"></a>05570   {
<a name="l05571"></a>05571     painter-&gt;drawText(0, 0, bounds.width(), bounds.height(), Qt::TextDontClip | Qt::AlignHCenter, text);
<a name="l05572"></a>05572   }
<a name="l05573"></a>05573   
<a name="l05574"></a>05574   <span class="comment">// reset rotation/translation transform to what it was before:</span>
<a name="l05575"></a>05575   painter-&gt;setTransform(oldTransform);
<a name="l05576"></a>05576 }
<a name="l05577"></a>05577 
<a name="l05585"></a>05585 <span class="keywordtype">void</span> QCPAxis::getMaxTickLabelSize(<span class="keyword">const</span> QFont &amp;font, <span class="keyword">const</span> QString &amp;text,  QSize *tickLabelsSize)<span class="keyword"> const</span>
<a name="l05586"></a>05586 <span class="keyword"></span>{
<a name="l05587"></a>05587   <span class="comment">// This function does the same as drawTickLabel but omits the actual drawing</span>
<a name="l05588"></a>05588   <span class="comment">// changes involve creating extra QFontMetrics instances for font, since painter-&gt;fontMetrics() isn&#39;t available</span>
<a name="l05589"></a>05589   
<a name="l05590"></a>05590   <span class="comment">// determine whether beautiful powers should be used</span>
<a name="l05591"></a>05591   <span class="keywordtype">bool</span> useBeautifulPowers = <span class="keyword">false</span>;
<a name="l05592"></a>05592   <span class="keywordtype">int</span> ePos=-1;
<a name="l05593"></a>05593   <span class="keywordflow">if</span> (mAutoTickLabels &amp;&amp; mNumberBeautifulPowers &amp;&amp; mTickLabelType == ltNumber)
<a name="l05594"></a>05594   {
<a name="l05595"></a>05595     ePos = text.indexOf(mExponentialChar);
<a name="l05596"></a>05596     <span class="keywordflow">if</span> (ePos &gt; -1)
<a name="l05597"></a>05597       useBeautifulPowers = <span class="keyword">true</span>;
<a name="l05598"></a>05598   }
<a name="l05599"></a>05599   
<a name="l05600"></a>05600   <span class="comment">// calculate and draw text, depending on whether beautiful powers are applicable or not:</span>
<a name="l05601"></a>05601   QRect bounds, baseBounds, expBounds;
<a name="l05602"></a>05602   QString basePart, expPart;
<a name="l05603"></a>05603   QFont bugFixFont(font);
<a name="l05604"></a>05604   bugFixFont.setPointSizeF(bugFixFont.pointSizeF()+0.05); <span class="comment">// QFontMetrics.boundingRect has a bug for exact point sizes that make the results oscillate due to internal rounding </span>
<a name="l05605"></a>05605   QFont expFont;
<a name="l05606"></a>05606   <span class="keywordflow">if</span> (useBeautifulPowers)
<a name="l05607"></a>05607   {
<a name="l05608"></a>05608     <span class="comment">// split string parts for part of number/symbol that will be drawn normally and part that will be drawn as exponent:</span>
<a name="l05609"></a>05609     basePart = text.left(ePos);
<a name="l05610"></a>05610     <span class="comment">// in log scaling, we want to turn &quot;1*10^n&quot; into &quot;10^n&quot;, else add multiplication sign and decimal base:</span>
<a name="l05611"></a>05611     <span class="keywordflow">if</span> (mScaleType == stLogarithmic &amp;&amp; basePart == <span class="stringliteral">&quot;1&quot;</span>)
<a name="l05612"></a>05612       basePart = <span class="stringliteral">&quot;10&quot;</span>;
<a name="l05613"></a>05613     <span class="keywordflow">else</span>
<a name="l05614"></a>05614       basePart += (mNumberMultiplyCross ? QString(QChar(215)) : QString(QChar(183))) + <span class="stringliteral">&quot;10&quot;</span>;
<a name="l05615"></a>05615     expPart = text.mid(ePos+1);
<a name="l05616"></a>05616     <span class="comment">// clip &quot;+&quot; and leading zeros off expPart:</span>
<a name="l05617"></a>05617     <span class="keywordflow">while</span> (expPart.at(1) == <span class="charliteral">&#39;0&#39;</span> &amp;&amp; expPart.length() &gt; 2) <span class="comment">// length &gt; 2 so we leave one zero when numberFormatChar is &#39;e&#39;</span>
<a name="l05618"></a>05618       expPart.remove(1, 1);
<a name="l05619"></a>05619     <span class="keywordflow">if</span> (expPart.at(0) == mPositiveSignChar)
<a name="l05620"></a>05620       expPart.remove(0, 1);
<a name="l05621"></a>05621     <span class="comment">// prepare smaller font for exponent:</span>
<a name="l05622"></a>05622     expFont = font;
<a name="l05623"></a>05623     expFont.setPointSize(expFont.pointSize()*0.75);
<a name="l05624"></a>05624     <span class="comment">// calculate bounding rects of base part, exponent part and total one:</span>
<a name="l05625"></a>05625     QFontMetrics baseFontMetrics(bugFixFont);
<a name="l05626"></a>05626     baseBounds = baseFontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip, basePart);
<a name="l05627"></a>05627     QFontMetrics expFontMetrics(expFont);
<a name="l05628"></a>05628     expBounds = expFontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip, expPart);
<a name="l05629"></a>05629     bounds = baseBounds.adjusted(0, 0, expBounds.width(), 0); 
<a name="l05630"></a>05630   } <span class="keywordflow">else</span> <span class="comment">// useBeautifulPowers == false</span>
<a name="l05631"></a>05631   {
<a name="l05632"></a>05632     QFontMetrics fontMetrics(bugFixFont);
<a name="l05633"></a>05633     bounds = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip | Qt::AlignHCenter, text);
<a name="l05634"></a>05634   }
<a name="l05635"></a>05635   
<a name="l05636"></a>05636   <span class="comment">// if rotated tick labels, transform bounding rect, too:</span>
<a name="l05637"></a>05637   QRect rotatedBounds = bounds;
<a name="l05638"></a>05638   <span class="keywordflow">if</span> (!qFuzzyCompare(mTickLabelRotation+1.0, 1.0))
<a name="l05639"></a>05639   {
<a name="l05640"></a>05640     QTransform transform;
<a name="l05641"></a>05641     transform.rotate(mTickLabelRotation);
<a name="l05642"></a>05642     rotatedBounds = transform.mapRect(bounds);
<a name="l05643"></a>05643   }
<a name="l05644"></a>05644   
<a name="l05645"></a>05645   <span class="comment">// expand passed tickLabelsSize if current tick label is larger:</span>
<a name="l05646"></a>05646   <span class="keywordflow">if</span> (rotatedBounds.width() &gt; tickLabelsSize-&gt;width()) 
<a name="l05647"></a>05647     tickLabelsSize-&gt;setWidth(rotatedBounds.width());
<a name="l05648"></a>05648   <span class="keywordflow">if</span> (rotatedBounds.height() &gt; tickLabelsSize-&gt;height())
<a name="l05649"></a>05649     tickLabelsSize-&gt;setHeight(rotatedBounds.height());
<a name="l05650"></a>05650 }
<a name="l05651"></a>05651 
<a name="l05665"></a>05665 <span class="keywordtype">bool</span> QCPAxis::handleAxisSelection(QMouseEvent *event, <span class="keywordtype">bool</span> additiveSelection, <span class="keywordtype">bool</span> &amp;modified)
<a name="l05666"></a>05666 {
<a name="l05667"></a>05667   <span class="keywordtype">bool</span> selectionFound = <span class="keyword">false</span>;
<a name="l05668"></a>05668   <span class="keywordflow">if</span> (event)
<a name="l05669"></a>05669   {
<a name="l05670"></a>05670     SelectablePart selectedAxisPart = selectTest(event-&gt;pos());
<a name="l05671"></a>05671     <span class="keywordflow">if</span> (selectedAxisPart == spNone || !selectable().testFlag(selectedAxisPart))
<a name="l05672"></a>05672     {
<a name="l05673"></a>05673       <span class="comment">// deselect parts that are changeable (selectable):</span>
<a name="l05674"></a>05674       SelectableParts newState = selected() &amp; ~selectable();
<a name="l05675"></a>05675       <span class="keywordflow">if</span> (newState != selected() &amp;&amp; !additiveSelection)
<a name="l05676"></a>05676       {
<a name="l05677"></a>05677         modified = <span class="keyword">true</span>;
<a name="l05678"></a>05678         setSelected(newState);
<a name="l05679"></a>05679       }
<a name="l05680"></a>05680     } <span class="keywordflow">else</span>
<a name="l05681"></a>05681     {
<a name="l05682"></a>05682       selectionFound = <span class="keyword">true</span>;
<a name="l05683"></a>05683       <span class="keywordflow">if</span> (additiveSelection)
<a name="l05684"></a>05684       {
<a name="l05685"></a>05685         <span class="comment">// additive selection, so toggle selected part:</span>
<a name="l05686"></a>05686         setSelected(selected() ^ selectedAxisPart);
<a name="l05687"></a>05687         modified = <span class="keyword">true</span>;
<a name="l05688"></a>05688       } <span class="keywordflow">else</span>
<a name="l05689"></a>05689       {
<a name="l05690"></a>05690         <span class="comment">// not additive selection, so select part and deselect all others that are changeable (selectable):</span>
<a name="l05691"></a>05691         SelectableParts newState = (selected() &amp; ~selectable()) | selectedAxisPart;
<a name="l05692"></a>05692         <span class="keywordflow">if</span> (newState != selected())
<a name="l05693"></a>05693         {
<a name="l05694"></a>05694           modified = <span class="keyword">true</span>;
<a name="l05695"></a>05695           setSelected(newState);
<a name="l05696"></a>05696         }
<a name="l05697"></a>05697       }
<a name="l05698"></a>05698     }
<a name="l05699"></a>05699   } <span class="keywordflow">else</span> <span class="comment">// event == 0, so deselect all changeable parts</span>
<a name="l05700"></a>05700   {
<a name="l05701"></a>05701     SelectableParts newState = selected() &amp; ~selectable();
<a name="l05702"></a>05702     <span class="keywordflow">if</span> (newState != selected())
<a name="l05703"></a>05703     {
<a name="l05704"></a>05704       modified = <span class="keyword">true</span>;
<a name="l05705"></a>05705       setSelected(newState);
<a name="l05706"></a>05706     }
<a name="l05707"></a>05707   }
<a name="l05708"></a>05708   <span class="keywordflow">return</span> selectionFound;
<a name="l05709"></a>05709 }
<a name="l05710"></a>05710 
<a name="l05721"></a>05721 <span class="keywordtype">void</span> QCPAxis::visibleTickBounds(<span class="keywordtype">int</span> &amp;lowIndex, <span class="keywordtype">int</span> &amp;highIndex)<span class="keyword"> const</span>
<a name="l05722"></a>05722 <span class="keyword"></span>{
<a name="l05723"></a>05723   lowIndex = 0;
<a name="l05724"></a>05724   highIndex = -1;
<a name="l05725"></a>05725   <span class="comment">// make sure only ticks that are in visible range are returned</span>
<a name="l05726"></a>05726   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; mTickVector-&gt;size(); ++i)
<a name="l05727"></a>05727   {
<a name="l05728"></a>05728     lowIndex = i;
<a name="l05729"></a>05729     <span class="keywordflow">if</span> (mTickVector-&gt;at(i) &gt;= mRange.lower) <span class="keywordflow">break</span>;
<a name="l05730"></a>05730   }
<a name="l05731"></a>05731   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=mTickVector-&gt;size()-1; i &gt;= 0; --i)
<a name="l05732"></a>05732   {
<a name="l05733"></a>05733     highIndex = i;
<a name="l05734"></a>05734     <span class="keywordflow">if</span> (mTickVector-&gt;at(i) &lt;= mRange.upper) <span class="keywordflow">break</span>;
<a name="l05735"></a>05735   }
<a name="l05736"></a>05736 }
<a name="l05737"></a>05737 
<a name="l05746"></a>05746 <span class="keywordtype">double</span> QCPAxis::baseLog(<span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l05747"></a>05747 <span class="keyword"></span>{
<a name="l05748"></a>05748   <span class="keywordflow">return</span> log(value)*mScaleLogBaseLogInv;
<a name="l05749"></a>05749 }
<a name="l05750"></a>05750 
<a name="l05758"></a>05758 <span class="keywordtype">double</span> QCPAxis::basePow(<span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l05759"></a>05759 <span class="keyword"></span>{
<a name="l05760"></a>05760   <span class="keywordflow">return</span> pow(mScaleLogBase, value);
<a name="l05761"></a>05761 }
<a name="l05762"></a>05762 
<a name="l05768"></a>05768 QPen QCPAxis::getBasePen()<span class="keyword"> const</span>
<a name="l05769"></a>05769 <span class="keyword"></span>{
<a name="l05770"></a>05770   <span class="keywordflow">return</span> mSelected.testFlag(spAxis) ? mSelectedBasePen : mBasePen;
<a name="l05771"></a>05771 }
<a name="l05772"></a>05772 
<a name="l05778"></a>05778 QPen QCPAxis::getTickPen()<span class="keyword"> const</span>
<a name="l05779"></a>05779 <span class="keyword"></span>{
<a name="l05780"></a>05780   <span class="keywordflow">return</span> mSelected.testFlag(spAxis) ? mSelectedTickPen : mTickPen;
<a name="l05781"></a>05781 }
<a name="l05782"></a>05782 
<a name="l05788"></a>05788 QPen QCPAxis::getSubTickPen()<span class="keyword"> const</span>
<a name="l05789"></a>05789 <span class="keyword"></span>{
<a name="l05790"></a>05790   <span class="keywordflow">return</span> mSelected.testFlag(spAxis) ? mSelectedSubTickPen : mSubTickPen;
<a name="l05791"></a>05791 }
<a name="l05792"></a>05792 
<a name="l05798"></a>05798 QFont QCPAxis::getTickLabelFont()<span class="keyword"> const</span>
<a name="l05799"></a>05799 <span class="keyword"></span>{
<a name="l05800"></a>05800   <span class="keywordflow">return</span> mSelected.testFlag(spTickLabels) ? mSelectedTickLabelFont : mTickLabelFont;
<a name="l05801"></a>05801 }
<a name="l05802"></a>05802 
<a name="l05808"></a>05808 QFont QCPAxis::getLabelFont()<span class="keyword"> const</span>
<a name="l05809"></a>05809 <span class="keyword"></span>{
<a name="l05810"></a>05810   <span class="keywordflow">return</span> mSelected.testFlag(spAxisLabel) ? mSelectedLabelFont : mLabelFont;
<a name="l05811"></a>05811 }
<a name="l05812"></a>05812 
<a name="l05818"></a>05818 QColor QCPAxis::getTickLabelColor()<span class="keyword"> const</span>
<a name="l05819"></a>05819 <span class="keyword"></span>{
<a name="l05820"></a>05820   <span class="keywordflow">return</span> mSelected.testFlag(spTickLabels) ? mSelectedTickLabelColor : mTickLabelColor;
<a name="l05821"></a>05821 }
<a name="l05822"></a>05822 
<a name="l05828"></a>05828 QColor QCPAxis::getLabelColor()<span class="keyword"> const</span>
<a name="l05829"></a>05829 <span class="keyword"></span>{
<a name="l05830"></a>05830   <span class="keywordflow">return</span> mSelected.testFlag(spAxisLabel) ? mSelectedLabelColor : mLabelColor;
<a name="l05831"></a>05831 }
<a name="l05832"></a>05832 
<a name="l05846"></a>05846 <span class="keywordtype">int</span> QCPAxis::calculateMargin()<span class="keyword"> const</span>
<a name="l05847"></a>05847 <span class="keyword"></span>{
<a name="l05848"></a>05848   <span class="comment">// run through similar steps as QCPAxis::drawAxis, and caluclate margin needed to fit axis and its labels</span>
<a name="l05849"></a>05849   <span class="keywordtype">int</span> margin = 0;
<a name="l05850"></a>05850   
<a name="l05851"></a>05851   <span class="keywordflow">if</span> (mVisible)
<a name="l05852"></a>05852   {
<a name="l05853"></a>05853     <span class="keywordtype">int</span> lowTick, highTick;
<a name="l05854"></a>05854     visibleTickBounds(lowTick, highTick);
<a name="l05855"></a>05855     <span class="comment">// get length of tick marks reaching outside axis rect:</span>
<a name="l05856"></a>05856     margin += qMax(0, qMax(mTickLengthOut, mSubTickLengthOut));
<a name="l05857"></a>05857     <span class="comment">// calculate size of tick labels:</span>
<a name="l05858"></a>05858     QSize tickLabelsSize(0, 0);
<a name="l05859"></a>05859     <span class="keywordflow">if</span> (mTickLabels)
<a name="l05860"></a>05860     {
<a name="l05861"></a>05861       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lowTick; i &lt;= highTick; ++i)
<a name="l05862"></a>05862       {
<a name="l05863"></a>05863         getMaxTickLabelSize(mTickLabelFont, mTickVectorLabels-&gt;at(i), &amp;tickLabelsSize); <span class="comment">// don&#39;t use getTickLabelFont() because we don&#39;t want margin to possibly change on selection</span>
<a name="l05864"></a>05864       }
<a name="l05865"></a>05865       <span class="keywordflow">if</span> (orientation() == Qt::Horizontal)
<a name="l05866"></a>05866         margin += tickLabelsSize.height() + mTickLabelPadding;
<a name="l05867"></a>05867       <span class="keywordflow">else</span>
<a name="l05868"></a>05868         margin += tickLabelsSize.width() + mTickLabelPadding;
<a name="l05869"></a>05869     }
<a name="l05870"></a>05870     <span class="comment">// calculate size of axis label (only height needed, because left/right labels are rotated by 90 degrees):</span>
<a name="l05871"></a>05871     <span class="keywordflow">if</span> (!mLabel.isEmpty())
<a name="l05872"></a>05872     {
<a name="l05873"></a>05873       QFontMetrics fontMetrics(mLabelFont); <span class="comment">// don&#39;t use getLabelFont() because we don&#39;t want margin to possibly change on selection</span>
<a name="l05874"></a>05874       QRect bounds;
<a name="l05875"></a>05875       bounds = fontMetrics.boundingRect(0, 0, 0, 0, Qt::TextDontClip | Qt::AlignHCenter | Qt::AlignVCenter, mLabel);
<a name="l05876"></a>05876       margin += bounds.height() + mLabelPadding;
<a name="l05877"></a>05877     }
<a name="l05878"></a>05878   }
<a name="l05879"></a>05879   margin += mPadding;
<a name="l05880"></a>05880   
<a name="l05881"></a>05881   <span class="keywordflow">if</span> (margin &lt; 15) <span class="comment">// need a bit of margin if no axis text is shown at all (i.e. only baseline and tick lines, or no axis at all)</span>
<a name="l05882"></a>05882     margin = 15;
<a name="l05883"></a>05883   <span class="keywordflow">return</span> margin;
<a name="l05884"></a>05884 }
<a name="l05885"></a>05885 
<a name="l05886"></a>05886 
<a name="l05887"></a>05887 <span class="comment">// ================================================================================</span>
<a name="l05888"></a>05888 <span class="comment">// =================== QCustomPlot</span>
<a name="l05889"></a>05889 <span class="comment">// ================================================================================</span>
<a name="l05890"></a>05890 
<a name="l05898"></a>05898 <span class="comment">/* start of documentation of signals */</span>
<a name="l05899"></a>05899 
<a name="l06059"></a>06059 <span class="comment">/* end of documentation of signals */</span>
<a name="l06060"></a>06060 
<a name="l06067"></a>06067 QCustomPlot::QCustomPlot(QWidget *parent) :
<a name="l06068"></a>06068   QWidget(parent)
<a name="l06069"></a>06069 {  
<a name="l06070"></a>06070   setMouseTracking(<span class="keyword">true</span>);
<a name="l06071"></a>06071   QLocale currentLocale = locale();
<a name="l06072"></a>06072   currentLocale.setNumberOptions(QLocale::OmitGroupSeparator);
<a name="l06073"></a>06073   setLocale(currentLocale);
<a name="l06074"></a>06074 
<a name="l06075"></a>06075   mReplotting = <span class="keyword">false</span>;
<a name="l06076"></a>06076   buffer = QPixmap(size());
<a name="l06077"></a>06077   legend = <span class="keyword">new</span> QCPLegend(<span class="keyword">this</span>);
<a name="l06078"></a>06078   legend-&gt;setVisible(<span class="keyword">false</span>);
<a name="l06079"></a>06079   xAxis = <span class="keyword">new</span> QCPAxis(<span class="keyword">this</span>, QCPAxis::atBottom);
<a name="l06080"></a>06080   yAxis = <span class="keyword">new</span> QCPAxis(<span class="keyword">this</span>, QCPAxis::atLeft);
<a name="l06081"></a>06081   xAxis2 = <span class="keyword">new</span> QCPAxis(<span class="keyword">this</span>, QCPAxis::atTop);
<a name="l06082"></a>06082   yAxis2 = <span class="keyword">new</span> QCPAxis(<span class="keyword">this</span>, QCPAxis::atRight);
<a name="l06083"></a>06083   xAxis2-&gt;setGrid(<span class="keyword">false</span>);
<a name="l06084"></a>06084   yAxis2-&gt;setGrid(<span class="keyword">false</span>);
<a name="l06085"></a>06085   xAxis2-&gt;setZeroLinePen(Qt::NoPen);
<a name="l06086"></a>06086   yAxis2-&gt;setZeroLinePen(Qt::NoPen);
<a name="l06087"></a>06087   xAxis2-&gt;setVisible(<span class="keyword">false</span>);
<a name="l06088"></a>06088   yAxis2-&gt;setVisible(<span class="keyword">false</span>);
<a name="l06089"></a>06089   mViewport = rect();
<a name="l06090"></a>06090   mDragging = <span class="keyword">false</span>;
<a name="l06091"></a>06091   
<a name="l06092"></a>06092   setAutoAddPlottableToLegend(<span class="keyword">true</span>);
<a name="l06093"></a>06093   setAntialiasedElements(aePlottables | aeScatters | aeFills);
<a name="l06094"></a>06094   setAxisBackground(QPixmap());
<a name="l06095"></a>06095   setAxisBackgroundScaled(<span class="keyword">true</span>);
<a name="l06096"></a>06096   setAxisBackgroundScaledMode(Qt::KeepAspectRatioByExpanding);
<a name="l06097"></a>06097   QFont tFont;
<a name="l06098"></a>06098   tFont.setPointSize(14);
<a name="l06099"></a>06099   tFont.setBold(<span class="keyword">true</span>);
<a name="l06100"></a>06100   setTitleFont(tFont);
<a name="l06101"></a>06101   setTitleColor(Qt::black);
<a name="l06102"></a>06102   tFont.setPointSizeF(14.25);
<a name="l06103"></a>06103   setSelectedTitleFont(tFont);
<a name="l06104"></a>06104   setSelectedTitleColor(Qt::blue);
<a name="l06105"></a>06105   setTitle(<span class="stringliteral">&quot;&quot;</span>);
<a name="l06106"></a>06106   setColor(Qt::white);
<a name="l06107"></a>06107   
<a name="l06108"></a>06108   setInteractions(iRangeDrag | iRangeZoom);
<a name="l06109"></a>06109   setRangeDragAxes(xAxis, yAxis);
<a name="l06110"></a>06110   setRangeZoomAxes(xAxis, yAxis);
<a name="l06111"></a>06111   setRangeDrag(0);
<a name="l06112"></a>06112   setRangeZoom(0);
<a name="l06113"></a>06113   setRangeZoomFactor(0.85);
<a name="l06114"></a>06114   setSelectionTolerance(8);
<a name="l06115"></a>06115   
<a name="l06116"></a>06116   setMargin(0, 0, 0, 0);
<a name="l06117"></a>06117   setAutoMargin(<span class="keyword">true</span>);
<a name="l06118"></a>06118   replot();
<a name="l06119"></a>06119 }
<a name="l06120"></a>06120 
<a name="l06121"></a>06121 QCustomPlot::~QCustomPlot()
<a name="l06122"></a>06122 {
<a name="l06123"></a>06123   clearPlottables();
<a name="l06124"></a>06124   <span class="keyword">delete</span> legend;
<a name="l06125"></a>06125   <span class="keyword">delete</span> xAxis;
<a name="l06126"></a>06126   <span class="keyword">delete</span> yAxis;
<a name="l06127"></a>06127   <span class="keyword">delete</span> xAxis2;
<a name="l06128"></a>06128   <span class="keyword">delete</span> yAxis2;
<a name="l06129"></a>06129 }
<a name="l06130"></a>06130 
<a name="l06135"></a>06135 QCPAxis *QCustomPlot::rangeDragAxis(Qt::Orientation orientation)
<a name="l06136"></a>06136 {
<a name="l06137"></a>06137   <span class="keywordflow">return</span> (orientation == Qt::Horizontal ? mRangeDragHorzAxis : mRangeDragVertAxis);
<a name="l06138"></a>06138 }
<a name="l06139"></a>06139 
<a name="l06144"></a>06144 QCPAxis *QCustomPlot::rangeZoomAxis(Qt::Orientation orientation)
<a name="l06145"></a>06145 {
<a name="l06146"></a>06146   <span class="keywordflow">return</span> (orientation == Qt::Horizontal ? mRangeZoomHorzAxis : mRangeZoomVertAxis);
<a name="l06147"></a>06147 }
<a name="l06148"></a>06148 
<a name="l06153"></a>06153 <span class="keywordtype">double</span> QCustomPlot::rangeZoomFactor(Qt::Orientation orientation)
<a name="l06154"></a>06154 {
<a name="l06155"></a>06155   <span class="keywordflow">return</span> (orientation == Qt::Horizontal ? mRangeZoomFactorHorz : mRangeZoomFactorVert);
<a name="l06156"></a>06156 }
<a name="l06157"></a>06157 
<a name="l06166"></a>06166 <span class="keywordtype">void</span> QCustomPlot::setTitle(<span class="keyword">const</span> QString &amp;title)
<a name="l06167"></a>06167 {
<a name="l06168"></a>06168   mTitle = title;
<a name="l06169"></a>06169 }
<a name="l06170"></a>06170 
<a name="l06175"></a>06175 <span class="keywordtype">void</span> QCustomPlot::setTitleFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l06176"></a>06176 {
<a name="l06177"></a>06177   mTitleFont = font;
<a name="l06178"></a>06178 }
<a name="l06179"></a>06179 
<a name="l06184"></a>06184 <span class="keywordtype">void</span> QCustomPlot::setTitleColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l06185"></a>06185 {
<a name="l06186"></a>06186   mTitleColor = color;
<a name="l06187"></a>06187 }
<a name="l06188"></a>06188 
<a name="l06199"></a>06199 <span class="keywordtype">void</span> QCustomPlot::setAxisRect(<span class="keyword">const</span> QRect &amp;arect)
<a name="l06200"></a>06200 {
<a name="l06201"></a>06201   mMarginLeft = arect.left()-mViewport.left();
<a name="l06202"></a>06202   mMarginRight = mViewport.right()-arect.right();
<a name="l06203"></a>06203   mMarginTop = arect.top()-mViewport.top();
<a name="l06204"></a>06204   mMarginBottom = mViewport.bottom()-arect.bottom();
<a name="l06205"></a>06205   updateAxisRect();
<a name="l06206"></a>06206 }
<a name="l06207"></a>06207 
<a name="l06212"></a>06212 <span class="keywordtype">void</span> QCustomPlot::setMarginLeft(<span class="keywordtype">int</span> margin)
<a name="l06213"></a>06213 {
<a name="l06214"></a>06214   mMarginLeft = margin;
<a name="l06215"></a>06215   updateAxisRect();
<a name="l06216"></a>06216 }
<a name="l06217"></a>06217 
<a name="l06222"></a>06222 <span class="keywordtype">void</span> QCustomPlot::setMarginRight(<span class="keywordtype">int</span> margin)
<a name="l06223"></a>06223 {
<a name="l06224"></a>06224   mMarginRight = margin;
<a name="l06225"></a>06225   updateAxisRect();
<a name="l06226"></a>06226 }
<a name="l06227"></a>06227 
<a name="l06232"></a>06232 <span class="keywordtype">void</span> QCustomPlot::setMarginTop(<span class="keywordtype">int</span> margin)
<a name="l06233"></a>06233 {
<a name="l06234"></a>06234   mMarginTop = margin;
<a name="l06235"></a>06235   updateAxisRect();
<a name="l06236"></a>06236 }
<a name="l06237"></a>06237 
<a name="l06242"></a>06242 <span class="keywordtype">void</span> QCustomPlot::setMarginBottom(<span class="keywordtype">int</span> margin)
<a name="l06243"></a>06243 {
<a name="l06244"></a>06244   mMarginBottom = margin;
<a name="l06245"></a>06245   updateAxisRect();
<a name="l06246"></a>06246 }
<a name="l06247"></a>06247 
<a name="l06255"></a>06255 <span class="keywordtype">void</span> QCustomPlot::setMargin(<span class="keywordtype">int</span> left, <span class="keywordtype">int</span> right, <span class="keywordtype">int</span> top, <span class="keywordtype">int</span> bottom)
<a name="l06256"></a>06256 {
<a name="l06257"></a>06257   mMarginLeft = left;
<a name="l06258"></a>06258   mMarginRight = right;
<a name="l06259"></a>06259   mMarginTop = top;
<a name="l06260"></a>06260   mMarginBottom = bottom;
<a name="l06261"></a>06261   updateAxisRect();
<a name="l06262"></a>06262 }
<a name="l06263"></a>06263 
<a name="l06270"></a>06270 <span class="keywordtype">void</span> QCustomPlot::setAutoMargin(<span class="keywordtype">bool</span> enabled)
<a name="l06271"></a>06271 {
<a name="l06272"></a>06272   mAutoMargin = enabled;
<a name="l06273"></a>06273 }
<a name="l06274"></a>06274 
<a name="l06278"></a>06278 <span class="keywordtype">void</span> QCustomPlot::setColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l06279"></a>06279 {
<a name="l06280"></a>06280   mColor = color;
<a name="l06281"></a>06281 }
<a name="l06282"></a>06282 
<a name="l06299"></a>06299 <span class="keywordtype">void</span> QCustomPlot::setRangeDrag(Qt::Orientations orientations)
<a name="l06300"></a>06300 {
<a name="l06301"></a>06301   mRangeDrag = orientations;
<a name="l06302"></a>06302 }
<a name="l06303"></a>06303 
<a name="l06319"></a>06319 <span class="keywordtype">void</span> QCustomPlot::setRangeZoom(Qt::Orientations orientations)
<a name="l06320"></a>06320 {
<a name="l06321"></a>06321   mRangeZoom = orientations;
<a name="l06322"></a>06322 }
<a name="l06323"></a>06323 
<a name="l06330"></a>06330 <span class="keywordtype">void</span> QCustomPlot::setRangeDragAxes(QCPAxis *horizontal, QCPAxis *vertical)
<a name="l06331"></a>06331 {
<a name="l06332"></a>06332   <span class="keywordflow">if</span> (horizontal)
<a name="l06333"></a>06333     mRangeDragHorzAxis = horizontal;
<a name="l06334"></a>06334   <span class="keywordflow">if</span> (vertical)
<a name="l06335"></a>06335     mRangeDragVertAxis = vertical;
<a name="l06336"></a>06336 }
<a name="l06337"></a>06337 
<a name="l06345"></a>06345 <span class="keywordtype">void</span> QCustomPlot::setRangeZoomAxes(QCPAxis *horizontal, QCPAxis *vertical)
<a name="l06346"></a>06346 {
<a name="l06347"></a>06347   <span class="keywordflow">if</span> (horizontal)
<a name="l06348"></a>06348     mRangeZoomHorzAxis = horizontal;
<a name="l06349"></a>06349   <span class="keywordflow">if</span> (vertical)
<a name="l06350"></a>06350     mRangeZoomVertAxis = vertical;
<a name="l06351"></a>06351 }
<a name="l06352"></a>06352 
<a name="l06363"></a>06363 <span class="keywordtype">void</span> QCustomPlot::setRangeZoomFactor(<span class="keywordtype">double</span> horizontalFactor, <span class="keywordtype">double</span> verticalFactor)
<a name="l06364"></a>06364 {
<a name="l06365"></a>06365   mRangeZoomFactorHorz = horizontalFactor;
<a name="l06366"></a>06366   mRangeZoomFactorVert = verticalFactor;
<a name="l06367"></a>06367 }
<a name="l06368"></a>06368 
<a name="l06373"></a>06373 <span class="keywordtype">void</span> QCustomPlot::setRangeZoomFactor(<span class="keywordtype">double</span> factor)
<a name="l06374"></a>06374 {
<a name="l06375"></a>06375   mRangeZoomFactorHorz = factor;
<a name="l06376"></a>06376   mRangeZoomFactorVert = factor;
<a name="l06377"></a>06377 }
<a name="l06378"></a>06378 
<a name="l06382"></a>06382 <span class="keywordtype">void</span> QCustomPlot::setAntialiasedElements(<span class="keyword">const</span> AntialiasedElements &amp;antialiasedElements)
<a name="l06383"></a>06383 {
<a name="l06384"></a>06384   mAntialiasedElements = antialiasedElements;
<a name="l06385"></a>06385 }
<a name="l06386"></a>06386 
<a name="l06390"></a>06390 <span class="keywordtype">void</span> QCustomPlot::setAntialiasedElement(AntialiasedElement antialiasedElement, <span class="keywordtype">bool</span> enabled)
<a name="l06391"></a>06391 {
<a name="l06392"></a>06392   <span class="keywordflow">if</span> (!enabled &amp;&amp; mAntialiasedElements.testFlag(antialiasedElement))
<a name="l06393"></a>06393     mAntialiasedElements &amp;= ~antialiasedElement;
<a name="l06394"></a>06394   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (enabled &amp;&amp; !mAntialiasedElements.testFlag(antialiasedElement))
<a name="l06395"></a>06395     mAntialiasedElements |= antialiasedElement;
<a name="l06396"></a>06396 }
<a name="l06397"></a>06397 
<a name="l06404"></a>06404 <span class="keywordtype">void</span> QCustomPlot::setAutoAddPlottableToLegend(<span class="keywordtype">bool</span> on)
<a name="l06405"></a>06405 {
<a name="l06406"></a>06406   mAutoAddPlottableToLegend = on;
<a name="l06407"></a>06407 }
<a name="l06408"></a>06408 
<a name="l06417"></a>06417 <span class="keywordtype">void</span> QCustomPlot::setAxisBackground(<span class="keyword">const</span> QPixmap &amp;pm)
<a name="l06418"></a>06418 {
<a name="l06419"></a>06419   mAxisBackground = pm;
<a name="l06420"></a>06420   mScaledAxisBackground = QPixmap();
<a name="l06421"></a>06421 }
<a name="l06422"></a>06422 
<a name="l06428"></a>06428 <span class="keywordtype">void</span> QCustomPlot::setAxisBackground(<span class="keyword">const</span> QPixmap &amp;pm, <span class="keywordtype">bool</span> scaled, Qt::AspectRatioMode mode)
<a name="l06429"></a>06429 {
<a name="l06430"></a>06430   mAxisBackground = pm;
<a name="l06431"></a>06431   mScaledAxisBackground = QPixmap();
<a name="l06432"></a>06432   mAxisBackgroundScaled = scaled;
<a name="l06433"></a>06433   mAxisBackgroundScaledMode = mode;
<a name="l06434"></a>06434 }
<a name="l06435"></a>06435 
<a name="l06447"></a>06447 <span class="keywordtype">void</span> QCustomPlot::setAxisBackgroundScaled(<span class="keywordtype">bool</span> scaled)
<a name="l06448"></a>06448 {
<a name="l06449"></a>06449   mAxisBackgroundScaled = scaled;
<a name="l06450"></a>06450 }
<a name="l06451"></a>06451 
<a name="l06457"></a>06457 <span class="keywordtype">void</span> QCustomPlot::setAxisBackgroundScaledMode(Qt::AspectRatioMode mode)
<a name="l06458"></a>06458 {
<a name="l06459"></a>06459   mAxisBackgroundScaledMode = mode;
<a name="l06460"></a>06460 }
<a name="l06461"></a>06461 
<a name="l06508"></a>06508 <span class="keywordtype">void</span> QCustomPlot::setInteractions(<span class="keyword">const</span> Interactions &amp;interactions)
<a name="l06509"></a>06509 {
<a name="l06510"></a>06510   mInteractions = interactions;
<a name="l06511"></a>06511 }
<a name="l06512"></a>06512 
<a name="l06520"></a>06520 <span class="keywordtype">void</span> QCustomPlot::setInteraction(<span class="keyword">const</span> QCustomPlot::Interaction &amp;interaction, <span class="keywordtype">bool</span> enabled)
<a name="l06521"></a>06521 {
<a name="l06522"></a>06522   <span class="keywordflow">if</span> (!enabled &amp;&amp; mInteractions.testFlag(interaction))
<a name="l06523"></a>06523     mInteractions &amp;= ~interaction;
<a name="l06524"></a>06524   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (enabled &amp;&amp; !mInteractions.testFlag(interaction))
<a name="l06525"></a>06525     mInteractions |= interaction;
<a name="l06526"></a>06526 }
<a name="l06527"></a>06527 
<a name="l06541"></a>06541 <span class="keywordtype">void</span> QCustomPlot::setSelectionTolerance(<span class="keywordtype">int</span> pixels)
<a name="l06542"></a>06542 {
<a name="l06543"></a>06543   mSelectionTolerance = pixels;
<a name="l06544"></a>06544 }
<a name="l06545"></a>06545 
<a name="l06551"></a>06551 <span class="keywordtype">void</span> QCustomPlot::setSelectedTitleFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l06552"></a>06552 {
<a name="l06553"></a>06553   mSelectedTitleFont = font;
<a name="l06554"></a>06554 }
<a name="l06555"></a>06555 
<a name="l06561"></a>06561 <span class="keywordtype">void</span> QCustomPlot::setSelectedTitleColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l06562"></a>06562 {
<a name="l06563"></a>06563   mSelectedTitleColor = color;
<a name="l06564"></a>06564 }
<a name="l06565"></a>06565 
<a name="l06571"></a>06571 <span class="keywordtype">void</span> QCustomPlot::setTitleSelected(<span class="keywordtype">bool</span> selected)
<a name="l06572"></a>06572 {
<a name="l06573"></a>06573   mTitleSelected = selected;
<a name="l06574"></a>06574 }
<a name="l06575"></a>06575 
<a name="l06584"></a>06584 QCPAbstractPlottable *QCustomPlot::plottable(<span class="keywordtype">int</span> index)
<a name="l06585"></a>06585 {
<a name="l06586"></a>06586   <span class="keywordflow">if</span> (index &gt;= 0 &amp;&amp; index &lt; mPlottables.size())
<a name="l06587"></a>06587   {
<a name="l06588"></a>06588     <span class="keywordflow">return</span> mPlottables.at(index);
<a name="l06589"></a>06589   } <span class="keywordflow">else</span>
<a name="l06590"></a>06590   {
<a name="l06591"></a>06591     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;index out of bounds:&quot;</span> &lt;&lt; index;
<a name="l06592"></a>06592     <span class="keywordflow">return</span> 0;
<a name="l06593"></a>06593   }
<a name="l06594"></a>06594 }
<a name="l06595"></a>06595 
<a name="l06603"></a>06603 QCPAbstractPlottable *QCustomPlot::plottable()
<a name="l06604"></a>06604 {
<a name="l06605"></a>06605   <span class="keywordflow">if</span> (!mPlottables.isEmpty())
<a name="l06606"></a>06606   {
<a name="l06607"></a>06607     <span class="keywordflow">return</span> mPlottables.last();
<a name="l06608"></a>06608   } <span class="keywordflow">else</span>
<a name="l06609"></a>06609     <span class="keywordflow">return</span> 0;
<a name="l06610"></a>06610 }
<a name="l06611"></a>06611 
<a name="l06622"></a>06622 <span class="keywordtype">bool</span> QCustomPlot::addPlottable(QCPAbstractPlottable *plottable)
<a name="l06623"></a>06623 {
<a name="l06624"></a>06624   <span class="keywordflow">if</span> (!mPlottables.contains(plottable) &amp;&amp; plottable-&gt;parentPlot() == <span class="keyword">this</span>)
<a name="l06625"></a>06625   {
<a name="l06626"></a>06626     mPlottables.append(plottable);
<a name="l06627"></a>06627     <span class="comment">// possibly add plottable to legend:</span>
<a name="l06628"></a>06628     <span class="keywordflow">if</span> (mAutoAddPlottableToLegend)
<a name="l06629"></a>06629       plottable-&gt;addToLegend();
<a name="l06630"></a>06630     <span class="comment">// special handling for QCPGraphs to maintain the simple graph interface:</span>
<a name="l06631"></a>06631     <span class="keywordflow">if</span> (QCPGraph *graph = qobject_cast&lt;QCPGraph*&gt;(plottable))
<a name="l06632"></a>06632       mGraphs.append(graph);
<a name="l06633"></a>06633     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l06634"></a>06634   } <span class="keywordflow">else</span>
<a name="l06635"></a>06635   {
<a name="l06636"></a>06636     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;plottable either already in list or not created with this QCustomPlot as parent:&quot;</span> &lt;&lt; (int)plottable;
<a name="l06637"></a>06637     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l06638"></a>06638   }
<a name="l06639"></a>06639 }
<a name="l06640"></a>06640 
<a name="l06648"></a>06648 <span class="keywordtype">bool</span> QCustomPlot::removePlottable(QCPAbstractPlottable *plottable)
<a name="l06649"></a>06649 {
<a name="l06650"></a>06650   <span class="keywordflow">if</span> (mPlottables.contains(plottable))
<a name="l06651"></a>06651   {
<a name="l06652"></a>06652     <span class="comment">// remove plottable from legend:</span>
<a name="l06653"></a>06653     plottable-&gt;removeFromLegend();
<a name="l06654"></a>06654     <span class="comment">// special handling for QCPGraphs to maintain the simple graph interface:</span>
<a name="l06655"></a>06655     <span class="keywordflow">if</span> (QCPGraph *graph = qobject_cast&lt;QCPGraph*&gt;(plottable))
<a name="l06656"></a>06656       mGraphs.removeOne(graph);
<a name="l06657"></a>06657     <span class="comment">// remove plottable:</span>
<a name="l06658"></a>06658     <span class="keyword">delete</span> plottable;
<a name="l06659"></a>06659     mPlottables.removeOne(plottable);
<a name="l06660"></a>06660     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l06661"></a>06661   } <span class="keywordflow">else</span>
<a name="l06662"></a>06662   {
<a name="l06663"></a>06663     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;plottable not in list:&quot;</span> &lt;&lt; (int)plottable;
<a name="l06664"></a>06664     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l06665"></a>06665   }
<a name="l06666"></a>06666 }
<a name="l06667"></a>06667 
<a name="l06672"></a>06672 <span class="keywordtype">bool</span> QCustomPlot::removePlottable(<span class="keywordtype">int</span> index)
<a name="l06673"></a>06673 {
<a name="l06674"></a>06674   <span class="keywordflow">if</span> (index &gt;= 0 &amp;&amp; index &lt; mPlottables.size())
<a name="l06675"></a>06675     <span class="keywordflow">return</span> removePlottable(mPlottables[index]);
<a name="l06676"></a>06676   <span class="keywordflow">else</span>
<a name="l06677"></a>06677   {
<a name="l06678"></a>06678     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;index out of bounds:&quot;</span> &lt;&lt; index;
<a name="l06679"></a>06679     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l06680"></a>06680   }
<a name="l06681"></a>06681 }
<a name="l06682"></a>06682 
<a name="l06690"></a>06690 <span class="keywordtype">int</span> QCustomPlot::clearPlottables()
<a name="l06691"></a>06691 {
<a name="l06692"></a>06692   <span class="keywordtype">int</span> c = mPlottables.size();
<a name="l06693"></a>06693   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=c-1; i &gt;= 0; --i)
<a name="l06694"></a>06694     removePlottable(mPlottables[i]);
<a name="l06695"></a>06695   <span class="keywordflow">return</span> c;
<a name="l06696"></a>06696 }
<a name="l06697"></a>06697 
<a name="l06703"></a>06703 <span class="keywordtype">int</span> QCustomPlot::plottableCount()<span class="keyword"> const</span>
<a name="l06704"></a>06704 <span class="keyword"></span>{
<a name="l06705"></a>06705   <span class="keywordflow">return</span> mPlottables.size();
<a name="l06706"></a>06706 }
<a name="l06707"></a>06707 
<a name="l06715"></a>06715 QList&lt;QCPAbstractPlottable*&gt; QCustomPlot::selectedPlottables()<span class="keyword"> const</span>
<a name="l06716"></a>06716 <span class="keyword"></span>{
<a name="l06717"></a>06717   QList&lt;QCPAbstractPlottable*&gt; result;
<a name="l06718"></a>06718   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mPlottables.size(); ++i)
<a name="l06719"></a>06719   {
<a name="l06720"></a>06720     <span class="keywordflow">if</span> (mPlottables.at(i)-&gt;selected())
<a name="l06721"></a>06721       result.append(mPlottables.at(i));
<a name="l06722"></a>06722   }
<a name="l06723"></a>06723   <span class="keywordflow">return</span> result;
<a name="l06724"></a>06724 }
<a name="l06725"></a>06725 
<a name="l06736"></a>06736 QCPAbstractPlottable *QCustomPlot::plottableAt(<span class="keyword">const</span> QPoint &amp;pos, <span class="keywordtype">bool</span> onlySelectable)<span class="keyword"> const</span>
<a name="l06737"></a>06737 <span class="keyword"></span>{
<a name="l06738"></a>06738   QCPAbstractPlottable *resultPlottable = 0;
<a name="l06739"></a>06739   <span class="keywordtype">double</span> resultDistance = mSelectionTolerance; <span class="comment">// only regard clicks with distances smaller than mSelectionTolerance as selections, so initialize with that value</span>
<a name="l06740"></a>06740   
<a name="l06741"></a>06741   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mPlottables.size(); ++i)
<a name="l06742"></a>06742   {
<a name="l06743"></a>06743     QCPAbstractPlottable *currentPlottable = mPlottables[i];
<a name="l06744"></a>06744     <span class="keywordflow">if</span> (onlySelectable &amp;&amp; !currentPlottable-&gt;selectable())
<a name="l06745"></a>06745       <span class="keywordflow">continue</span>;
<a name="l06746"></a>06746     <span class="keywordflow">if</span> ((currentPlottable-&gt;keyAxis()-&gt;axisRect() | currentPlottable-&gt;valueAxis()-&gt;axisRect()).contains(pos)) <span class="comment">// only consider clicks inside the rect that is spanned by the plottable&#39;s key/value axes</span>
<a name="l06747"></a>06747     {
<a name="l06748"></a>06748       <span class="keywordtype">double</span> key, value;
<a name="l06749"></a>06749       currentPlottable-&gt;pixelsToCoords(pos, key, value);
<a name="l06750"></a>06750       <span class="keywordtype">double</span> currentDistance = currentPlottable-&gt;selectTest(key, value);
<a name="l06751"></a>06751       <span class="keywordflow">if</span> (currentDistance &gt; 0 &amp;&amp; currentDistance &lt; resultDistance)
<a name="l06752"></a>06752       {
<a name="l06753"></a>06753         resultPlottable = currentPlottable;
<a name="l06754"></a>06754         resultDistance = currentDistance;
<a name="l06755"></a>06755       }
<a name="l06756"></a>06756     }
<a name="l06757"></a>06757   }
<a name="l06758"></a>06758   
<a name="l06759"></a>06759   <span class="keywordflow">return</span> resultPlottable;
<a name="l06760"></a>06760 }
<a name="l06761"></a>06761 
<a name="l06770"></a>06770 QCPGraph *QCustomPlot::graph(<span class="keywordtype">int</span> index)<span class="keyword"> const</span>
<a name="l06771"></a>06771 <span class="keyword"></span>{
<a name="l06772"></a>06772   <span class="keywordflow">if</span> (index &gt;= 0 &amp;&amp; index &lt; mGraphs.size())
<a name="l06773"></a>06773   {
<a name="l06774"></a>06774     <span class="keywordflow">return</span> mGraphs.at(index);
<a name="l06775"></a>06775   } <span class="keywordflow">else</span>
<a name="l06776"></a>06776   {
<a name="l06777"></a>06777     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;index out of bounds:&quot;</span> &lt;&lt; index;
<a name="l06778"></a>06778     <span class="keywordflow">return</span> 0;
<a name="l06779"></a>06779   }
<a name="l06780"></a>06780 }
<a name="l06781"></a>06781 
<a name="l06789"></a>06789 QCPGraph *QCustomPlot::graph()<span class="keyword"> const</span>
<a name="l06790"></a>06790 <span class="keyword"></span>{
<a name="l06791"></a>06791   <span class="keywordflow">if</span> (!mGraphs.isEmpty())
<a name="l06792"></a>06792   {
<a name="l06793"></a>06793     <span class="keywordflow">return</span> mGraphs.last();
<a name="l06794"></a>06794   } <span class="keywordflow">else</span>
<a name="l06795"></a>06795     <span class="keywordflow">return</span> 0;
<a name="l06796"></a>06796 }
<a name="l06797"></a>06797 
<a name="l06810"></a>06810 QCPGraph *QCustomPlot::addGraph(QCPAxis *keyAxis, QCPAxis *valueAxis)
<a name="l06811"></a>06811 {
<a name="l06812"></a>06812   <span class="keywordflow">if</span> (!keyAxis) keyAxis = xAxis;
<a name="l06813"></a>06813   <span class="keywordflow">if</span> (!valueAxis) valueAxis = yAxis;
<a name="l06814"></a>06814   QCPGraph *newGraph = <span class="keyword">new</span> QCPGraph(keyAxis, valueAxis);
<a name="l06815"></a>06815   <span class="keywordflow">if</span> (addPlottable(newGraph))
<a name="l06816"></a>06816   {
<a name="l06817"></a>06817     newGraph-&gt;setName(<span class="stringliteral">&quot;Graph &quot;</span>+QString::number(mGraphs.size()));
<a name="l06818"></a>06818     <span class="keywordflow">return</span> newGraph;
<a name="l06819"></a>06819   } <span class="keywordflow">else</span>
<a name="l06820"></a>06820   {
<a name="l06821"></a>06821     <span class="keyword">delete</span> newGraph;
<a name="l06822"></a>06822     <span class="keywordflow">return</span> 0;
<a name="l06823"></a>06823   }
<a name="l06824"></a>06824 }
<a name="l06825"></a>06825 
<a name="l06835"></a>06835 <span class="keywordtype">bool</span> QCustomPlot::removeGraph(QCPGraph *graph)
<a name="l06836"></a>06836 {
<a name="l06837"></a>06837   <span class="keywordflow">return</span> removePlottable(graph);
<a name="l06838"></a>06838 }
<a name="l06839"></a>06839 
<a name="l06844"></a>06844 <span class="keywordtype">bool</span> QCustomPlot::removeGraph(<span class="keywordtype">int</span> index)
<a name="l06845"></a>06845 {
<a name="l06846"></a>06846   <span class="keywordflow">if</span> (index &gt;= 0 &amp;&amp; index &lt; mGraphs.size())
<a name="l06847"></a>06847     <span class="keywordflow">return</span> removeGraph(mGraphs[index]);
<a name="l06848"></a>06848   <span class="keywordflow">else</span>
<a name="l06849"></a>06849     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l06850"></a>06850 }
<a name="l06851"></a>06851 
<a name="l06857"></a>06857 <span class="keywordtype">int</span> QCustomPlot::clearGraphs()
<a name="l06858"></a>06858 {
<a name="l06859"></a>06859   <span class="keywordtype">int</span> c = mGraphs.size();
<a name="l06860"></a>06860   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=c-1; i &gt;= 0; --i)
<a name="l06861"></a>06861     removeGraph(mGraphs[i]);
<a name="l06862"></a>06862   <span class="keywordflow">return</span> c;
<a name="l06863"></a>06863 }
<a name="l06864"></a>06864 
<a name="l06870"></a>06870 <span class="keywordtype">int</span> QCustomPlot::graphCount()<span class="keyword"> const</span>
<a name="l06871"></a>06871 <span class="keyword"></span>{
<a name="l06872"></a>06872   <span class="keywordflow">return</span> mGraphs.size();
<a name="l06873"></a>06873 }
<a name="l06874"></a>06874 
<a name="l06884"></a>06884 QList&lt;QCPGraph*&gt; QCustomPlot::selectedGraphs()<span class="keyword"> const</span>
<a name="l06885"></a>06885 <span class="keyword"></span>{
<a name="l06886"></a>06886   QList&lt;QCPGraph*&gt; result;
<a name="l06887"></a>06887   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mGraphs.size(); ++i)
<a name="l06888"></a>06888   {
<a name="l06889"></a>06889     <span class="keywordflow">if</span> (mGraphs.at(i)-&gt;selected())
<a name="l06890"></a>06890       result.append(mGraphs.at(i));
<a name="l06891"></a>06891   }
<a name="l06892"></a>06892   <span class="keywordflow">return</span> result;
<a name="l06893"></a>06893 }
<a name="l06894"></a>06894 
<a name="l06900"></a>06900 QList&lt;QCPAxis*&gt; QCustomPlot::selectedAxes()<span class="keyword"> const</span>
<a name="l06901"></a>06901 <span class="keyword"></span>{
<a name="l06902"></a>06902   QList&lt;QCPAxis*&gt; result = QList&lt;QCPAxis*&gt;() &lt;&lt; xAxis &lt;&lt; yAxis &lt;&lt; xAxis2 &lt;&lt; yAxis2;
<a name="l06903"></a>06903   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=result.size()-1; i&gt;=0; --i)
<a name="l06904"></a>06904   {
<a name="l06905"></a>06905     <span class="keywordflow">if</span> (result.at(i)-&gt;selected() == QCPAxis::spNone)
<a name="l06906"></a>06906       result.removeAt(i);
<a name="l06907"></a>06907   }
<a name="l06908"></a>06908   <span class="keywordflow">return</span> result;
<a name="l06909"></a>06909 }
<a name="l06910"></a>06910 
<a name="l06917"></a>06917 QList&lt;QCPLegend*&gt; QCustomPlot::selectedLegends()<span class="keyword"> const</span>
<a name="l06918"></a>06918 <span class="keyword"></span>{
<a name="l06919"></a>06919   <span class="comment">/* for now, we only have the one legend. Maybe later, there will be a mechanism to have more. */</span>
<a name="l06920"></a>06920   QList&lt;QCPLegend*&gt; result;
<a name="l06921"></a>06921   <span class="keywordflow">if</span> (legend-&gt;selected() != QCPLegend::spNone)
<a name="l06922"></a>06922     result.append(legend);
<a name="l06923"></a>06923   <span class="keywordflow">return</span> result;
<a name="l06924"></a>06924 }
<a name="l06925"></a>06925 
<a name="l06935"></a>06935 <span class="keywordtype">void</span> QCustomPlot::deselectAll()
<a name="l06936"></a>06936 {
<a name="l06937"></a>06937   <span class="comment">// deselect plottables:</span>
<a name="l06938"></a>06938   QList&lt;QCPAbstractPlottable*&gt; selPlottables = selectedPlottables();
<a name="l06939"></a>06939   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;selPlottables.size(); ++i)
<a name="l06940"></a>06940     selPlottables.at(i)-&gt;setSelected(<span class="keyword">false</span>);
<a name="l06941"></a>06941   
<a name="l06942"></a>06942   <span class="comment">// deselect axes:</span>
<a name="l06943"></a>06943   QList&lt;QCPAxis*&gt; selAxes = selectedAxes();
<a name="l06944"></a>06944   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;selAxes.size(); ++i)
<a name="l06945"></a>06945     selAxes.at(i)-&gt;setSelected(QCPAxis::spNone);
<a name="l06946"></a>06946   
<a name="l06947"></a>06947   <span class="comment">// deselect legend:</span>
<a name="l06948"></a>06948   legend-&gt;setSelected(QCPLegend::spNone);
<a name="l06949"></a>06949   
<a name="l06950"></a>06950   <span class="comment">// deselect title:</span>
<a name="l06951"></a>06951   setTitleSelected(<span class="keyword">false</span>);
<a name="l06952"></a>06952 }
<a name="l06953"></a>06953 
<a name="l06962"></a>06962 <span class="keywordtype">void</span> QCustomPlot::replot()
<a name="l06963"></a>06963 {
<a name="l06964"></a>06964   <span class="keywordflow">if</span> (mReplotting) <span class="comment">// incase signals loop back to replot slot</span>
<a name="l06965"></a>06965     <span class="keywordflow">return</span>;
<a name="l06966"></a>06966   mReplotting = <span class="keyword">true</span>;
<a name="l06967"></a>06967   emit beforeReplot();
<a name="l06968"></a>06968   QPainter painter(&amp;buffer);
<a name="l06969"></a>06969   <span class="keywordflow">if</span> (!painter.isActive()) <span class="comment">// might happen if QCustomPlot has width or height zero</span>
<a name="l06970"></a>06970   {
<a name="l06971"></a>06971     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;Couldn&#39;t activate painter on buffer&quot;</span>;
<a name="l06972"></a>06972     <span class="keywordflow">return</span>;
<a name="l06973"></a>06973   }
<a name="l06974"></a>06974   painter.fillRect(rect(), mColor);
<a name="l06975"></a>06975   draw(&amp;painter);
<a name="l06976"></a>06976   update();
<a name="l06977"></a>06977   emit afterReplot();
<a name="l06978"></a>06978   mReplotting = <span class="keyword">false</span>;
<a name="l06979"></a>06979 }
<a name="l06980"></a>06980 
<a name="l07001"></a>07001 <span class="keywordtype">void</span> QCustomPlot::setupFullAxesBox()
<a name="l07002"></a>07002 {
<a name="l07003"></a>07003   xAxis2-&gt;setVisible(<span class="keyword">true</span>);
<a name="l07004"></a>07004   yAxis2-&gt;setVisible(<span class="keyword">true</span>);
<a name="l07005"></a>07005   
<a name="l07006"></a>07006   xAxis2-&gt;setTickLabels(<span class="keyword">false</span>);
<a name="l07007"></a>07007   yAxis2-&gt;setTickLabels(<span class="keyword">false</span>);
<a name="l07008"></a>07008   
<a name="l07009"></a>07009   xAxis2-&gt;setAutoSubTicks(xAxis-&gt;autoSubTicks());
<a name="l07010"></a>07010   yAxis2-&gt;setAutoSubTicks(yAxis-&gt;autoSubTicks());
<a name="l07011"></a>07011   
<a name="l07012"></a>07012   xAxis2-&gt;setAutoTickCount(xAxis-&gt;autoTickCount());
<a name="l07013"></a>07013   yAxis2-&gt;setAutoTickCount(yAxis-&gt;autoTickCount());
<a name="l07014"></a>07014   
<a name="l07015"></a>07015   xAxis2-&gt;setAutoTickStep(xAxis-&gt;autoTickStep());
<a name="l07016"></a>07016   yAxis2-&gt;setAutoTickStep(yAxis-&gt;autoTickStep());
<a name="l07017"></a>07017   
<a name="l07018"></a>07018   xAxis2-&gt;setScaleType(xAxis-&gt;scaleType());
<a name="l07019"></a>07019   yAxis2-&gt;setScaleType(yAxis-&gt;scaleType());
<a name="l07020"></a>07020   
<a name="l07021"></a>07021   xAxis2-&gt;setScaleLogBase(xAxis-&gt;scaleLogBase());
<a name="l07022"></a>07022   yAxis2-&gt;setScaleLogBase(yAxis-&gt;scaleLogBase());
<a name="l07023"></a>07023   
<a name="l07024"></a>07024   xAxis2-&gt;setTicks(xAxis-&gt;ticks());
<a name="l07025"></a>07025   yAxis2-&gt;setTicks(yAxis-&gt;ticks());
<a name="l07026"></a>07026   
<a name="l07027"></a>07027   xAxis2-&gt;setSubTickCount(xAxis-&gt;subTickCount());
<a name="l07028"></a>07028   yAxis2-&gt;setSubTickCount(yAxis-&gt;subTickCount());
<a name="l07029"></a>07029   
<a name="l07030"></a>07030   xAxis2-&gt;setTickStep(xAxis-&gt;tickStep());
<a name="l07031"></a>07031   yAxis2-&gt;setTickStep(yAxis-&gt;tickStep());
<a name="l07032"></a>07032   
<a name="l07033"></a>07033   xAxis2-&gt;setRange(xAxis-&gt;range());
<a name="l07034"></a>07034   yAxis2-&gt;setRange(yAxis-&gt;range());
<a name="l07035"></a>07035   
<a name="l07036"></a>07036   xAxis2-&gt;setRangeReversed(xAxis-&gt;rangeReversed());
<a name="l07037"></a>07037   yAxis2-&gt;setRangeReversed(yAxis-&gt;rangeReversed());
<a name="l07038"></a>07038 }
<a name="l07039"></a>07039 
<a name="l07046"></a>07046 <span class="keywordtype">void</span> QCustomPlot::rescaleAxes()
<a name="l07047"></a>07047 {
<a name="l07048"></a>07048   <span class="keywordflow">if</span> (mPlottables.isEmpty()) <span class="keywordflow">return</span>;
<a name="l07049"></a>07049   
<a name="l07050"></a>07050   mPlottables.at(0)-&gt;rescaleAxes(<span class="keyword">false</span>); <span class="comment">// onlyEnlarge disabled on first plottable</span>
<a name="l07051"></a>07051   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;mPlottables.size(); ++i)
<a name="l07052"></a>07052     mPlottables.at(i)-&gt;rescaleAxes(<span class="keyword">true</span>);  <span class="comment">// onlyEnlarge enabled on all other plottables</span>
<a name="l07053"></a>07053 }
<a name="l07054"></a>07054 
<a name="l07084"></a>07084 <span class="keywordtype">void</span> QCustomPlot::savePdf(<span class="keyword">const</span> QString &amp;fileName, <span class="keywordtype">bool</span> noCosmeticPen, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
<a name="l07085"></a>07085 {
<a name="l07086"></a>07086   <span class="keywordtype">int</span> newWidth, newHeight;
<a name="l07087"></a>07087   <span class="keywordflow">if</span> (width == 0 || height == 0)
<a name="l07088"></a>07088   {
<a name="l07089"></a>07089     newWidth = this-&gt;width();
<a name="l07090"></a>07090     newHeight = this-&gt;height();
<a name="l07091"></a>07091   } <span class="keywordflow">else</span>
<a name="l07092"></a>07092   {
<a name="l07093"></a>07093     newWidth = width;
<a name="l07094"></a>07094     newHeight = height;
<a name="l07095"></a>07095   }
<a name="l07096"></a>07096   
<a name="l07097"></a>07097   QPrinter printer(QPrinter::ScreenResolution);
<a name="l07098"></a>07098   printer.setOutputFileName(fileName);
<a name="l07099"></a>07099   printer.setFullPage(<span class="keyword">true</span>);
<a name="l07100"></a>07100   QRect oldViewport = mViewport;
<a name="l07101"></a>07101   mViewport = QRect(0, 0, newWidth, newHeight);
<a name="l07102"></a>07102   updateAxisRect();
<a name="l07103"></a>07103   printer.setPaperSize(mViewport.size(), QPrinter::DevicePixel);
<a name="l07104"></a>07104   QPainter printpainter(&amp;printer);
<a name="l07105"></a>07105   printpainter.setWindow(mViewport);
<a name="l07106"></a>07106   printpainter.setRenderHint(QPainter::NonCosmeticDefaultPen, noCosmeticPen);
<a name="l07107"></a>07107   draw(&amp;printpainter);
<a name="l07108"></a>07108   mViewport = oldViewport;
<a name="l07109"></a>07109   updateAxisRect();
<a name="l07110"></a>07110 }
<a name="l07111"></a>07111 
<a name="l07112"></a>07112 <span class="comment">/*</span>
<a name="l07113"></a>07113 <span class="comment">  Function for providing svg export. Requires the QtSvg module</span>
<a name="l07114"></a>07114 <span class="comment">  This is Not tested and will require some modifications!</span>
<a name="l07115"></a>07115 <span class="comment">*/</span>
<a name="l07116"></a>07116 <span class="comment">/*</span>
<a name="l07117"></a>07117 <span class="comment">void QCustomPlot::saveSvg(const QString &amp;fileName)</span>
<a name="l07118"></a>07118 <span class="comment">{  </span>
<a name="l07119"></a>07119 <span class="comment">  QSvgGenerator generator;</span>
<a name="l07120"></a>07120 <span class="comment">  generator.setFileName(fileName);</span>
<a name="l07121"></a>07121 <span class="comment">  generator.setSize(QSize(200, 200));</span>
<a name="l07122"></a>07122 <span class="comment">  generator.setViewBox(QRect(0, 0, 200, 200));</span>
<a name="l07123"></a>07123 <span class="comment">  generator.setTitle(&quot;&quot;);</span>
<a name="l07124"></a>07124 <span class="comment">  generator.setDescription(&quot;&quot;);</span>
<a name="l07125"></a>07125 <span class="comment">  QPainter painter(&amp;generator);</span>
<a name="l07126"></a>07126 <span class="comment">  draw(&amp;painter);</span>
<a name="l07127"></a>07127 <span class="comment">}</span>
<a name="l07128"></a>07128 <span class="comment">*/</span>
<a name="l07129"></a>07129 
<a name="l07150"></a>07150 <span class="keywordtype">void</span> QCustomPlot::savePng(<span class="keyword">const</span> QString &amp;fileName, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
<a name="l07151"></a>07151 {  
<a name="l07152"></a>07152   <span class="keywordtype">int</span> newWidth, newHeight;
<a name="l07153"></a>07153   <span class="keywordflow">if</span> (width == 0 || height == 0)
<a name="l07154"></a>07154   {
<a name="l07155"></a>07155     newWidth = this-&gt;width();
<a name="l07156"></a>07156     newHeight = this-&gt;height();
<a name="l07157"></a>07157   } <span class="keywordflow">else</span>
<a name="l07158"></a>07158   {
<a name="l07159"></a>07159     newWidth = width;
<a name="l07160"></a>07160     newHeight = height;
<a name="l07161"></a>07161   }
<a name="l07162"></a>07162   
<a name="l07163"></a>07163   QPixmap pngBuffer(newWidth, newHeight);
<a name="l07164"></a>07164   QPainter painter(&amp;pngBuffer);
<a name="l07165"></a>07165   painter.fillRect(pngBuffer.rect(), mColor);
<a name="l07166"></a>07166   QRect oldViewport = mViewport;
<a name="l07167"></a>07167   mViewport = QRect(0, 0, newWidth, newHeight);
<a name="l07168"></a>07168   updateAxisRect();
<a name="l07169"></a>07169   draw(&amp;painter);
<a name="l07170"></a>07170   mViewport = oldViewport;
<a name="l07171"></a>07171   updateAxisRect();
<a name="l07172"></a>07172   pngBuffer.save(fileName);
<a name="l07173"></a>07173 }
<a name="l07174"></a>07174 
<a name="l07201"></a>07201 <span class="keywordtype">void</span> QCustomPlot::savePngScaled(<span class="keyword">const</span> QString &amp;fileName, <span class="keywordtype">double</span> scale, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
<a name="l07202"></a>07202 {  
<a name="l07203"></a>07203   <span class="keywordtype">int</span> newWidth, newHeight;
<a name="l07204"></a>07204   <span class="keywordflow">if</span> (width == 0 || height == 0)
<a name="l07205"></a>07205   {
<a name="l07206"></a>07206     newWidth = this-&gt;width();
<a name="l07207"></a>07207     newHeight = this-&gt;height();
<a name="l07208"></a>07208   } <span class="keywordflow">else</span>
<a name="l07209"></a>07209   {
<a name="l07210"></a>07210     newWidth = width;
<a name="l07211"></a>07211     newHeight = height;
<a name="l07212"></a>07212   }
<a name="l07213"></a>07213   
<a name="l07214"></a>07214   <span class="keywordtype">int</span> scaledWidth = scale*newWidth;
<a name="l07215"></a>07215   <span class="keywordtype">int</span> scaledHeight = scale*newHeight;
<a name="l07216"></a>07216   
<a name="l07217"></a>07217   QPixmap pngBuffer(scaledWidth, scaledHeight);
<a name="l07218"></a>07218   QPainter painter(&amp;pngBuffer);
<a name="l07219"></a>07219   painter.setRenderHint(QPainter::NonCosmeticDefaultPen);
<a name="l07220"></a>07220   painter.fillRect(pngBuffer.rect(), mColor);
<a name="l07221"></a>07221   QRect oldViewport = mViewport;
<a name="l07222"></a>07222   mViewport = QRect(0, 0, newWidth, newHeight);
<a name="l07223"></a>07223   updateAxisRect();
<a name="l07224"></a>07224   painter.scale(scale, scale);
<a name="l07225"></a>07225   draw(&amp;painter);
<a name="l07226"></a>07226   mViewport = oldViewport;
<a name="l07227"></a>07227   updateAxisRect();
<a name="l07228"></a>07228   pngBuffer.save(fileName);
<a name="l07229"></a>07229 }
<a name="l07230"></a>07230 
<a name="l07236"></a>07236 <span class="keywordtype">void</span> QCustomPlot::paintEvent(QPaintEvent *event)
<a name="l07237"></a>07237 {
<a name="l07238"></a>07238   Q_UNUSED(event);
<a name="l07239"></a>07239   QPainter painter(<span class="keyword">this</span>);
<a name="l07240"></a>07240   painter.drawPixmap(0, 0, buffer);
<a name="l07241"></a>07241 }
<a name="l07242"></a>07242 
<a name="l07249"></a>07249 <span class="keywordtype">void</span> QCustomPlot::resizeEvent(QResizeEvent *event)
<a name="l07250"></a>07250 {
<a name="l07251"></a>07251   <span class="comment">// resize and repaint the buffer:</span>
<a name="l07252"></a>07252   buffer = QPixmap(event-&gt;size());
<a name="l07253"></a>07253   mViewport = rect();
<a name="l07254"></a>07254   updateAxisRect();
<a name="l07255"></a>07255   replot();
<a name="l07256"></a>07256 }
<a name="l07257"></a>07257 
<a name="l07262"></a>07262 <span class="keywordtype">void</span> QCustomPlot::mouseDoubleClickEvent(QMouseEvent *event)
<a name="l07263"></a>07263 {
<a name="l07264"></a>07264   emit mouseDoubleClick(event);
<a name="l07265"></a>07265   
<a name="l07266"></a>07266   <span class="comment">// emit specialized object double click signals:</span>
<a name="l07267"></a>07267   <span class="keywordtype">bool</span> foundHit = <span class="keyword">false</span>;
<a name="l07268"></a>07268   <span class="comment">// for legend:</span>
<a name="l07269"></a>07269   <span class="keywordflow">if</span> (receivers(SIGNAL(legendDoubleClick(QCPLegend*,QCPAbstractLegendItem*,QMouseEvent*))) &gt; 0)
<a name="l07270"></a>07270   {
<a name="l07271"></a>07271     <span class="keywordflow">if</span> (legend-&gt;selectTestLegend(event-&gt;pos()))
<a name="l07272"></a>07272     {
<a name="l07273"></a>07273       emit legendDoubleClick(legend, legend-&gt;selectTestItem(event-&gt;pos()), event);
<a name="l07274"></a>07274       foundHit = <span class="keyword">true</span>;
<a name="l07275"></a>07275     }
<a name="l07276"></a>07276   }
<a name="l07277"></a>07277   <span class="comment">// for plottables:</span>
<a name="l07278"></a>07278   <span class="keywordflow">if</span> (!foundHit &amp;&amp; receivers(SIGNAL(plottableDoubleClick(QCPAbstractPlottable*,QMouseEvent*))) &gt; 0)
<a name="l07279"></a>07279   {
<a name="l07280"></a>07280     <span class="keywordflow">if</span> (QCPAbstractPlottable *ap = plottableAt(event-&gt;pos(), <span class="keyword">false</span>))
<a name="l07281"></a>07281     {
<a name="l07282"></a>07282       emit plottableDoubleClick(ap, event);
<a name="l07283"></a>07283       foundHit = <span class="keyword">true</span>;
<a name="l07284"></a>07284     }
<a name="l07285"></a>07285   }
<a name="l07286"></a>07286   <span class="comment">// for axes:</span>
<a name="l07287"></a>07287   <span class="keywordflow">if</span> (!foundHit &amp;&amp; receivers(SIGNAL(axisDoubleClick(QCPAxis*,QCPAxis::SelectablePart,QMouseEvent*))) &gt; 0)
<a name="l07288"></a>07288   {
<a name="l07289"></a>07289     QVector&lt;QCPAxis*&gt; axes = QVector&lt;QCPAxis*&gt;() &lt;&lt; xAxis &lt;&lt; yAxis &lt;&lt; xAxis2 &lt;&lt; yAxis2;
<a name="l07290"></a>07290     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;axes.size(); ++i)
<a name="l07291"></a>07291     {
<a name="l07292"></a>07292       QCPAxis::SelectablePart part = axes.at(i)-&gt;selectTest(event-&gt;pos());
<a name="l07293"></a>07293       <span class="keywordflow">if</span> (part != QCPAxis::spNone)
<a name="l07294"></a>07294       {
<a name="l07295"></a>07295         foundHit = <span class="keyword">true</span>;
<a name="l07296"></a>07296         emit axisDoubleClick(axes.at(i), part, event);
<a name="l07297"></a>07297         <span class="keywordflow">break</span>;
<a name="l07298"></a>07298       }
<a name="l07299"></a>07299     }
<a name="l07300"></a>07300   }
<a name="l07301"></a>07301   <span class="comment">// for title:</span>
<a name="l07302"></a>07302   <span class="keywordflow">if</span> (!foundHit &amp;&amp; receivers(SIGNAL(titleDoubleClick(QMouseEvent*))) &gt; 0)
<a name="l07303"></a>07303   {
<a name="l07304"></a>07304     <span class="keywordflow">if</span> (selectTestTitle(event-&gt;pos()))
<a name="l07305"></a>07305     {
<a name="l07306"></a>07306       emit titleDoubleClick(event);
<a name="l07307"></a>07307       foundHit = <span class="keyword">true</span>;
<a name="l07308"></a>07308     }
<a name="l07309"></a>07309   }
<a name="l07310"></a>07310 }
<a name="l07311"></a>07311 
<a name="l07323"></a>07323 <span class="keywordtype">void</span> QCustomPlot::mousePressEvent(QMouseEvent *event)
<a name="l07324"></a>07324 {
<a name="l07325"></a>07325   emit mousePress(event);
<a name="l07326"></a>07326   mDragStart = <span class="keyword">event</span>-&gt;pos(); <span class="comment">// need this even when not LeftButton is pressed, to determine in releaseEvent whether it was a full click (no position change between press and release)</span>
<a name="l07327"></a>07327   <span class="keywordflow">if</span> (event-&gt;buttons() &amp; Qt::LeftButton)
<a name="l07328"></a>07328   {
<a name="l07329"></a>07329     mDragging = <span class="keyword">true</span>;
<a name="l07330"></a>07330     <span class="comment">// Mouse range dragging interaction:</span>
<a name="l07331"></a>07331     <span class="keywordflow">if</span> (mInteractions.testFlag(iRangeDrag))
<a name="l07332"></a>07332     {
<a name="l07333"></a>07333       mDragStartHorzRange = mRangeDragHorzAxis-&gt;range();
<a name="l07334"></a>07334       mDragStartVertRange = mRangeDragVertAxis-&gt;range();
<a name="l07335"></a>07335     }
<a name="l07336"></a>07336   }
<a name="l07337"></a>07337   
<a name="l07338"></a>07338   QWidget::mousePressEvent(event);
<a name="l07339"></a>07339 }
<a name="l07340"></a>07340 
<a name="l07348"></a>07348 <span class="keywordtype">void</span> QCustomPlot::mouseMoveEvent(QMouseEvent *event)
<a name="l07349"></a>07349 {
<a name="l07350"></a>07350   emit mouseMove(event);
<a name="l07351"></a>07351 
<a name="l07352"></a>07352   <span class="comment">// Mouse range dragging interaction:</span>
<a name="l07353"></a>07353   <span class="keywordflow">if</span> (mInteractions.testFlag(iRangeDrag))
<a name="l07354"></a>07354   {
<a name="l07355"></a>07355     <span class="keywordflow">if</span> (mDragging)
<a name="l07356"></a>07356     {
<a name="l07357"></a>07357       <span class="keywordflow">if</span> (mRangeDrag.testFlag(Qt::Horizontal))
<a name="l07358"></a>07358       {
<a name="l07359"></a>07359         <span class="keywordflow">if</span> (mRangeDragHorzAxis-&gt;mScaleType == QCPAxis::stLinear)
<a name="l07360"></a>07360         {
<a name="l07361"></a>07361           <span class="keywordtype">double</span> diff = mRangeDragHorzAxis-&gt;pixelToCoord(mDragStart.x()) - mRangeDragHorzAxis-&gt;pixelToCoord(event-&gt;pos().x());
<a name="l07362"></a>07362           mRangeDragHorzAxis-&gt;setRange(mDragStartHorzRange.lower+diff, mDragStartHorzRange.upper+diff);
<a name="l07363"></a>07363         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mRangeDragHorzAxis-&gt;mScaleType == QCPAxis::stLogarithmic)
<a name="l07364"></a>07364         {
<a name="l07365"></a>07365           <span class="keywordtype">double</span> diff = mRangeDragHorzAxis-&gt;pixelToCoord(mDragStart.x()) / mRangeDragHorzAxis-&gt;pixelToCoord(event-&gt;pos().x());
<a name="l07366"></a>07366           mRangeDragHorzAxis-&gt;setRange(mDragStartHorzRange.lower*diff, mDragStartHorzRange.upper*diff);
<a name="l07367"></a>07367         }
<a name="l07368"></a>07368       }
<a name="l07369"></a>07369       <span class="keywordflow">if</span> (mRangeDrag.testFlag(Qt::Vertical))
<a name="l07370"></a>07370       {
<a name="l07371"></a>07371         <span class="keywordflow">if</span> (mRangeDragVertAxis-&gt;mScaleType == QCPAxis::stLinear)
<a name="l07372"></a>07372         {
<a name="l07373"></a>07373           <span class="keywordtype">double</span> diff = mRangeDragVertAxis-&gt;pixelToCoord(mDragStart.y()) - mRangeDragVertAxis-&gt;pixelToCoord(event-&gt;pos().y());
<a name="l07374"></a>07374           mRangeDragVertAxis-&gt;setRange(mDragStartVertRange.lower+diff, mDragStartVertRange.upper+diff);
<a name="l07375"></a>07375         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mRangeDragVertAxis-&gt;mScaleType == QCPAxis::stLogarithmic)
<a name="l07376"></a>07376         {
<a name="l07377"></a>07377           <span class="keywordtype">double</span> diff = mRangeDragVertAxis-&gt;pixelToCoord(mDragStart.y()) / mRangeDragVertAxis-&gt;pixelToCoord(event-&gt;pos().y());
<a name="l07378"></a>07378           mRangeDragVertAxis-&gt;setRange(mDragStartVertRange.lower*diff, mDragStartVertRange.upper*diff);
<a name="l07379"></a>07379         }
<a name="l07380"></a>07380       }
<a name="l07381"></a>07381       <span class="keywordflow">if</span> (mRangeDrag != 0) <span class="comment">// if either vertical or horizontal drag was enabled, do a replot</span>
<a name="l07382"></a>07382         replot();
<a name="l07383"></a>07383     }
<a name="l07384"></a>07384   }
<a name="l07385"></a>07385   
<a name="l07386"></a>07386   QWidget::mouseMoveEvent(event);
<a name="l07387"></a>07387 }
<a name="l07388"></a>07388 
<a name="l07396"></a>07396 <span class="keywordtype">void</span> QCustomPlot::mouseReleaseEvent(QMouseEvent *event)
<a name="l07397"></a>07397 {
<a name="l07398"></a>07398   emit mouseRelease(event);
<a name="l07399"></a>07399   mDragging = <span class="keyword">false</span>;
<a name="l07400"></a>07400   
<a name="l07401"></a>07401   <span class="comment">// determine whether it was a drag or click operation:</span>
<a name="l07402"></a>07402   <span class="keywordflow">if</span> ((mDragStart-event-&gt;pos()).manhattanLength() &lt; 5) <span class="comment">// was a click</span>
<a name="l07403"></a>07403   {
<a name="l07404"></a>07404     <span class="comment">// Mouse selection interaction:</span>
<a name="l07405"></a>07405     <span class="keywordflow">if</span> ((mInteractions &amp; (iSelectPlottables|iSelectAxes|iSelectLegend|iSelectTitle)) &gt; 0 
<a name="l07406"></a>07406         &amp;&amp; event-&gt;button() == Qt::LeftButton)
<a name="l07407"></a>07407     {
<a name="l07408"></a>07408       <span class="keywordtype">bool</span> selectionFound = <span class="keyword">false</span>;
<a name="l07409"></a>07409       <span class="keywordtype">bool</span> emitChangedSignal = <span class="keyword">false</span>;
<a name="l07410"></a>07410       <span class="keywordtype">bool</span> additiveSelection = mInteractions.testFlag(iMultiSelect) &amp;&amp; <span class="keyword">event</span>-&gt;modifiers().testFlag(Qt::ControlModifier);
<a name="l07411"></a>07411       <span class="comment">// Mouse selection of legend:</span>
<a name="l07412"></a>07412       <span class="keywordflow">if</span> (mInteractions.testFlag(iSelectLegend))
<a name="l07413"></a>07413         selectionFound |= legend-&gt;handleLegendSelection(event, additiveSelection, emitChangedSignal);
<a name="l07414"></a>07414       <span class="comment">// Mouse selection of plottables:</span>
<a name="l07415"></a>07415       <span class="keywordflow">if</span> (mInteractions.testFlag(iSelectPlottables))
<a name="l07416"></a>07416         selectionFound |= handlePlottableSelection((!selectionFound || additiveSelection) ? <span class="keyword">event</span> : 0, additiveSelection, emitChangedSignal);
<a name="l07417"></a>07417       <span class="comment">// Mouse selection of axes:</span>
<a name="l07418"></a>07418       <span class="keywordflow">if</span> (mInteractions.testFlag(iSelectAxes))
<a name="l07419"></a>07419         selectionFound |= handleAxisSelection((!selectionFound || additiveSelection) ? <span class="keyword">event</span> : 0, additiveSelection, emitChangedSignal);
<a name="l07420"></a>07420       <span class="comment">// Mouse selection of title:</span>
<a name="l07421"></a>07421       <span class="keywordflow">if</span> (mInteractions.testFlag(iSelectTitle))
<a name="l07422"></a>07422         selectionFound |= handleTitleSelection((!selectionFound || additiveSelection) ? <span class="keyword">event</span> : 0, additiveSelection, emitChangedSignal);
<a name="l07423"></a>07423       
<a name="l07424"></a>07424       <span class="keywordflow">if</span> (emitChangedSignal)
<a name="l07425"></a>07425         emit selectionChangedByUser();
<a name="l07426"></a>07426       replot();
<a name="l07427"></a>07427     }
<a name="l07428"></a>07428     
<a name="l07429"></a>07429     <span class="comment">// emit specialized object click signals:</span>
<a name="l07430"></a>07430     <span class="keywordtype">bool</span> foundHit = <span class="keyword">false</span>;
<a name="l07431"></a>07431     <span class="comment">// for legend:</span>
<a name="l07432"></a>07432     <span class="keywordflow">if</span> (receivers(SIGNAL(legendClick(QCPLegend*,QCPAbstractLegendItem*,QMouseEvent*))) &gt; 0)
<a name="l07433"></a>07433     {
<a name="l07434"></a>07434       <span class="keywordflow">if</span> (legend-&gt;selectTestLegend(event-&gt;pos()))
<a name="l07435"></a>07435       {
<a name="l07436"></a>07436         emit legendClick(legend, legend-&gt;selectTestItem(event-&gt;pos()), event);
<a name="l07437"></a>07437         foundHit = <span class="keyword">true</span>;
<a name="l07438"></a>07438       }
<a name="l07439"></a>07439     }
<a name="l07440"></a>07440     <span class="comment">// for plottables:</span>
<a name="l07441"></a>07441     <span class="keywordflow">if</span> (!foundHit &amp;&amp; receivers(SIGNAL(plottableClick(QCPAbstractPlottable*,QMouseEvent*))) &gt; 0)
<a name="l07442"></a>07442     {
<a name="l07443"></a>07443       <span class="keywordflow">if</span> (QCPAbstractPlottable *ap = plottableAt(event-&gt;pos(), <span class="keyword">false</span>))
<a name="l07444"></a>07444       {
<a name="l07445"></a>07445         emit plottableClick(ap, event);
<a name="l07446"></a>07446         foundHit = <span class="keyword">true</span>;
<a name="l07447"></a>07447       }
<a name="l07448"></a>07448     }
<a name="l07449"></a>07449     <span class="comment">// for axes:</span>
<a name="l07450"></a>07450     <span class="keywordflow">if</span> (!foundHit &amp;&amp; receivers(SIGNAL(axisClick(QCPAxis*,QCPAxis::SelectablePart,QMouseEvent*))) &gt; 0)
<a name="l07451"></a>07451     {
<a name="l07452"></a>07452       QVector&lt;QCPAxis*&gt; axes = QVector&lt;QCPAxis*&gt;() &lt;&lt; xAxis &lt;&lt; yAxis &lt;&lt; xAxis2 &lt;&lt; yAxis2;
<a name="l07453"></a>07453       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;axes.size(); ++i)
<a name="l07454"></a>07454       {
<a name="l07455"></a>07455         QCPAxis::SelectablePart part = axes.at(i)-&gt;selectTest(event-&gt;pos());
<a name="l07456"></a>07456         <span class="keywordflow">if</span> (part != QCPAxis::spNone)
<a name="l07457"></a>07457         {
<a name="l07458"></a>07458           foundHit = <span class="keyword">true</span>;
<a name="l07459"></a>07459           emit axisClick(axes.at(i), part, event);
<a name="l07460"></a>07460           <span class="keywordflow">break</span>;
<a name="l07461"></a>07461         }
<a name="l07462"></a>07462       }
<a name="l07463"></a>07463     }
<a name="l07464"></a>07464     <span class="comment">// for title:</span>
<a name="l07465"></a>07465     <span class="keywordflow">if</span> (!foundHit &amp;&amp; receivers(SIGNAL(titleClick(QMouseEvent*))) &gt; 0)
<a name="l07466"></a>07466     {
<a name="l07467"></a>07467       <span class="keywordflow">if</span> (selectTestTitle(event-&gt;pos()))
<a name="l07468"></a>07468       {
<a name="l07469"></a>07469         emit titleClick(event);
<a name="l07470"></a>07470         foundHit = <span class="keyword">true</span>;
<a name="l07471"></a>07471       }
<a name="l07472"></a>07472     }
<a name="l07473"></a>07473   } <span class="comment">// was a click end</span>
<a name="l07474"></a>07474   
<a name="l07475"></a>07475   QWidget::mouseReleaseEvent(event);
<a name="l07476"></a>07476 }
<a name="l07477"></a>07477 
<a name="l07494"></a>07494 <span class="keywordtype">void</span> QCustomPlot::wheelEvent(QWheelEvent *event)
<a name="l07495"></a>07495 {
<a name="l07496"></a>07496   emit mouseWheel(event);
<a name="l07497"></a>07497   
<a name="l07498"></a>07498   <span class="comment">// Mouse range zooming interaction:</span>
<a name="l07499"></a>07499   <span class="keywordflow">if</span> (mInteractions.testFlag(iRangeZoom))
<a name="l07500"></a>07500   {
<a name="l07501"></a>07501     <span class="keywordflow">if</span> (mRangeZoom != 0)
<a name="l07502"></a>07502     {
<a name="l07503"></a>07503       <span class="keywordtype">double</span> factor;
<a name="l07504"></a>07504       <span class="keywordtype">double</span> wheelSteps = <span class="keyword">event</span>-&gt;delta()/120.0; <span class="comment">// a single step delta is +/-120 usually</span>
<a name="l07505"></a>07505       <span class="keywordflow">if</span> (mRangeZoom.testFlag(Qt::Horizontal))
<a name="l07506"></a>07506       {
<a name="l07507"></a>07507         factor = pow(mRangeZoomFactorHorz, wheelSteps);
<a name="l07508"></a>07508         mRangeZoomHorzAxis-&gt;scaleRange(factor, mRangeZoomHorzAxis-&gt;pixelToCoord(event-&gt;pos().x()));
<a name="l07509"></a>07509       }
<a name="l07510"></a>07510       <span class="keywordflow">if</span> (mRangeZoom.testFlag(Qt::Vertical))
<a name="l07511"></a>07511       {
<a name="l07512"></a>07512         factor = pow(mRangeZoomFactorVert, wheelSteps);
<a name="l07513"></a>07513         mRangeZoomVertAxis-&gt;scaleRange(factor, mRangeZoomVertAxis-&gt;pixelToCoord(event-&gt;pos().y()));
<a name="l07514"></a>07514       }
<a name="l07515"></a>07515       replot();
<a name="l07516"></a>07516     }
<a name="l07517"></a>07517   }
<a name="l07518"></a>07518   
<a name="l07519"></a>07519   QWidget::wheelEvent(event);
<a name="l07520"></a>07520 }
<a name="l07521"></a>07521 
<a name="l07539"></a>07539 <span class="keywordtype">bool</span> QCustomPlot::handlePlottableSelection(QMouseEvent *event, <span class="keywordtype">bool</span> additiveSelection, <span class="keywordtype">bool</span> &amp;modified)
<a name="l07540"></a>07540 {
<a name="l07541"></a>07541   <span class="keywordtype">bool</span> selectionFound = <span class="keyword">false</span>;
<a name="l07542"></a>07542   <span class="keywordflow">if</span> (event)
<a name="l07543"></a>07543   {
<a name="l07544"></a>07544     QCPAbstractPlottable *plottableSelection = plottableAt(event-&gt;pos(), <span class="keyword">true</span>);
<a name="l07545"></a>07545     <span class="comment">// handle selection of found plottable:</span>
<a name="l07546"></a>07546     <span class="keywordflow">if</span> (plottableSelection)
<a name="l07547"></a>07547     {
<a name="l07548"></a>07548       selectionFound = <span class="keyword">true</span>;
<a name="l07549"></a>07549       <span class="keywordflow">if</span> (!plottableSelection-&gt;selected() || additiveSelection)
<a name="l07550"></a>07550       {
<a name="l07551"></a>07551         plottableSelection-&gt;setSelected(!plottableSelection-&gt;selected());
<a name="l07552"></a>07552         modified = <span class="keyword">true</span>;
<a name="l07553"></a>07553       }
<a name="l07554"></a>07554     }
<a name="l07555"></a>07555     <span class="comment">// deselect all others (if plottableSelection is 0, all plottables are deselected):</span>
<a name="l07556"></a>07556     <span class="keywordflow">if</span> (!additiveSelection)
<a name="l07557"></a>07557     {
<a name="l07558"></a>07558       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mPlottables.size(); ++i)
<a name="l07559"></a>07559       {
<a name="l07560"></a>07560         <span class="keywordflow">if</span> (mPlottables.at(i) != plottableSelection &amp;&amp; mPlottables.at(i)-&gt;selected() &amp;&amp; mPlottables.at(i)-&gt;selectable())
<a name="l07561"></a>07561         {
<a name="l07562"></a>07562           mPlottables.at(i)-&gt;setSelected(<span class="keyword">false</span>);
<a name="l07563"></a>07563           modified = <span class="keyword">true</span>;
<a name="l07564"></a>07564         }
<a name="l07565"></a>07565       }
<a name="l07566"></a>07566     }
<a name="l07567"></a>07567   } <span class="keywordflow">else</span> <span class="comment">// event == 0, so deselect selectable plottables</span>
<a name="l07568"></a>07568   {
<a name="l07569"></a>07569     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mPlottables.size(); ++i)
<a name="l07570"></a>07570     {
<a name="l07571"></a>07571       <span class="keywordflow">if</span> (mPlottables.at(i)-&gt;selected() &amp;&amp; mPlottables.at(i)-&gt;selectable())
<a name="l07572"></a>07572       {
<a name="l07573"></a>07573         mPlottables.at(i)-&gt;setSelected(<span class="keyword">false</span>);
<a name="l07574"></a>07574         modified = <span class="keyword">true</span>;
<a name="l07575"></a>07575       }
<a name="l07576"></a>07576     }
<a name="l07577"></a>07577   }
<a name="l07578"></a>07578   <span class="keywordflow">return</span> selectionFound;
<a name="l07579"></a>07579 }
<a name="l07580"></a>07580 
<a name="l07593"></a>07593 <span class="keywordtype">bool</span> QCustomPlot::handleAxisSelection(QMouseEvent *event, <span class="keywordtype">bool</span> additiveSelection, <span class="keywordtype">bool</span> &amp;modified)
<a name="l07594"></a>07594 {
<a name="l07595"></a>07595   <span class="keywordtype">bool</span> selectionFound = <span class="keyword">false</span>;
<a name="l07596"></a>07596   QVector&lt;QCPAxis*&gt; axes = QVector&lt;QCPAxis*&gt;() &lt;&lt; xAxis &lt;&lt; yAxis &lt;&lt; xAxis2 &lt;&lt; yAxis2;
<a name="l07597"></a>07597   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;axes.size(); ++i)
<a name="l07598"></a>07598     selectionFound |= axes.at(i)-&gt;handleAxisSelection((!selectionFound || additiveSelection) ? event : 0, additiveSelection, modified);
<a name="l07599"></a>07599   <span class="keywordflow">return</span> selectionFound;
<a name="l07600"></a>07600 }
<a name="l07601"></a>07601 
<a name="l07614"></a>07614 <span class="keywordtype">bool</span> QCustomPlot::handleTitleSelection(QMouseEvent *event, <span class="keywordtype">bool</span> additiveSelection, <span class="keywordtype">bool</span> &amp;modified)
<a name="l07615"></a>07615 {
<a name="l07616"></a>07616   <span class="keywordtype">bool</span> selectionFound = <span class="keyword">false</span>;
<a name="l07617"></a>07617   <span class="keywordflow">if</span> (event &amp;&amp; selectTestTitle(event-&gt;pos())) <span class="comment">// hit, select title</span>
<a name="l07618"></a>07618   {
<a name="l07619"></a>07619     selectionFound = <span class="keyword">true</span>;
<a name="l07620"></a>07620     <span class="keywordflow">if</span> (!titleSelected() || additiveSelection)
<a name="l07621"></a>07621     {
<a name="l07622"></a>07622       setTitleSelected(!titleSelected());
<a name="l07623"></a>07623       modified = <span class="keyword">true</span>;
<a name="l07624"></a>07624     }
<a name="l07625"></a>07625   } <span class="keywordflow">else</span> <span class="comment">// no hit or event == 0, deselect title</span>
<a name="l07626"></a>07626   {
<a name="l07627"></a>07627     <span class="keywordflow">if</span> (titleSelected() &amp;&amp; !additiveSelection)
<a name="l07628"></a>07628     {
<a name="l07629"></a>07629       setTitleSelected(<span class="keyword">false</span>);
<a name="l07630"></a>07630       modified = <span class="keyword">true</span>;
<a name="l07631"></a>07631     }
<a name="l07632"></a>07632   }
<a name="l07633"></a>07633   <span class="keywordflow">return</span> selectionFound;
<a name="l07634"></a>07634 }
<a name="l07635"></a>07635 
<a name="l07642"></a>07642 <span class="keywordtype">void</span> QCustomPlot::draw(QPainter *painter)
<a name="l07643"></a>07643 {
<a name="l07644"></a>07644 
<a name="l07645"></a>07645   <span class="comment">// draw title:</span>
<a name="l07646"></a>07646   <span class="keywordflow">if</span> (!mTitle.isEmpty())
<a name="l07647"></a>07647   {
<a name="l07648"></a>07648     painter-&gt;setFont(titleSelected() ? mSelectedTitleFont : mTitleFont);
<a name="l07649"></a>07649     painter-&gt;setPen(QPen(titleSelected() ? mSelectedTitleColor : mTitleColor));
<a name="l07650"></a>07650     mTitleBoundingBox = painter-&gt;fontMetrics().boundingRect(mViewport, Qt::TextDontClip | Qt::AlignHCenter, mTitle);
<a name="l07651"></a>07651     painter-&gt;drawText(mTitleBoundingBox, Qt::TextDontClip | Qt::AlignHCenter, mTitle);
<a name="l07652"></a>07652   } <span class="keywordflow">else</span>
<a name="l07653"></a>07653     mTitleBoundingBox = QRect();
<a name="l07654"></a>07654   
<a name="l07655"></a>07655   <span class="comment">// prepare values of ticks and tick strings:</span>
<a name="l07656"></a>07656   xAxis-&gt;generateTickVectors();
<a name="l07657"></a>07657   yAxis-&gt;generateTickVectors();
<a name="l07658"></a>07658   xAxis2-&gt;generateTickVectors();
<a name="l07659"></a>07659   yAxis2-&gt;generateTickVectors();
<a name="l07660"></a>07660   
<a name="l07661"></a>07661   <span class="comment">// set auto margin such that tick/axis labels etc. are not clipped:</span>
<a name="l07662"></a>07662   <span class="keywordflow">if</span> (mAutoMargin)
<a name="l07663"></a>07663   {
<a name="l07664"></a>07664     setMargin(yAxis-&gt;calculateMargin(),
<a name="l07665"></a>07665               yAxis2-&gt;calculateMargin(),
<a name="l07666"></a>07666               xAxis2-&gt;calculateMargin()+mTitleBoundingBox.height(),
<a name="l07667"></a>07667               xAxis-&gt;calculateMargin());
<a name="l07668"></a>07668   }
<a name="l07669"></a>07669   
<a name="l07670"></a>07670   <span class="comment">// draw axis background:</span>
<a name="l07671"></a>07671   drawAxisBackground(painter);
<a name="l07672"></a>07672   
<a name="l07673"></a>07673   <span class="comment">// draw grids (and zerolines):</span>
<a name="l07674"></a>07674   xAxis-&gt;drawSubGrid(painter);
<a name="l07675"></a>07675   yAxis-&gt;drawSubGrid(painter);
<a name="l07676"></a>07676   xAxis2-&gt;drawSubGrid(painter);
<a name="l07677"></a>07677   yAxis2-&gt;drawSubGrid(painter);
<a name="l07678"></a>07678   xAxis-&gt;drawGrid(painter);
<a name="l07679"></a>07679   yAxis-&gt;drawGrid(painter);
<a name="l07680"></a>07680   xAxis2-&gt;drawGrid(painter);
<a name="l07681"></a>07681   yAxis2-&gt;drawGrid(painter);
<a name="l07682"></a>07682   
<a name="l07683"></a>07683   <span class="comment">// draw all plottables:</span>
<a name="l07684"></a>07684   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; mPlottables.size(); ++i)
<a name="l07685"></a>07685   {
<a name="l07686"></a>07686     painter-&gt;save(); <span class="comment">// since this might be user subclass, we save painter outside - just in case</span>
<a name="l07687"></a>07687     mPlottables.at(i)-&gt;draw(painter);
<a name="l07688"></a>07688     painter-&gt;restore();
<a name="l07689"></a>07689   }
<a name="l07690"></a>07690   
<a name="l07691"></a>07691   <span class="comment">// draw axes, ticks and axis labels:</span>
<a name="l07692"></a>07692   xAxis-&gt;drawAxis(painter);
<a name="l07693"></a>07693   yAxis-&gt;drawAxis(painter);
<a name="l07694"></a>07694   xAxis2-&gt;drawAxis(painter);
<a name="l07695"></a>07695   yAxis2-&gt;drawAxis(painter);
<a name="l07696"></a>07696   
<a name="l07697"></a>07697   <span class="comment">// draw legend:</span>
<a name="l07698"></a>07698   legend-&gt;reArrange();
<a name="l07699"></a>07699   legend-&gt;draw(painter);
<a name="l07700"></a>07700 }
<a name="l07701"></a>07701 
<a name="l07714"></a>07714 <span class="keywordtype">void</span> QCustomPlot::drawAxisBackground(QPainter *painter)
<a name="l07715"></a>07715 {
<a name="l07716"></a>07716   <span class="keywordflow">if</span> (!mAxisBackground.isNull())
<a name="l07717"></a>07717   {
<a name="l07718"></a>07718     <span class="keywordflow">if</span> (mAxisBackgroundScaled)
<a name="l07719"></a>07719     {
<a name="l07720"></a>07720       <span class="comment">// check whether mScaledAxisBackground needs to be updated:</span>
<a name="l07721"></a>07721       QSize scaledSize(mAxisBackground.size());
<a name="l07722"></a>07722       scaledSize.scale(mAxisRect.size(), mAxisBackgroundScaledMode);
<a name="l07723"></a>07723       <span class="keywordflow">if</span> (mScaledAxisBackground.size() != scaledSize)
<a name="l07724"></a>07724         mScaledAxisBackground = mAxisBackground.scaled(mAxisRect.size(), mAxisBackgroundScaledMode, Qt::SmoothTransformation);
<a name="l07725"></a>07725       painter-&gt;drawPixmap(mAxisRect.topLeft(), mScaledAxisBackground, QRect(0, 0, mAxisRect.width(), mAxisRect.height()) &amp; mScaledAxisBackground.rect());
<a name="l07726"></a>07726     } <span class="keywordflow">else</span>
<a name="l07727"></a>07727     {
<a name="l07728"></a>07728       painter-&gt;drawPixmap(mAxisRect.topLeft(), mAxisBackground, QRect(0, 0, mAxisRect.width(), mAxisRect.height()));
<a name="l07729"></a>07729     }
<a name="l07730"></a>07730   }
<a name="l07731"></a>07731 }
<a name="l07732"></a>07732 
<a name="l07740"></a>07740 <span class="keywordtype">void</span> QCustomPlot::updateAxisRect()
<a name="l07741"></a>07741 {
<a name="l07742"></a>07742   mAxisRect = mViewport.adjusted(mMarginLeft, mMarginTop, -mMarginRight, -mMarginBottom);
<a name="l07743"></a>07743   xAxis-&gt;setAxisRect(mAxisRect);
<a name="l07744"></a>07744   yAxis-&gt;setAxisRect(mAxisRect);
<a name="l07745"></a>07745   xAxis2-&gt;setAxisRect(mAxisRect);
<a name="l07746"></a>07746   yAxis2-&gt;setAxisRect(mAxisRect);
<a name="l07747"></a>07747 }
<a name="l07748"></a>07748 
<a name="l07753"></a>07753 <span class="keywordtype">bool</span> QCustomPlot::selectTestTitle(<span class="keyword">const</span> QPoint &amp;pos)<span class="keyword"> const</span>
<a name="l07754"></a>07754 <span class="keyword"></span>{
<a name="l07755"></a>07755   <span class="keywordflow">return</span> mTitleBoundingBox.contains(pos);
<a name="l07756"></a>07756 }
<a name="l07757"></a>07757 
<a name="l07758"></a>07758 
<a name="l07759"></a>07759 <span class="comment">// ================================================================================</span>
<a name="l07760"></a>07760 <span class="comment">// =================== QCPAbstractPlottable</span>
<a name="l07761"></a>07761 <span class="comment">// ================================================================================</span>
<a name="l07762"></a>07762 
<a name="l07831"></a>07831 <span class="comment">/* start of documentation of pure virtual functions */</span>
<a name="l07832"></a>07832 
<a name="l07904"></a>07904 <span class="comment">/* end of documentation of pure virtual functions */</span>
<a name="l07905"></a>07905 <span class="comment">/* start of documentation of signals */</span>
<a name="l07906"></a>07906 
<a name="l07912"></a>07912 <span class="comment">/* end of documentation of signals */</span>
<a name="l07913"></a>07913 
<a name="l07927"></a>07927 QCPAbstractPlottable::QCPAbstractPlottable(QCPAxis *keyAxis, QCPAxis *valueAxis) :
<a name="l07928"></a>07928   QObject(keyAxis-&gt;parentPlot()),
<a name="l07929"></a>07929   mParentPlot(keyAxis-&gt;parentPlot()),
<a name="l07930"></a>07930   mName(<span class="stringliteral">&quot;&quot;</span>),
<a name="l07931"></a>07931   mVisible(true),
<a name="l07932"></a>07932   mPen(Qt::black),
<a name="l07933"></a>07933   mSelectedPen(Qt::black),
<a name="l07934"></a>07934   mBrush(Qt::NoBrush),
<a name="l07935"></a>07935   mSelectedBrush(Qt::NoBrush),
<a name="l07936"></a>07936   mKeyAxis(keyAxis),
<a name="l07937"></a>07937   mValueAxis(valueAxis),
<a name="l07938"></a>07938   mSelected(false),
<a name="l07939"></a>07939   mSelectable(true)
<a name="l07940"></a>07940 {
<a name="l07941"></a>07941   <span class="keywordflow">if</span> (keyAxis-&gt;parentPlot() != valueAxis-&gt;parentPlot())
<a name="l07942"></a>07942     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;Parent plot of keyAxis is not the same as that of valueAxis.&quot;</span>;
<a name="l07943"></a>07943   <span class="keywordflow">if</span> (keyAxis-&gt;orientation() == valueAxis-&gt;orientation())
<a name="l07944"></a>07944     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;keyAxis and valueAxis must be orthogonal to each other.&quot;</span>;
<a name="l07945"></a>07945 }
<a name="l07946"></a>07946 
<a name="l07951"></a>07951 <span class="keywordtype">void</span> QCPAbstractPlottable::setName(<span class="keyword">const</span> QString &amp;name)
<a name="l07952"></a>07952 {
<a name="l07953"></a>07953   mName = name;
<a name="l07954"></a>07954 }
<a name="l07955"></a>07955 
<a name="l07960"></a>07960 <span class="keywordtype">void</span> QCPAbstractPlottable::setVisible(<span class="keywordtype">bool</span> visible)
<a name="l07961"></a>07961 {
<a name="l07962"></a>07962   mVisible = visible;
<a name="l07963"></a>07963 }
<a name="l07964"></a>07964 
<a name="l07974"></a>07974 <span class="keywordtype">void</span> QCPAbstractPlottable::setPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l07975"></a>07975 {
<a name="l07976"></a>07976   mPen = pen;
<a name="l07977"></a>07977 }
<a name="l07978"></a>07978 
<a name="l07985"></a>07985 <span class="keywordtype">void</span> QCPAbstractPlottable::setSelectedPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l07986"></a>07986 {
<a name="l07987"></a>07987   mSelectedPen = pen;
<a name="l07988"></a>07988 }
<a name="l07989"></a>07989 
<a name="l07999"></a>07999 <span class="keywordtype">void</span> QCPAbstractPlottable::setBrush(<span class="keyword">const</span> QBrush &amp;brush)
<a name="l08000"></a>08000 {
<a name="l08001"></a>08001   mBrush = brush;
<a name="l08002"></a>08002 }
<a name="l08003"></a>08003 
<a name="l08010"></a>08010 <span class="keywordtype">void</span> QCPAbstractPlottable::setSelectedBrush(<span class="keyword">const</span> QBrush &amp;brush)
<a name="l08011"></a>08011 {
<a name="l08012"></a>08012   mSelectedBrush = brush;
<a name="l08013"></a>08013 }
<a name="l08014"></a>08014 
<a name="l08026"></a>08026 <span class="keywordtype">void</span> QCPAbstractPlottable::setKeyAxis(QCPAxis *axis)
<a name="l08027"></a>08027 {
<a name="l08028"></a>08028   mKeyAxis = axis;
<a name="l08029"></a>08029 }
<a name="l08030"></a>08030 
<a name="l08042"></a>08042 <span class="keywordtype">void</span> QCPAbstractPlottable::setValueAxis(QCPAxis *axis)
<a name="l08043"></a>08043 {
<a name="l08044"></a>08044   mValueAxis = axis;
<a name="l08045"></a>08045 }
<a name="l08046"></a>08046 
<a name="l08056"></a>08056 <span class="keywordtype">void</span> QCPAbstractPlottable::setSelectable(<span class="keywordtype">bool</span> selectable)
<a name="l08057"></a>08057 {
<a name="l08058"></a>08058   mSelectable = selectable;
<a name="l08059"></a>08059 }
<a name="l08060"></a>08060 
<a name="l08075"></a>08075 <span class="keywordtype">void</span> QCPAbstractPlottable::setSelected(<span class="keywordtype">bool</span> selected)
<a name="l08076"></a>08076 {
<a name="l08077"></a>08077   <span class="keywordflow">if</span> (mSelected != selected)
<a name="l08078"></a>08078   {
<a name="l08079"></a>08079     mSelected = selected;
<a name="l08080"></a>08080     emit selectionChanged(mSelected);
<a name="l08081"></a>08081   }
<a name="l08082"></a>08082 }
<a name="l08083"></a>08083 
<a name="l08095"></a>08095 <span class="keywordtype">void</span> QCPAbstractPlottable::rescaleAxes(<span class="keywordtype">bool</span> onlyEnlarge)<span class="keyword"> const</span>
<a name="l08096"></a>08096 <span class="keyword"></span>{
<a name="l08097"></a>08097   rescaleKeyAxis(onlyEnlarge);
<a name="l08098"></a>08098   rescaleValueAxis(onlyEnlarge);
<a name="l08099"></a>08099 }
<a name="l08100"></a>08100 
<a name="l08106"></a>08106 <span class="keywordtype">void</span> QCPAbstractPlottable::rescaleKeyAxis(<span class="keywordtype">bool</span> onlyEnlarge)<span class="keyword"> const</span>
<a name="l08107"></a>08107 <span class="keyword"></span>{
<a name="l08108"></a>08108   SignDomain signDomain = sdBoth;
<a name="l08109"></a>08109   <span class="keywordflow">if</span> (mKeyAxis-&gt;scaleType() == QCPAxis::stLogarithmic)
<a name="l08110"></a>08110     signDomain = (mKeyAxis-&gt;range().upper &lt; 0 ? sdNegative : sdPositive);
<a name="l08111"></a>08111   
<a name="l08112"></a>08112   <span class="keywordtype">bool</span> validRange;
<a name="l08113"></a>08113   QCPRange newRange = getKeyRange(validRange, signDomain);
<a name="l08114"></a>08114   
<a name="l08115"></a>08115   <span class="keywordflow">if</span> (validRange)
<a name="l08116"></a>08116   {
<a name="l08117"></a>08117     <span class="keywordflow">if</span> (onlyEnlarge)
<a name="l08118"></a>08118     {
<a name="l08119"></a>08119       <span class="keywordflow">if</span> (mKeyAxis-&gt;range().lower &lt; newRange.lower)
<a name="l08120"></a>08120         newRange.lower = mKeyAxis-&gt;range().lower;
<a name="l08121"></a>08121       <span class="keywordflow">if</span> (mKeyAxis-&gt;range().upper &gt; newRange.upper)
<a name="l08122"></a>08122         newRange.upper = mKeyAxis-&gt;range().upper;
<a name="l08123"></a>08123     }
<a name="l08124"></a>08124     mKeyAxis-&gt;setRange(newRange);
<a name="l08125"></a>08125   }
<a name="l08126"></a>08126 }
<a name="l08127"></a>08127 
<a name="l08133"></a>08133 <span class="keywordtype">void</span> QCPAbstractPlottable::rescaleValueAxis(<span class="keywordtype">bool</span> onlyEnlarge)<span class="keyword"> const</span>
<a name="l08134"></a>08134 <span class="keyword"></span>{
<a name="l08135"></a>08135   SignDomain signDomain = sdBoth;
<a name="l08136"></a>08136   <span class="keywordflow">if</span> (mValueAxis-&gt;scaleType() == QCPAxis::stLogarithmic)
<a name="l08137"></a>08137     signDomain = (mValueAxis-&gt;range().upper &lt; 0 ? sdNegative : sdPositive);
<a name="l08138"></a>08138   
<a name="l08139"></a>08139   <span class="keywordtype">bool</span> validRange;
<a name="l08140"></a>08140   QCPRange newRange = getValueRange(validRange, signDomain);
<a name="l08141"></a>08141   
<a name="l08142"></a>08142   <span class="keywordflow">if</span> (validRange)
<a name="l08143"></a>08143   {
<a name="l08144"></a>08144     <span class="keywordflow">if</span> (onlyEnlarge)
<a name="l08145"></a>08145     {
<a name="l08146"></a>08146       <span class="keywordflow">if</span> (mValueAxis-&gt;range().lower &lt; newRange.lower)
<a name="l08147"></a>08147         newRange.lower = mValueAxis-&gt;range().lower;
<a name="l08148"></a>08148       <span class="keywordflow">if</span> (mValueAxis-&gt;range().upper &gt; newRange.upper)
<a name="l08149"></a>08149         newRange.upper = mValueAxis-&gt;range().upper;
<a name="l08150"></a>08150     }
<a name="l08151"></a>08151     mValueAxis-&gt;setRange(newRange);
<a name="l08152"></a>08152   }
<a name="l08153"></a>08153 }
<a name="l08154"></a>08154 
<a name="l08167"></a>08167 <span class="keywordtype">bool</span> QCPAbstractPlottable::addToLegend()
<a name="l08168"></a>08168 {
<a name="l08169"></a>08169   <span class="keywordflow">if</span> (!mParentPlot-&gt;legend-&gt;hasItemWithPlottable(<span class="keyword">this</span>))
<a name="l08170"></a>08170   {
<a name="l08171"></a>08171     mParentPlot-&gt;legend-&gt;addItem(<span class="keyword">new</span> QCPPlottableLegendItem(mParentPlot-&gt;legend, <span class="keyword">this</span>));
<a name="l08172"></a>08172     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l08173"></a>08173   } <span class="keywordflow">else</span>
<a name="l08174"></a>08174     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l08175"></a>08175 }
<a name="l08176"></a>08176 
<a name="l08187"></a>08187 <span class="keywordtype">bool</span> QCPAbstractPlottable::removeFromLegend()<span class="keyword"> const</span>
<a name="l08188"></a>08188 <span class="keyword"></span>{
<a name="l08189"></a>08189   <span class="keywordflow">if</span> (QCPPlottableLegendItem *lip = mParentPlot-&gt;legend-&gt;itemWithPlottable(<span class="keyword">this</span>))
<a name="l08190"></a>08190     <span class="keywordflow">return</span> mParentPlot-&gt;legend-&gt;removeItem(lip);
<a name="l08191"></a>08191   <span class="keywordflow">else</span>
<a name="l08192"></a>08192     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l08193"></a>08193 }
<a name="l08194"></a>08194 
<a name="l08205"></a>08205 <span class="keywordtype">void</span> QCPAbstractPlottable::coordsToPixels(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value, <span class="keywordtype">double</span> &amp;x, <span class="keywordtype">double</span> &amp;y)<span class="keyword"> const</span>
<a name="l08206"></a>08206 <span class="keyword"></span>{
<a name="l08207"></a>08207   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Horizontal)
<a name="l08208"></a>08208   {
<a name="l08209"></a>08209     x = mKeyAxis-&gt;coordToPixel(key);
<a name="l08210"></a>08210     y = mValueAxis-&gt;coordToPixel(value);
<a name="l08211"></a>08211   } <span class="keywordflow">else</span>
<a name="l08212"></a>08212   {
<a name="l08213"></a>08213     y = mKeyAxis-&gt;coordToPixel(key);
<a name="l08214"></a>08214     x = mValueAxis-&gt;coordToPixel(value);
<a name="l08215"></a>08215   }
<a name="l08216"></a>08216 }
<a name="l08217"></a>08217 
<a name="l08223"></a>08223 <span class="keyword">const</span> QPointF QCPAbstractPlottable::coordsToPixels(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l08224"></a>08224 <span class="keyword"></span>{
<a name="l08225"></a>08225   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Horizontal)
<a name="l08226"></a>08226     <span class="keywordflow">return</span> QPointF(mKeyAxis-&gt;coordToPixel(key), mValueAxis-&gt;coordToPixel(value));
<a name="l08227"></a>08227   <span class="keywordflow">else</span>
<a name="l08228"></a>08228     <span class="keywordflow">return</span> QPointF(mValueAxis-&gt;coordToPixel(value), mKeyAxis-&gt;coordToPixel(key));
<a name="l08229"></a>08229 }
<a name="l08230"></a>08230 
<a name="l08241"></a>08241 <span class="keywordtype">void</span> QCPAbstractPlottable::pixelsToCoords(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> &amp;key, <span class="keywordtype">double</span> &amp;value)<span class="keyword"> const</span>
<a name="l08242"></a>08242 <span class="keyword"></span>{
<a name="l08243"></a>08243   <span class="keywordflow">if</span> (mKeyAxis-&gt;orientation() == Qt::Horizontal)
<a name="l08244"></a>08244   {
<a name="l08245"></a>08245     key = mKeyAxis-&gt;pixelToCoord(x);
<a name="l08246"></a>08246     value = mValueAxis-&gt;pixelToCoord(y);
<a name="l08247"></a>08247   } <span class="keywordflow">else</span>
<a name="l08248"></a>08248   {
<a name="l08249"></a>08249     key = mKeyAxis-&gt;pixelToCoord(y);
<a name="l08250"></a>08250     value = mValueAxis-&gt;pixelToCoord(x);
<a name="l08251"></a>08251   }
<a name="l08252"></a>08252 }
<a name="l08253"></a>08253 
<a name="l08259"></a>08259 <span class="keywordtype">void</span> QCPAbstractPlottable::pixelsToCoords(<span class="keyword">const</span> QPointF &amp;pixelPos, <span class="keywordtype">double</span> &amp;key, <span class="keywordtype">double</span> &amp;value)<span class="keyword"> const</span>
<a name="l08260"></a>08260 <span class="keyword"></span>{
<a name="l08261"></a>08261   pixelsToCoords(pixelPos.x(), pixelPos.y(), key, value);
<a name="l08262"></a>08262 }
<a name="l08263"></a>08263 
<a name="l08269"></a>08269 QPen QCPAbstractPlottable::mainPen()<span class="keyword"> const</span>
<a name="l08270"></a>08270 <span class="keyword"></span>{
<a name="l08271"></a>08271   <span class="keywordflow">return</span> mSelected ? mSelectedPen : mPen;
<a name="l08272"></a>08272 }
<a name="l08273"></a>08273 
<a name="l08279"></a>08279 QBrush QCPAbstractPlottable::mainBrush()<span class="keyword"> const</span>
<a name="l08280"></a>08280 <span class="keyword"></span>{
<a name="l08281"></a>08281   <span class="keywordflow">return</span> mSelected ? mSelectedBrush : mBrush;
<a name="l08282"></a>08282 }
<a name="l08283"></a>08283 
<a name="l08284"></a>08284 
<a name="l08285"></a>08285 <span class="comment">// ================================================================================</span>
<a name="l08286"></a>08286 <span class="comment">// =================== QCPAbstractLegendItem</span>
<a name="l08287"></a>08287 <span class="comment">// ================================================================================</span>
<a name="l08288"></a>08288 
<a name="l08314"></a>08314 <span class="comment">/* start documentation of pure virtual functions */</span>
<a name="l08315"></a>08315 
<a name="l08330"></a>08330 <span class="comment">/* end documentation of pure virtual functions */</span>
<a name="l08331"></a>08331 <span class="comment">/* start of documentation of signals */</span>
<a name="l08332"></a>08332 
<a name="l08339"></a>08339 <span class="comment">/* end of documentation of signals */</span>
<a name="l08340"></a>08340 
<a name="l08345"></a>08345 QCPAbstractLegendItem::QCPAbstractLegendItem(QCPLegend *parent) : 
<a name="l08346"></a>08346   QObject(parent),
<a name="l08347"></a>08347   mParentLegend(parent),
<a name="l08348"></a>08348   mFont(parent-&gt;font()),
<a name="l08349"></a>08349   mTextColor(parent-&gt;textColor()),
<a name="l08350"></a>08350   mSelectedFont(parent-&gt;selectedFont()),
<a name="l08351"></a>08351   mSelectedTextColor(parent-&gt;selectedTextColor()),
<a name="l08352"></a>08352   mSelectable(true),
<a name="l08353"></a>08353   mSelected(false)
<a name="l08354"></a>08354 {
<a name="l08355"></a>08355 }
<a name="l08356"></a>08356 
<a name="l08362"></a>08362 <span class="keywordtype">void</span> QCPAbstractLegendItem::setFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l08363"></a>08363 {
<a name="l08364"></a>08364   mFont = font;
<a name="l08365"></a>08365 }
<a name="l08366"></a>08366 
<a name="l08372"></a>08372 <span class="keywordtype">void</span> QCPAbstractLegendItem::setTextColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l08373"></a>08373 {
<a name="l08374"></a>08374   mTextColor = color;
<a name="l08375"></a>08375 }
<a name="l08376"></a>08376 
<a name="l08383"></a>08383 <span class="keywordtype">void</span> QCPAbstractLegendItem::setSelectedFont(<span class="keyword">const</span> QFont &amp;font)
<a name="l08384"></a>08384 {
<a name="l08385"></a>08385   mSelectedFont = font;
<a name="l08386"></a>08386 }
<a name="l08387"></a>08387 
<a name="l08394"></a>08394 <span class="keywordtype">void</span> QCPAbstractLegendItem::setSelectedTextColor(<span class="keyword">const</span> QColor &amp;color)
<a name="l08395"></a>08395 {
<a name="l08396"></a>08396   mSelectedTextColor = color;
<a name="l08397"></a>08397 }
<a name="l08398"></a>08398 
<a name="l08404"></a>08404 <span class="keywordtype">void</span> QCPAbstractLegendItem::setSelectable(<span class="keywordtype">bool</span> selectable)
<a name="l08405"></a>08405 {
<a name="l08406"></a>08406   mSelectable = selectable;
<a name="l08407"></a>08407 }
<a name="l08408"></a>08408 
<a name="l08418"></a>08418 <span class="keywordtype">void</span> QCPAbstractLegendItem::setSelected(<span class="keywordtype">bool</span> selected)
<a name="l08419"></a>08419 {
<a name="l08420"></a>08420   <span class="keywordflow">if</span> (mSelected != selected)
<a name="l08421"></a>08421   {
<a name="l08422"></a>08422     mSelected = selected;
<a name="l08423"></a>08423     emit selectionChanged(mSelected);
<a name="l08424"></a>08424     mParentLegend-&gt;updateSelectionState();
<a name="l08425"></a>08425   }
<a name="l08426"></a>08426 }
<a name="l08427"></a>08427 
<a name="l08428"></a>08428 
<a name="l08429"></a>08429 <span class="comment">// ================================================================================</span>
<a name="l08430"></a>08430 <span class="comment">// =================== QCPPlottableLegendItem</span>
<a name="l08431"></a>08431 <span class="comment">// ================================================================================</span>
<a name="l08462"></a>08462 <span class="comment"></span>QCPPlottableLegendItem::QCPPlottableLegendItem(QCPLegend *parent, QCPAbstractPlottable *plottable) :
<a name="l08463"></a>08463   QCPAbstractLegendItem(parent),
<a name="l08464"></a>08464   mPlottable(plottable)
<a name="l08465"></a>08465 {
<a name="l08466"></a>08466   mTextWrap = <span class="keyword">false</span>;
<a name="l08467"></a>08467 }
<a name="l08468"></a>08468 
<a name="l08477"></a>08477 <span class="keywordtype">void</span> QCPPlottableLegendItem::setTextWrap(<span class="keywordtype">bool</span> wrap)
<a name="l08478"></a>08478 {
<a name="l08479"></a>08479   mTextWrap = wrap;
<a name="l08480"></a>08480 }
<a name="l08481"></a>08481 
<a name="l08487"></a>08487 QPen QCPPlottableLegendItem::getIconBorderPen()<span class="keyword"> const</span>
<a name="l08488"></a>08488 <span class="keyword"></span>{
<a name="l08489"></a>08489   <span class="keywordflow">return</span> mSelected ? mParentLegend-&gt;selectedIconBorderPen() : mParentLegend-&gt;iconBorderPen();
<a name="l08490"></a>08490 }
<a name="l08491"></a>08491 
<a name="l08497"></a>08497 QColor QCPPlottableLegendItem::getTextColor()<span class="keyword"> const</span>
<a name="l08498"></a>08498 <span class="keyword"></span>{
<a name="l08499"></a>08499   <span class="keywordflow">return</span> mSelected ? mSelectedTextColor : mTextColor;
<a name="l08500"></a>08500 }
<a name="l08501"></a>08501 
<a name="l08507"></a>08507 QFont QCPPlottableLegendItem::getFont()<span class="keyword"> const</span>
<a name="l08508"></a>08508 <span class="keyword"></span>{
<a name="l08509"></a>08509   <span class="keywordflow">return</span> mSelected ? mSelectedFont : mFont;
<a name="l08510"></a>08510 }
<a name="l08511"></a>08511 
<a name="l08522"></a>08522 <span class="keywordtype">void</span> QCPPlottableLegendItem::draw(QPainter *painter, <span class="keyword">const</span> QRect &amp;rect)<span class="keyword"> const</span>
<a name="l08523"></a>08523 <span class="keyword"></span>{
<a name="l08524"></a>08524   <span class="keywordflow">if</span> (!mPlottable) <span class="keywordflow">return</span>;
<a name="l08525"></a>08525   painter-&gt;setFont(getFont());
<a name="l08526"></a>08526   painter-&gt;setPen(QPen(getTextColor()));
<a name="l08527"></a>08527   <span class="keywordtype">int</span> iconTextPadding = mParentLegend-&gt;iconTextPadding();
<a name="l08528"></a>08528   QSize iconSize = mParentLegend-&gt;iconSize();
<a name="l08529"></a>08529   QRect textRect;
<a name="l08530"></a>08530   QRect iconRect(rect.topLeft(), iconSize);
<a name="l08531"></a>08531   <span class="keywordflow">if</span> (mTextWrap)
<a name="l08532"></a>08532   {
<a name="l08533"></a>08533     <span class="comment">// take width from rect since our text should wrap there (only icon must fit at least):</span>
<a name="l08534"></a>08534     textRect = painter-&gt;fontMetrics().boundingRect(0, 0, rect.width()-iconTextPadding-iconSize.width(), rect.height(), Qt::TextDontClip | Qt::TextWordWrap, mPlottable-&gt;name());
<a name="l08535"></a>08535     <span class="keywordflow">if</span> (textRect.height() &lt; iconSize.height()) <span class="comment">// text smaller than icon, center text vertically in icon height</span>
<a name="l08536"></a>08536     {
<a name="l08537"></a>08537       painter-&gt;drawText(rect.x()+iconSize.width()+iconTextPadding, rect.y(), rect.width()-iconTextPadding-iconSize.width(), iconSize.height(), Qt::TextDontClip | Qt::TextWordWrap, mPlottable-&gt;name());
<a name="l08538"></a>08538     } <span class="keywordflow">else</span> <span class="comment">// text bigger than icon, position top of text with top of icon</span>
<a name="l08539"></a>08539     {
<a name="l08540"></a>08540       painter-&gt;drawText(rect.x()+iconSize.width()+iconTextPadding, rect.y(), rect.width()-iconTextPadding-iconSize.width(), textRect.height(), Qt::TextDontClip | Qt::TextWordWrap, mPlottable-&gt;name());
<a name="l08541"></a>08541     }
<a name="l08542"></a>08542   } <span class="keywordflow">else</span>
<a name="l08543"></a>08543   {
<a name="l08544"></a>08544     <span class="comment">// text can&#39;t wrap (except with explicit newlines), center at current item size (icon size)</span>
<a name="l08545"></a>08545     textRect = painter-&gt;fontMetrics().boundingRect(0, 0, 0, rect.height(), Qt::TextDontClip, mPlottable-&gt;name());
<a name="l08546"></a>08546     <span class="keywordflow">if</span> (textRect.height() &lt; iconSize.height()) <span class="comment">// text smaller than icon, center text vertically in icon height</span>
<a name="l08547"></a>08547     {
<a name="l08548"></a>08548       painter-&gt;drawText(rect.x()+iconSize.width()+iconTextPadding, rect.y(), rect.width(), iconSize.height(), Qt::TextDontClip, mPlottable-&gt;name());
<a name="l08549"></a>08549     } <span class="keywordflow">else</span> <span class="comment">// text bigger than icon, position top of text with top of icon</span>
<a name="l08550"></a>08550     {
<a name="l08551"></a>08551       painter-&gt;drawText(rect.x()+iconSize.width()+iconTextPadding, rect.y(), rect.width(), textRect.height(), Qt::TextDontClip, mPlottable-&gt;name());
<a name="l08552"></a>08552     }
<a name="l08553"></a>08553   }
<a name="l08554"></a>08554   <span class="comment">// draw icon:</span>
<a name="l08555"></a>08555   painter-&gt;save();
<a name="l08556"></a>08556   painter-&gt;setClipRect(iconRect, Qt::IntersectClip);
<a name="l08557"></a>08557   mPlottable-&gt;drawLegendIcon(painter, iconRect);
<a name="l08558"></a>08558   painter-&gt;restore();
<a name="l08559"></a>08559   <span class="comment">// draw icon border:</span>
<a name="l08560"></a>08560   <span class="keywordflow">if</span> (getIconBorderPen().style() != Qt::NoPen)
<a name="l08561"></a>08561   {
<a name="l08562"></a>08562     painter-&gt;setPen(getIconBorderPen());
<a name="l08563"></a>08563     painter-&gt;setBrush(Qt::NoBrush);
<a name="l08564"></a>08564     painter-&gt;drawRect(iconRect);
<a name="l08565"></a>08565   }
<a name="l08566"></a>08566 }
<a name="l08567"></a>08567 
<a name="l08579"></a>08579 QSize QCPPlottableLegendItem::size(<span class="keyword">const</span> QSize &amp;targetSize)<span class="keyword"> const</span>
<a name="l08580"></a>08580 <span class="keyword"></span>{
<a name="l08581"></a>08581   <span class="keywordflow">if</span> (!mPlottable) <span class="keywordflow">return</span> QSize();
<a name="l08582"></a>08582   QSize result(0, 0);
<a name="l08583"></a>08583   QRect textRect;
<a name="l08584"></a>08584   QFontMetrics fontMetrics(getFont());
<a name="l08585"></a>08585   <span class="keywordtype">int</span> iconTextPadding = mParentLegend-&gt;iconTextPadding();
<a name="l08586"></a>08586   QSize iconSize = mParentLegend-&gt;iconSize();
<a name="l08587"></a>08587   <span class="keywordflow">if</span> (mTextWrap)
<a name="l08588"></a>08588   {
<a name="l08589"></a>08589     <span class="comment">// take width from targetSize since our text can wrap (Only icon must fit at least):</span>
<a name="l08590"></a>08590     textRect = fontMetrics.boundingRect(0, 0, targetSize.width()-iconTextPadding-iconSize.width(), iconSize.height(), Qt::TextDontClip | Qt::TextWordWrap, mPlottable-&gt;name());
<a name="l08591"></a>08591   } <span class="keywordflow">else</span>
<a name="l08592"></a>08592   {
<a name="l08593"></a>08593     <span class="comment">// text can&#39;t wrap (except with explicit newlines), center at current item size (icon size)</span>
<a name="l08594"></a>08594     textRect = fontMetrics.boundingRect(0, 0, 0, iconSize.height(), Qt::TextDontClip, mPlottable-&gt;name());
<a name="l08595"></a>08595   }
<a name="l08596"></a>08596   result.setWidth(iconSize.width() + mParentLegend-&gt;iconTextPadding() + textRect.width());
<a name="l08597"></a>08597   result.setHeight(qMax(textRect.height(), iconSize.height()));
<a name="l08598"></a>08598   <span class="keywordflow">return</span> result;
<a name="l08599"></a>08599 }
<a name="l08600"></a>08600 
<a name="l08601"></a>08601 <span class="comment">// ================================================================================</span>
<a name="l08602"></a>08602 <span class="comment">// =================== QCPCurve</span>
<a name="l08603"></a>08603 <span class="comment">// ================================================================================</span>
<a name="l08638"></a>08638 <span class="comment"></span>QCPCurve::QCPCurve(QCPAxis *keyAxis, QCPAxis *valueAxis) :
<a name="l08639"></a>08639   QCPAbstractPlottable(keyAxis, valueAxis)
<a name="l08640"></a>08640 {
<a name="l08641"></a>08641   mData = <span class="keyword">new</span> QCPCurveDataMap;
<a name="l08642"></a>08642   mPen.setColor(Qt::blue);
<a name="l08643"></a>08643   mPen.setStyle(Qt::SolidLine);
<a name="l08644"></a>08644   mBrush.setColor(Qt::blue);
<a name="l08645"></a>08645   mBrush.setStyle(Qt::NoBrush);
<a name="l08646"></a>08646   mSelectedPen = mPen;
<a name="l08647"></a>08647   mSelectedPen.setWidthF(2.5);
<a name="l08648"></a>08648   mSelectedPen.setColor(QColor(80, 80, 255)); <span class="comment">// lighter than Qt::blue of mPen</span>
<a name="l08649"></a>08649   mSelectedBrush = mBrush;
<a name="l08650"></a>08650 }
<a name="l08651"></a>08651 
<a name="l08652"></a>08652 QCPCurve::~QCPCurve()
<a name="l08653"></a>08653 {
<a name="l08654"></a>08654   <span class="keyword">delete</span> mData;
<a name="l08655"></a>08655 }
<a name="l08656"></a>08656 
<a name="l08664"></a>08664 <span class="keywordtype">void</span> QCPCurve::setData(QCPCurveDataMap *data, <span class="keywordtype">bool</span> copy)
<a name="l08665"></a>08665 {
<a name="l08666"></a>08666   <span class="keywordflow">if</span> (copy)
<a name="l08667"></a>08667   {
<a name="l08668"></a>08668     *mData = *data;
<a name="l08669"></a>08669   } <span class="keywordflow">else</span>
<a name="l08670"></a>08670   {
<a name="l08671"></a>08671     <span class="keyword">delete</span> mData;
<a name="l08672"></a>08672     mData = data;
<a name="l08673"></a>08673   }
<a name="l08674"></a>08674 }
<a name="l08675"></a>08675 
<a name="l08682"></a>08682 <span class="keywordtype">void</span> QCPCurve::setData(<span class="keyword">const</span> QVector&lt;double&gt; &amp;t, <span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value)
<a name="l08683"></a>08683 {
<a name="l08684"></a>08684   mData-&gt;clear();
<a name="l08685"></a>08685   <span class="keywordtype">int</span> n = t.size();
<a name="l08686"></a>08686   n = qMin(n, key.size());
<a name="l08687"></a>08687   n = qMin(n, value.size());
<a name="l08688"></a>08688   QCPCurveData newData;
<a name="l08689"></a>08689   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l08690"></a>08690   {
<a name="l08691"></a>08691     newData.t = t[i];
<a name="l08692"></a>08692     newData.key = key[i];
<a name="l08693"></a>08693     newData.value = value[i];
<a name="l08694"></a>08694     mData-&gt;insertMulti(newData.t, newData);
<a name="l08695"></a>08695   }
<a name="l08696"></a>08696 }
<a name="l08697"></a>08697 
<a name="l08703"></a>08703 <span class="keywordtype">void</span> QCPCurve::setData(<span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value)
<a name="l08704"></a>08704 {
<a name="l08705"></a>08705   mData-&gt;clear();
<a name="l08706"></a>08706   <span class="keywordtype">int</span> n = key.size();
<a name="l08707"></a>08707   n = qMin(n, value.size());
<a name="l08708"></a>08708   QCPCurveData newData;
<a name="l08709"></a>08709   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l08710"></a>08710   {
<a name="l08711"></a>08711     newData.t = i; <span class="comment">// no t vector given, so we assign t the index of the key/value pair</span>
<a name="l08712"></a>08712     newData.key = key[i];
<a name="l08713"></a>08713     newData.value = value[i];
<a name="l08714"></a>08714     mData-&gt;insertMulti(newData.t, newData);
<a name="l08715"></a>08715   }
<a name="l08716"></a>08716 }
<a name="l08717"></a>08717 
<a name="l08722"></a>08722 <span class="keywordtype">void</span> QCPCurve::addData(<span class="keyword">const</span> QCPCurveDataMap &amp;dataMap)
<a name="l08723"></a>08723 {
<a name="l08724"></a>08724   mData-&gt;unite(dataMap);
<a name="l08725"></a>08725 }
<a name="l08726"></a>08726 
<a name="l08731"></a>08731 <span class="keywordtype">void</span> QCPCurve::addData(<span class="keyword">const</span> QCPCurveData &amp;data)
<a name="l08732"></a>08732 {
<a name="l08733"></a>08733   mData-&gt;insertMulti(data.t, data);
<a name="l08734"></a>08734 }
<a name="l08735"></a>08735 
<a name="l08740"></a>08740 <span class="keywordtype">void</span> QCPCurve::addData(<span class="keywordtype">double</span> t, <span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)
<a name="l08741"></a>08741 {
<a name="l08742"></a>08742   QCPCurveData newData;
<a name="l08743"></a>08743   newData.t = t;
<a name="l08744"></a>08744   newData.key = key;
<a name="l08745"></a>08745   newData.value = value;
<a name="l08746"></a>08746   mData-&gt;insertMulti(newData.t, newData);
<a name="l08747"></a>08747 }
<a name="l08748"></a>08748 
<a name="l08757"></a>08757 <span class="keywordtype">void</span> QCPCurve::addData(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)
<a name="l08758"></a>08758 {
<a name="l08759"></a>08759   QCPCurveData newData;
<a name="l08760"></a>08760   <span class="keywordflow">if</span> (!mData-&gt;isEmpty())
<a name="l08761"></a>08761     newData.t = (mData-&gt;constEnd()-1).key()+1;
<a name="l08762"></a>08762   <span class="keywordflow">else</span>
<a name="l08763"></a>08763     newData.t = 0;
<a name="l08764"></a>08764   newData.key = key;
<a name="l08765"></a>08765   newData.value = value;
<a name="l08766"></a>08766   mData-&gt;insertMulti(newData.t, newData);
<a name="l08767"></a>08767 }
<a name="l08768"></a>08768 
<a name="l08773"></a>08773 <span class="keywordtype">void</span> QCPCurve::addData(<span class="keyword">const</span> QVector&lt;double&gt; &amp;ts, <span class="keyword">const</span> QVector&lt;double&gt; &amp;keys, <span class="keyword">const</span> QVector&lt;double&gt; &amp;values)
<a name="l08774"></a>08774 {
<a name="l08775"></a>08775   <span class="keywordtype">int</span> n = ts.size();
<a name="l08776"></a>08776   n = qMin(n, keys.size());
<a name="l08777"></a>08777   n = qMin(n, values.size());
<a name="l08778"></a>08778   QCPCurveData newData;
<a name="l08779"></a>08779   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l08780"></a>08780   {
<a name="l08781"></a>08781     newData.t = ts[i];
<a name="l08782"></a>08782     newData.key = keys[i];
<a name="l08783"></a>08783     newData.value = values[i];
<a name="l08784"></a>08784     mData-&gt;insertMulti(newData.t, newData);
<a name="l08785"></a>08785   }
<a name="l08786"></a>08786 }
<a name="l08787"></a>08787 
<a name="l08792"></a>08792 <span class="keywordtype">void</span> QCPCurve::removeDataBefore(<span class="keywordtype">double</span> t)
<a name="l08793"></a>08793 {
<a name="l08794"></a>08794   QCPCurveDataMap::iterator it = mData-&gt;begin();
<a name="l08795"></a>08795   <span class="keywordflow">while</span> (it != mData-&gt;end() &amp;&amp; it.key() &lt; t)
<a name="l08796"></a>08796     it = mData-&gt;erase(it);
<a name="l08797"></a>08797 }
<a name="l08798"></a>08798 
<a name="l08803"></a>08803 <span class="keywordtype">void</span> QCPCurve::removeDataAfter(<span class="keywordtype">double</span> t)
<a name="l08804"></a>08804 {
<a name="l08805"></a>08805   <span class="keywordflow">if</span> (mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l08806"></a>08806   QCPCurveDataMap::iterator it = mData-&gt;upperBound(t);
<a name="l08807"></a>08807   <span class="keywordflow">while</span> (it != mData-&gt;end())
<a name="l08808"></a>08808     it = mData-&gt;erase(it);
<a name="l08809"></a>08809 }
<a name="l08810"></a>08810 
<a name="l08818"></a>08818 <span class="keywordtype">void</span> QCPCurve::removeData(<span class="keywordtype">double</span> fromt, <span class="keywordtype">double</span> tot)
<a name="l08819"></a>08819 {
<a name="l08820"></a>08820   <span class="keywordflow">if</span> (fromt &gt;= tot || mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l08821"></a>08821   QCPCurveDataMap::iterator it = mData-&gt;upperBound(fromt);
<a name="l08822"></a>08822   QCPCurveDataMap::iterator itEnd = mData-&gt;upperBound(tot);
<a name="l08823"></a>08823   <span class="keywordflow">while</span> (it != itEnd)
<a name="l08824"></a>08824     it = mData-&gt;erase(it);
<a name="l08825"></a>08825 }
<a name="l08826"></a>08826 
<a name="l08836"></a>08836 <span class="keywordtype">void</span> QCPCurve::removeData(<span class="keywordtype">double</span> t)
<a name="l08837"></a>08837 {
<a name="l08838"></a>08838   mData-&gt;remove(t);
<a name="l08839"></a>08839 }
<a name="l08840"></a>08840 
<a name="l08845"></a>08845 <span class="keywordtype">void</span> QCPCurve::clearData()
<a name="l08846"></a>08846 {
<a name="l08847"></a>08847   mData-&gt;clear();
<a name="l08848"></a>08848 }
<a name="l08849"></a>08849 
<a name="l08850"></a>08850 <span class="comment">/* inherits documentation from base class */</span>
<a name="l08851"></a>08851 <span class="keywordtype">double</span> QCPCurve::selectTest(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l08852"></a>08852 <span class="keyword"></span>{
<a name="l08853"></a>08853   <span class="keywordflow">if</span> (mData-&gt;isEmpty() || !mVisible)
<a name="l08854"></a>08854     <span class="keywordflow">return</span> -1;
<a name="l08855"></a>08855   
<a name="l08856"></a>08856   <span class="keywordflow">return</span> pointDistance(coordsToPixels(key, value));
<a name="l08857"></a>08857 }
<a name="l08858"></a>08858 
<a name="l08859"></a>08859 <span class="comment">/* inherits documentation from base class */</span>
<a name="l08860"></a>08860 <span class="keywordtype">void</span> QCPCurve::draw(QPainter *painter)<span class="keyword"> const</span>
<a name="l08861"></a>08861 <span class="keyword"></span>{
<a name="l08862"></a>08862   <span class="keywordflow">if</span> (!mVisible) <span class="keywordflow">return</span>;
<a name="l08863"></a>08863   <span class="keywordflow">if</span> (mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l08864"></a>08864   painter-&gt;setClipRect(mKeyAxis-&gt;axisRect() | mValueAxis-&gt;axisRect());
<a name="l08865"></a>08865   
<a name="l08866"></a>08866   <span class="comment">// allocate line vector:</span>
<a name="l08867"></a>08867   QVector&lt;QPointF&gt; *lineData = <span class="keyword">new</span> QVector&lt;QPointF&gt;;
<a name="l08868"></a>08868   <span class="comment">// fill with curve data:</span>
<a name="l08869"></a>08869   getCurveData(lineData);
<a name="l08870"></a>08870   <span class="comment">// draw curve fill:</span>
<a name="l08871"></a>08871   <span class="keywordflow">if</span> (mainBrush().style() != Qt::NoBrush &amp;&amp; mainBrush().color().alpha() != 0)
<a name="l08872"></a>08872   {
<a name="l08873"></a>08873     painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeFills));
<a name="l08874"></a>08874     painter-&gt;setPen(Qt::NoPen);
<a name="l08875"></a>08875     painter-&gt;setBrush(mainBrush());
<a name="l08876"></a>08876     painter-&gt;drawPolygon(QPolygonF(*lineData));
<a name="l08877"></a>08877   }
<a name="l08878"></a>08878   <span class="comment">// draw curve line:</span>
<a name="l08879"></a>08879   <span class="keywordflow">if</span> (mainPen().style() != Qt::NoPen &amp;&amp; mainPen().color().alpha() != 0)
<a name="l08880"></a>08880   {
<a name="l08881"></a>08881     painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l08882"></a>08882     painter-&gt;setPen(mainPen());
<a name="l08883"></a>08883     painter-&gt;setBrush(Qt::NoBrush);
<a name="l08884"></a>08884     painter-&gt;drawPolyline(QPolygonF(*lineData));
<a name="l08885"></a>08885   }
<a name="l08886"></a>08886   <span class="comment">// free allocated line data:</span>
<a name="l08887"></a>08887   <span class="keyword">delete</span> lineData;
<a name="l08888"></a>08888 }
<a name="l08889"></a>08889 
<a name="l08890"></a>08890 <span class="comment">/* inherits documentation from base class */</span>
<a name="l08891"></a>08891 <span class="keywordtype">void</span> QCPCurve::drawLegendIcon(QPainter *painter, <span class="keyword">const</span> QRect &amp;rect)<span class="keyword"> const</span>
<a name="l08892"></a>08892 <span class="keyword"></span>{
<a name="l08893"></a>08893   <span class="comment">// draw fill:</span>
<a name="l08894"></a>08894   <span class="keywordflow">if</span> (mBrush.style() != Qt::NoBrush)
<a name="l08895"></a>08895   {
<a name="l08896"></a>08896     painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l08897"></a>08897     painter-&gt;fillRect(rect.left(), rect.top()+rect.height()/2.0, rect.width(), rect.height()/3.0, mBrush);
<a name="l08898"></a>08898   }
<a name="l08899"></a>08899   <span class="comment">// draw line vertically centered:</span>
<a name="l08900"></a>08900   painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l08901"></a>08901   painter-&gt;setPen(mPen);
<a name="l08902"></a>08902   painter-&gt;drawLine(rect.left(), rect.top()+rect.height()/2.0, rect.right()+5, rect.top()+rect.height()/2.0); <span class="comment">// +5 on x2 else last segment is missing from dashed/dotted pens</span>
<a name="l08903"></a>08903 }
<a name="l08904"></a>08904 
<a name="l08911"></a>08911 <span class="keywordtype">void</span> QCPCurve::getCurveData(QVector&lt;QPointF&gt; *lineData)<span class="keyword"> const</span>
<a name="l08912"></a>08912 <span class="keyword"></span>{
<a name="l08913"></a>08913   <span class="comment">/* Edges of axis rect R divide space into 9 regions:</span>
<a name="l08914"></a>08914 <span class="comment">     1__|_4_|__7  </span>
<a name="l08915"></a>08915 <span class="comment">     2__|_R_|__8</span>
<a name="l08916"></a>08916 <span class="comment">     3  | 6 |  9 </span>
<a name="l08917"></a>08917 <span class="comment">     General idea: If the two points of a line segment are in the same region (that is not R), the line segment corner is removed.</span>
<a name="l08918"></a>08918 <span class="comment">     Curves outside R become straight lines closely outside of R which greatly reduces drawing time, yet keeps the look of lines and</span>
<a name="l08919"></a>08919 <span class="comment">     fills inside R consistent.</span>
<a name="l08920"></a>08920 <span class="comment">     The region inside R has index 5.</span>
<a name="l08921"></a>08921 <span class="comment">  */</span>
<a name="l08922"></a>08922   lineData-&gt;reserve(mData-&gt;size());
<a name="l08923"></a>08923   QCPCurveDataMap::const_iterator it;
<a name="l08924"></a>08924   <span class="keywordtype">int</span> lastRegion = 5;
<a name="l08925"></a>08925   <span class="keywordtype">int</span> currentRegion = 5;
<a name="l08926"></a>08926   <span class="keywordtype">double</span> RLeft = mKeyAxis-&gt;range().lower;
<a name="l08927"></a>08927   <span class="keywordtype">double</span> RRight = mKeyAxis-&gt;range().upper;
<a name="l08928"></a>08928   <span class="keywordtype">double</span> RBottom = mValueAxis-&gt;range().lower;
<a name="l08929"></a>08929   <span class="keywordtype">double</span> RTop = mValueAxis-&gt;range().upper;
<a name="l08930"></a>08930   <span class="keywordtype">double</span> x, y; <span class="comment">// current key/value</span>
<a name="l08931"></a>08931   <span class="keywordtype">bool</span> addedLastAlready = <span class="keyword">true</span>;
<a name="l08932"></a>08932   <span class="keywordtype">bool</span> firstPoint = <span class="keyword">true</span>; <span class="comment">// first point must always be drawn, to make sure fill works correctly</span>
<a name="l08933"></a>08933   <span class="keywordflow">for</span> (it = mData-&gt;constBegin(); it != mData-&gt;constEnd(); ++it)
<a name="l08934"></a>08934   {
<a name="l08935"></a>08935     x = it.value().key;
<a name="l08936"></a>08936     y = it.value().value;
<a name="l08937"></a>08937     <span class="comment">// determine current region:</span>
<a name="l08938"></a>08938     <span class="keywordflow">if</span> (x &lt; RLeft) <span class="comment">// region 123</span>
<a name="l08939"></a>08939     {
<a name="l08940"></a>08940       <span class="keywordflow">if</span> (y &gt; RTop)
<a name="l08941"></a>08941         currentRegion = 1;
<a name="l08942"></a>08942       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (y &lt; RBottom)
<a name="l08943"></a>08943         currentRegion = 3;
<a name="l08944"></a>08944       <span class="keywordflow">else</span>
<a name="l08945"></a>08945         currentRegion = 2;
<a name="l08946"></a>08946     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &gt; RRight) <span class="comment">// region 789</span>
<a name="l08947"></a>08947     {
<a name="l08948"></a>08948       <span class="keywordflow">if</span> (y &gt; RTop)
<a name="l08949"></a>08949         currentRegion = 7;
<a name="l08950"></a>08950       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (y &lt; RBottom)
<a name="l08951"></a>08951         currentRegion = 9;
<a name="l08952"></a>08952       <span class="keywordflow">else</span>
<a name="l08953"></a>08953         currentRegion = 8;
<a name="l08954"></a>08954     } <span class="keywordflow">else</span> <span class="comment">// region 456</span>
<a name="l08955"></a>08955     {
<a name="l08956"></a>08956       <span class="keywordflow">if</span> (y &gt; RTop)
<a name="l08957"></a>08957         currentRegion = 4;
<a name="l08958"></a>08958       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (y &lt; RBottom)
<a name="l08959"></a>08959         currentRegion = 6;
<a name="l08960"></a>08960       <span class="keywordflow">else</span>
<a name="l08961"></a>08961         currentRegion = 5;
<a name="l08962"></a>08962     }
<a name="l08963"></a>08963     
<a name="l08964"></a>08964     <span class="comment">/*</span>
<a name="l08965"></a>08965 <span class="comment">      Watch out, the next part is very tricky. It modifies the curve such that it seems like the</span>
<a name="l08966"></a>08966 <span class="comment">      whole thing is still drawn, but actually the points outside the axisRect are simplified</span>
<a name="l08967"></a>08967 <span class="comment">      (&quot;optimized&quot;) greatly. There are some subtle special cases when line segments are large and</span>
<a name="l08968"></a>08968 <span class="comment">      thereby each subsequent point may be in a different region or even skip some.</span>
<a name="l08969"></a>08969 <span class="comment">    */</span>
<a name="l08970"></a>08970     <span class="comment">// determine whether to keep current point:</span>
<a name="l08971"></a>08971     <span class="keywordflow">if</span> (currentRegion == 5 || (firstPoint &amp;&amp; mBrush.style() != Qt::NoBrush)) <span class="comment">// current is in R, add current and last if it wasn&#39;t added already</span>
<a name="l08972"></a>08972     {
<a name="l08973"></a>08973       <span class="keywordflow">if</span> (!addedLastAlready) <span class="comment">// in case curve just entered R, make sure the last point outside R is also drawn correctly</span>
<a name="l08974"></a>08974         lineData-&gt;append(coordsToPixels((it-1).value().key, (it-1).value().value)); <span class="comment">// add last point to vector</span>
<a name="l08975"></a>08975       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lastRegion != 5) <span class="comment">// added last already. If that&#39;s the case, we probably added it at optimized position. So go back and make sure it&#39;s at original position (else the angle changes under which this segment enters R)</span>
<a name="l08976"></a>08976       {
<a name="l08977"></a>08977         <span class="keywordflow">if</span> (!firstPoint) <span class="comment">// because on firstPoint, currentRegion is 5 and addedLastAlready is true, although there is no last point</span>
<a name="l08978"></a>08978           lineData-&gt;replace(lineData-&gt;size()-1, coordsToPixels((it-1).value().key, (it-1).value().value));
<a name="l08979"></a>08979       }
<a name="l08980"></a>08980       lineData-&gt;append(coordsToPixels(it.value().key, it.value().value)); <span class="comment">// add current point to vector</span>
<a name="l08981"></a>08981       addedLastAlready = <span class="keyword">true</span>; <span class="comment">// so in next iteration, we don&#39;t add this point twice</span>
<a name="l08982"></a>08982     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currentRegion != lastRegion) <span class="comment">// changed region, add current and last if not added already</span>
<a name="l08983"></a>08983     {
<a name="l08984"></a>08984       <span class="comment">// using outsideCoordsToPixels instead of coorsToPixels for optimized point placement (places points just outside axisRect instead of potentially far away)</span>
<a name="l08985"></a>08985       
<a name="l08986"></a>08986       <span class="comment">// if we&#39;re coming from R or we skip diagonally over the edge regions (so line might still be visible in R), we can&#39;t place points optimized</span>
<a name="l08987"></a>08987       <span class="keywordflow">if</span> (lastRegion == 5 || <span class="comment">// coming from R</span>
<a name="l08988"></a>08988           ((lastRegion==2 &amp;&amp; currentRegion==4) || (lastRegion==4 &amp;&amp; currentRegion==2)) || <span class="comment">// skip top left diagonal</span>
<a name="l08989"></a>08989           ((lastRegion==4 &amp;&amp; currentRegion==8) || (lastRegion==8 &amp;&amp; currentRegion==4)) || <span class="comment">// skip top right diagonal</span>
<a name="l08990"></a>08990           ((lastRegion==8 &amp;&amp; currentRegion==6) || (lastRegion==6 &amp;&amp; currentRegion==8)) || <span class="comment">// skip bottom right diagonal</span>
<a name="l08991"></a>08991           ((lastRegion==6 &amp;&amp; currentRegion==2) || (lastRegion==2 &amp;&amp; currentRegion==6))    <span class="comment">// skip bottom left diagonal</span>
<a name="l08992"></a>08992           )
<a name="l08993"></a>08993       {
<a name="l08994"></a>08994         <span class="comment">// always add last point if not added already, original:</span>
<a name="l08995"></a>08995         <span class="keywordflow">if</span> (!addedLastAlready)
<a name="l08996"></a>08996           lineData-&gt;append(coordsToPixels((it-1).value().key, (it-1).value().value));
<a name="l08997"></a>08997         <span class="comment">// add current point, original:</span>
<a name="l08998"></a>08998         lineData-&gt;append(coordsToPixels(it.value().key, it.value().value));
<a name="l08999"></a>08999       } <span class="keywordflow">else</span> <span class="comment">// no special case that forbids optimized point placement, so do it:</span>
<a name="l09000"></a>09000       {
<a name="l09001"></a>09001         <span class="comment">// always add last point if not added already, optimized:</span>
<a name="l09002"></a>09002         <span class="keywordflow">if</span> (!addedLastAlready)
<a name="l09003"></a>09003           lineData-&gt;append(outsideCoordsToPixels((it-1).value().key, (it-1).value().value, currentRegion));
<a name="l09004"></a>09004         <span class="comment">// add current point, optimized:</span>
<a name="l09005"></a>09005         lineData-&gt;append(outsideCoordsToPixels(it.value().key, it.value().value, currentRegion));
<a name="l09006"></a>09006       }
<a name="l09007"></a>09007       addedLastAlready = <span class="keyword">true</span>; <span class="comment">// so that if next point enters 5, or crosses another region boundary, we don&#39;t add this point twice</span>
<a name="l09008"></a>09008     } <span class="keywordflow">else</span> <span class="comment">// neither in R, nor crossed a region boundary, skip current point</span>
<a name="l09009"></a>09009     {
<a name="l09010"></a>09010       addedLastAlready = <span class="keyword">false</span>;
<a name="l09011"></a>09011     }
<a name="l09012"></a>09012     lastRegion = currentRegion;
<a name="l09013"></a>09013     firstPoint = <span class="keyword">false</span>;
<a name="l09014"></a>09014   }
<a name="l09015"></a>09015   <span class="comment">// If curve ends outside R, we want to add very last point so the fill looks like it should when the curve started inside R:</span>
<a name="l09016"></a>09016   <span class="keywordflow">if</span> (lastRegion != 5 &amp;&amp; mBrush.style() != Qt::NoBrush &amp;&amp; !mData-&gt;isEmpty())
<a name="l09017"></a>09017     lineData-&gt;append(coordsToPixels((mData-&gt;constEnd()-1).value().key, (mData-&gt;constEnd()-1).value().value));
<a name="l09018"></a>09018 }
<a name="l09019"></a>09019 
<a name="l09026"></a>09026 <span class="keywordtype">double</span> QCPCurve::pointDistance(<span class="keyword">const</span> QPointF &amp;pixelPoint)<span class="keyword"> const</span>
<a name="l09027"></a>09027 <span class="keyword"></span>{
<a name="l09028"></a>09028   <span class="keywordflow">if</span> (mData-&gt;isEmpty())
<a name="l09029"></a>09029   {
<a name="l09030"></a>09030     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;requested point distance on curve&quot;</span> &lt;&lt; mName &lt;&lt; <span class="stringliteral">&quot;without data&quot;</span>;
<a name="l09031"></a>09031     <span class="keywordflow">return</span> 500;
<a name="l09032"></a>09032   }
<a name="l09033"></a>09033   <span class="keywordflow">if</span> (mData-&gt;size() == 1)
<a name="l09034"></a>09034   {
<a name="l09035"></a>09035     QPointF dataPoint = coordsToPixels(mData-&gt;constBegin().key(), mData-&gt;constBegin().value().value);
<a name="l09036"></a>09036     <span class="keywordflow">return</span> QVector2D(dataPoint-pixelPoint).length();
<a name="l09037"></a>09037   }
<a name="l09038"></a>09038   
<a name="l09039"></a>09039   <span class="comment">// calculate minimum distance to line segments:</span>
<a name="l09040"></a>09040   QVector&lt;QPointF&gt; *lineData = <span class="keyword">new</span> QVector&lt;QPointF&gt;;
<a name="l09041"></a>09041   getCurveData(lineData);
<a name="l09042"></a>09042   <span class="keywordtype">double</span> minDistSqr = std::numeric_limits&lt;double&gt;::max();
<a name="l09043"></a>09043   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;lineData-&gt;size()-1; ++i)
<a name="l09044"></a>09044   {
<a name="l09045"></a>09045     <span class="keywordtype">double</span> currentDistSqr = distSqrToLine(lineData-&gt;at(i), lineData-&gt;at(i+1), pixelPoint);
<a name="l09046"></a>09046     <span class="keywordflow">if</span> (currentDistSqr &lt; minDistSqr)
<a name="l09047"></a>09047       minDistSqr = currentDistSqr;
<a name="l09048"></a>09048   }
<a name="l09049"></a>09049   <span class="keyword">delete</span> lineData;
<a name="l09050"></a>09050   <span class="keywordflow">return</span> sqrt(minDistSqr);
<a name="l09051"></a>09051 }
<a name="l09052"></a>09052 
<a name="l09060"></a>09060 <span class="keywordtype">double</span> QCPCurve::distSqrToLine(QPointF ptA, QPointF ptB, QPointF point)<span class="keyword"> const</span>
<a name="l09061"></a>09061 <span class="keyword"></span>{
<a name="l09062"></a>09062   QVector2D a(ptA);
<a name="l09063"></a>09063   QVector2D b(ptB);
<a name="l09064"></a>09064   QVector2D p(point);
<a name="l09065"></a>09065   QVector2D v(b-a);
<a name="l09066"></a>09066   <span class="keywordtype">double</span> mu = (QVector2D::dotProduct(p, v)-QVector2D::dotProduct(a, v))/v.lengthSquared();
<a name="l09067"></a>09067   <span class="keywordflow">if</span> (mu &lt;= 0)
<a name="l09068"></a>09068     <span class="keywordflow">return</span> (a-p).lengthSquared();
<a name="l09069"></a>09069   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mu &gt;= 1)
<a name="l09070"></a>09070     <span class="keywordflow">return</span> (b-p).lengthSquared();
<a name="l09071"></a>09071   <span class="keywordflow">else</span>
<a name="l09072"></a>09072     <span class="keywordflow">return</span> ((a + mu*v)-p).lengthSquared();
<a name="l09073"></a>09073 }
<a name="l09074"></a>09074 
<a name="l09085"></a>09085 QPointF QCPCurve::outsideCoordsToPixels(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value, <span class="keywordtype">int</span> region)<span class="keyword"> const</span>
<a name="l09086"></a>09086 <span class="keyword"></span>{
<a name="l09087"></a>09087   <span class="keywordtype">int</span> margin = 10;
<a name="l09088"></a>09088   QRect axisRect = mKeyAxis-&gt;axisRect() | mValueAxis-&gt;axisRect();
<a name="l09089"></a>09089   QPointF result = coordsToPixels(key, value);
<a name="l09090"></a>09090   <span class="keywordflow">switch</span> (region)
<a name="l09091"></a>09091   {
<a name="l09092"></a>09092     <span class="keywordflow">case</span> 2: result.setX(axisRect.left()-margin); <span class="keywordflow">break</span>; <span class="comment">// left</span>
<a name="l09093"></a>09093     <span class="keywordflow">case</span> 8: result.setX(axisRect.right()+margin); <span class="keywordflow">break</span>; <span class="comment">// right</span>
<a name="l09094"></a>09094     <span class="keywordflow">case</span> 4: result.setY(axisRect.top()-margin); <span class="keywordflow">break</span>; <span class="comment">// top</span>
<a name="l09095"></a>09095     <span class="keywordflow">case</span> 6: result.setY(axisRect.bottom()+margin); <span class="keywordflow">break</span>; <span class="comment">// bottom</span>
<a name="l09096"></a>09096     <span class="keywordflow">case</span> 1: result.setX(axisRect.left()-margin);
<a name="l09097"></a>09097             result.setY(axisRect.top()-margin); <span class="keywordflow">break</span>; <span class="comment">// top left</span>
<a name="l09098"></a>09098     <span class="keywordflow">case</span> 7: result.setX(axisRect.right()+margin);
<a name="l09099"></a>09099             result.setY(axisRect.top()-margin); <span class="keywordflow">break</span>; <span class="comment">// top right</span>
<a name="l09100"></a>09100     <span class="keywordflow">case</span> 9: result.setX(axisRect.right()+margin);
<a name="l09101"></a>09101             result.setY(axisRect.bottom()+margin); <span class="keywordflow">break</span>; <span class="comment">// bottom right</span>
<a name="l09102"></a>09102     <span class="keywordflow">case</span> 3: result.setX(axisRect.left()-margin);
<a name="l09103"></a>09103             result.setY(axisRect.bottom()+margin); <span class="keywordflow">break</span>; <span class="comment">// bottom left</span>
<a name="l09104"></a>09104   }
<a name="l09105"></a>09105   <span class="keywordflow">return</span> result;
<a name="l09106"></a>09106 }
<a name="l09107"></a>09107 
<a name="l09108"></a>09108 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09109"></a>09109 QCPRange QCPCurve::getKeyRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain)<span class="keyword"> const</span>
<a name="l09110"></a>09110 <span class="keyword"></span>{
<a name="l09111"></a>09111   QCPRange range;
<a name="l09112"></a>09112   <span class="keywordtype">bool</span> haveLower = <span class="keyword">false</span>;
<a name="l09113"></a>09113   <span class="keywordtype">bool</span> haveUpper = <span class="keyword">false</span>;
<a name="l09114"></a>09114   
<a name="l09115"></a>09115   <span class="keywordtype">double</span> current;
<a name="l09116"></a>09116   
<a name="l09117"></a>09117   QCPCurveDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l09118"></a>09118   <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l09119"></a>09119   {
<a name="l09120"></a>09120     current = it.value().key;
<a name="l09121"></a>09121     <span class="keywordflow">if</span> (inSignDomain == sdBoth || (inSignDomain == sdNegative &amp;&amp; current &lt; 0) || (inSignDomain == sdPositive &amp;&amp; current &gt; 0))
<a name="l09122"></a>09122     {
<a name="l09123"></a>09123       <span class="keywordflow">if</span> (current &lt; range.lower || !haveLower)
<a name="l09124"></a>09124       {
<a name="l09125"></a>09125         range.lower = current;
<a name="l09126"></a>09126         haveLower = <span class="keyword">true</span>;
<a name="l09127"></a>09127       }
<a name="l09128"></a>09128       <span class="keywordflow">if</span> (current &gt; range.upper || !haveUpper)
<a name="l09129"></a>09129       {
<a name="l09130"></a>09130         range.upper = current;
<a name="l09131"></a>09131         haveUpper = <span class="keyword">true</span>;
<a name="l09132"></a>09132       }
<a name="l09133"></a>09133     }
<a name="l09134"></a>09134     ++it;
<a name="l09135"></a>09135   }
<a name="l09136"></a>09136   
<a name="l09137"></a>09137   validRange = haveLower &amp;&amp; haveUpper;
<a name="l09138"></a>09138   <span class="keywordflow">return</span> range;
<a name="l09139"></a>09139 }
<a name="l09140"></a>09140 
<a name="l09141"></a>09141 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09142"></a>09142 QCPRange QCPCurve::getValueRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain)<span class="keyword"> const</span>
<a name="l09143"></a>09143 <span class="keyword"></span>{
<a name="l09144"></a>09144   QCPRange range;
<a name="l09145"></a>09145   <span class="keywordtype">bool</span> haveLower = <span class="keyword">false</span>;
<a name="l09146"></a>09146   <span class="keywordtype">bool</span> haveUpper = <span class="keyword">false</span>;
<a name="l09147"></a>09147   
<a name="l09148"></a>09148   <span class="keywordtype">double</span> current;
<a name="l09149"></a>09149   
<a name="l09150"></a>09150   QCPCurveDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l09151"></a>09151   <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l09152"></a>09152   {
<a name="l09153"></a>09153     current = it.value().value;
<a name="l09154"></a>09154     <span class="keywordflow">if</span> (inSignDomain == sdBoth || (inSignDomain == sdNegative &amp;&amp; current &lt; 0) || (inSignDomain == sdPositive &amp;&amp; current &gt; 0))
<a name="l09155"></a>09155     {
<a name="l09156"></a>09156       <span class="keywordflow">if</span> (current &lt; range.lower || !haveLower)
<a name="l09157"></a>09157       {
<a name="l09158"></a>09158         range.lower = current;
<a name="l09159"></a>09159         haveLower = <span class="keyword">true</span>;
<a name="l09160"></a>09160       }
<a name="l09161"></a>09161       <span class="keywordflow">if</span> (current &gt; range.upper || !haveUpper)
<a name="l09162"></a>09162       {
<a name="l09163"></a>09163         range.upper = current;
<a name="l09164"></a>09164         haveUpper = <span class="keyword">true</span>;
<a name="l09165"></a>09165       }
<a name="l09166"></a>09166     }
<a name="l09167"></a>09167     ++it;
<a name="l09168"></a>09168   }
<a name="l09169"></a>09169   
<a name="l09170"></a>09170   validRange = haveLower &amp;&amp; haveUpper;
<a name="l09171"></a>09171   <span class="keywordflow">return</span> range;
<a name="l09172"></a>09172 }
<a name="l09173"></a>09173 
<a name="l09174"></a>09174 <span class="comment">// ================================================================================</span>
<a name="l09175"></a>09175 <span class="comment">// =================== QCPBars</span>
<a name="l09176"></a>09176 <span class="comment">// ================================================================================</span>
<a name="l09232"></a>09232 <span class="comment"></span>QCPBars::QCPBars(QCPAxis *keyAxis, QCPAxis *valueAxis) :
<a name="l09233"></a>09233   QCPAbstractPlottable(keyAxis, valueAxis),
<a name="l09234"></a>09234   mBarBelow(0),
<a name="l09235"></a>09235   mBarAbove(0)
<a name="l09236"></a>09236 {
<a name="l09237"></a>09237   mData = <span class="keyword">new</span> QCPBarDataMap;
<a name="l09238"></a>09238   mPen.setColor(Qt::blue);
<a name="l09239"></a>09239   mPen.setStyle(Qt::SolidLine);
<a name="l09240"></a>09240   mBrush.setColor(QColor(40, 50, 255, 30));
<a name="l09241"></a>09241   mBrush.setStyle(Qt::SolidPattern);
<a name="l09242"></a>09242   mSelectedPen = mPen;
<a name="l09243"></a>09243   mSelectedPen.setWidthF(2.5);
<a name="l09244"></a>09244   mSelectedPen.setColor(QColor(80, 80, 255)); <span class="comment">// lighter than Qt::blue of mPen</span>
<a name="l09245"></a>09245   mSelectedBrush = mBrush;
<a name="l09246"></a>09246   
<a name="l09247"></a>09247   mWidth = 0.75;
<a name="l09248"></a>09248 }
<a name="l09249"></a>09249 
<a name="l09250"></a>09250 QCPBars::~QCPBars()
<a name="l09251"></a>09251 {
<a name="l09252"></a>09252   <span class="keywordflow">if</span> (mBarBelow || mBarAbove)
<a name="l09253"></a>09253     connectBars(mBarBelow, mBarAbove); <span class="comment">// take this bar out of any stacking</span>
<a name="l09254"></a>09254   <span class="keyword">delete</span> mData;
<a name="l09255"></a>09255 }
<a name="l09256"></a>09256 
<a name="l09260"></a>09260 <span class="keywordtype">void</span> QCPBars::setWidth(<span class="keywordtype">double</span> width)
<a name="l09261"></a>09261 {
<a name="l09262"></a>09262   mWidth = width;
<a name="l09263"></a>09263 }
<a name="l09264"></a>09264 
<a name="l09272"></a>09272 <span class="keywordtype">void</span> QCPBars::setData(QCPBarDataMap *data, <span class="keywordtype">bool</span> copy)
<a name="l09273"></a>09273 {
<a name="l09274"></a>09274   <span class="keywordflow">if</span> (copy)
<a name="l09275"></a>09275   {
<a name="l09276"></a>09276     *mData = *data;
<a name="l09277"></a>09277   } <span class="keywordflow">else</span>
<a name="l09278"></a>09278   {
<a name="l09279"></a>09279     <span class="keyword">delete</span> mData;
<a name="l09280"></a>09280     mData = data;
<a name="l09281"></a>09281   }
<a name="l09282"></a>09282 }
<a name="l09283"></a>09283 
<a name="l09290"></a>09290 <span class="keywordtype">void</span> QCPBars::setData(<span class="keyword">const</span> QVector&lt;double&gt; &amp;key, <span class="keyword">const</span> QVector&lt;double&gt; &amp;value)
<a name="l09291"></a>09291 {
<a name="l09292"></a>09292   mData-&gt;clear();
<a name="l09293"></a>09293   <span class="keywordtype">int</span> n = key.size();
<a name="l09294"></a>09294   n = qMin(n, value.size());
<a name="l09295"></a>09295   QCPBarData newData;
<a name="l09296"></a>09296   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l09297"></a>09297   {
<a name="l09298"></a>09298     newData.key = key[i];
<a name="l09299"></a>09299     newData.value = value[i];
<a name="l09300"></a>09300     mData-&gt;insertMulti(newData.key, newData);
<a name="l09301"></a>09301   }
<a name="l09302"></a>09302 }
<a name="l09303"></a>09303 
<a name="l09318"></a>09318 <span class="keywordtype">void</span> QCPBars::moveBelow(QCPBars *bars)
<a name="l09319"></a>09319 {
<a name="l09320"></a>09320   <span class="keywordflow">if</span> (bars == <span class="keyword">this</span>) <span class="keywordflow">return</span>;
<a name="l09321"></a>09321   <span class="keywordflow">if</span> (bars-&gt;keyAxis() != mKeyAxis || bars-&gt;valueAxis() != mValueAxis)
<a name="l09322"></a>09322   {
<a name="l09323"></a>09323     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;passed QCPBars* doesn&#39;t have same key and value axis as this QCPBars&quot;</span>;
<a name="l09324"></a>09324     <span class="keywordflow">return</span>;
<a name="l09325"></a>09325   }
<a name="l09326"></a>09326   <span class="comment">// remove from stacking:</span>
<a name="l09327"></a>09327   connectBars(mBarBelow, mBarAbove); <span class="comment">// Note: also works if one (or both) of them is 0</span>
<a name="l09328"></a>09328   <span class="comment">// if new bar given, insert this bar below it:</span>
<a name="l09329"></a>09329   <span class="keywordflow">if</span> (bars)
<a name="l09330"></a>09330   {
<a name="l09331"></a>09331     <span class="keywordflow">if</span> (bars-&gt;mBarBelow)
<a name="l09332"></a>09332       connectBars(bars-&gt;mBarBelow, <span class="keyword">this</span>);
<a name="l09333"></a>09333     connectBars(<span class="keyword">this</span>, bars);
<a name="l09334"></a>09334   }
<a name="l09335"></a>09335 }
<a name="l09336"></a>09336 
<a name="l09351"></a>09351 <span class="keywordtype">void</span> QCPBars::moveAbove(QCPBars *bars)
<a name="l09352"></a>09352 {
<a name="l09353"></a>09353   <span class="keywordflow">if</span> (bars == <span class="keyword">this</span>) <span class="keywordflow">return</span>;
<a name="l09354"></a>09354   <span class="keywordflow">if</span> (bars &amp;&amp; (bars-&gt;keyAxis() != mKeyAxis || bars-&gt;valueAxis() != mValueAxis))
<a name="l09355"></a>09355   {
<a name="l09356"></a>09356     qDebug() &lt;&lt; FUNCNAME &lt;&lt; <span class="stringliteral">&quot;passed QCPBars* doesn&#39;t have same key and value axis as this QCPBars&quot;</span>;
<a name="l09357"></a>09357     <span class="keywordflow">return</span>;
<a name="l09358"></a>09358   }
<a name="l09359"></a>09359   <span class="comment">// remove from stacking:</span>
<a name="l09360"></a>09360   connectBars(mBarBelow, mBarAbove); <span class="comment">// Note: also works if one (or both) of them is 0</span>
<a name="l09361"></a>09361   <span class="comment">// if new bar given, insert this bar above it:</span>
<a name="l09362"></a>09362   <span class="keywordflow">if</span> (bars)
<a name="l09363"></a>09363   {
<a name="l09364"></a>09364     <span class="keywordflow">if</span> (bars-&gt;mBarAbove)
<a name="l09365"></a>09365       connectBars(<span class="keyword">this</span>, bars-&gt;mBarAbove);
<a name="l09366"></a>09366     connectBars(bars, <span class="keyword">this</span>);
<a name="l09367"></a>09367   }
<a name="l09368"></a>09368 }
<a name="l09369"></a>09369 
<a name="l09374"></a>09374 <span class="keywordtype">void</span> QCPBars::addData(<span class="keyword">const</span> QCPBarDataMap &amp;dataMap)
<a name="l09375"></a>09375 {
<a name="l09376"></a>09376   mData-&gt;unite(dataMap);
<a name="l09377"></a>09377 }
<a name="l09378"></a>09378 
<a name="l09383"></a>09383 <span class="keywordtype">void</span> QCPBars::addData(<span class="keyword">const</span> QCPBarData &amp;data)
<a name="l09384"></a>09384 {
<a name="l09385"></a>09385   mData-&gt;insertMulti(data.key, data);
<a name="l09386"></a>09386 }
<a name="l09387"></a>09387 
<a name="l09392"></a>09392 <span class="keywordtype">void</span> QCPBars::addData(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)
<a name="l09393"></a>09393 {
<a name="l09394"></a>09394   QCPBarData newData;
<a name="l09395"></a>09395   newData.key = key;
<a name="l09396"></a>09396   newData.value = value;
<a name="l09397"></a>09397   mData-&gt;insertMulti(newData.key, newData);
<a name="l09398"></a>09398 }
<a name="l09399"></a>09399 
<a name="l09404"></a>09404 <span class="keywordtype">void</span> QCPBars::addData(<span class="keyword">const</span> QVector&lt;double&gt; &amp;keys, <span class="keyword">const</span> QVector&lt;double&gt; &amp;values)
<a name="l09405"></a>09405 {
<a name="l09406"></a>09406   <span class="keywordtype">int</span> n = keys.size();
<a name="l09407"></a>09407   n = qMin(n, values.size());
<a name="l09408"></a>09408   QCPBarData newData;
<a name="l09409"></a>09409   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; ++i)
<a name="l09410"></a>09410   {
<a name="l09411"></a>09411     newData.key = keys[i];
<a name="l09412"></a>09412     newData.value = values[i];
<a name="l09413"></a>09413     mData-&gt;insertMulti(newData.key, newData);
<a name="l09414"></a>09414   }
<a name="l09415"></a>09415 }
<a name="l09416"></a>09416 
<a name="l09421"></a>09421 <span class="keywordtype">void</span> QCPBars::removeDataBefore(<span class="keywordtype">double</span> key)
<a name="l09422"></a>09422 {
<a name="l09423"></a>09423   QCPBarDataMap::iterator it = mData-&gt;begin();
<a name="l09424"></a>09424   <span class="keywordflow">while</span> (it != mData-&gt;end() &amp;&amp; it.key() &lt; key)
<a name="l09425"></a>09425     it = mData-&gt;erase(it);
<a name="l09426"></a>09426 }
<a name="l09427"></a>09427 
<a name="l09432"></a>09432 <span class="keywordtype">void</span> QCPBars::removeDataAfter(<span class="keywordtype">double</span> key)
<a name="l09433"></a>09433 {
<a name="l09434"></a>09434   <span class="keywordflow">if</span> (mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l09435"></a>09435   QCPBarDataMap::iterator it = mData-&gt;upperBound(key);
<a name="l09436"></a>09436   <span class="keywordflow">while</span> (it != mData-&gt;end())
<a name="l09437"></a>09437     it = mData-&gt;erase(it);
<a name="l09438"></a>09438 }
<a name="l09439"></a>09439 
<a name="l09447"></a>09447 <span class="keywordtype">void</span> QCPBars::removeData(<span class="keywordtype">double</span> fromKey, <span class="keywordtype">double</span> toKey)
<a name="l09448"></a>09448 {
<a name="l09449"></a>09449   <span class="keywordflow">if</span> (fromKey &gt;= toKey || mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l09450"></a>09450   QCPBarDataMap::iterator it = mData-&gt;upperBound(fromKey);
<a name="l09451"></a>09451   QCPBarDataMap::iterator itEnd = mData-&gt;upperBound(toKey);
<a name="l09452"></a>09452   <span class="keywordflow">while</span> (it != itEnd)
<a name="l09453"></a>09453     it = mData-&gt;erase(it);
<a name="l09454"></a>09454 }
<a name="l09455"></a>09455 
<a name="l09464"></a>09464 <span class="keywordtype">void</span> QCPBars::removeData(<span class="keywordtype">double</span> key)
<a name="l09465"></a>09465 {
<a name="l09466"></a>09466   mData-&gt;remove(key);
<a name="l09467"></a>09467 }
<a name="l09468"></a>09468 
<a name="l09473"></a>09473 <span class="keywordtype">void</span> QCPBars::clearData()
<a name="l09474"></a>09474 {
<a name="l09475"></a>09475   mData-&gt;clear();
<a name="l09476"></a>09476 }
<a name="l09477"></a>09477 
<a name="l09478"></a>09478 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09479"></a>09479 <span class="keywordtype">double</span> QCPBars::selectTest(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l09480"></a>09480 <span class="keyword"></span>{
<a name="l09481"></a>09481   QCPBarDataMap::ConstIterator it;
<a name="l09482"></a>09482   <span class="keywordflow">for</span> (it = mData-&gt;constBegin(); it != mData-&gt;constEnd(); ++it)
<a name="l09483"></a>09483   {
<a name="l09484"></a>09484     <span class="keywordtype">double</span> baseValue = getBaseValue(it.key(), it.value().value &gt;=0);
<a name="l09485"></a>09485     QCPRange keyRange(it.key()-mWidth*0.5, it.key()+mWidth*0.5);
<a name="l09486"></a>09486     QCPRange valueRange(baseValue, baseValue+it.value().value);
<a name="l09487"></a>09487     <span class="keywordflow">if</span> (keyRange.contains(key) &amp;&amp; valueRange.contains(value))
<a name="l09488"></a>09488       <span class="keywordflow">return</span> mParentPlot-&gt;selectionTolerance()*0.99;
<a name="l09489"></a>09489   }
<a name="l09490"></a>09490   <span class="keywordflow">return</span> -1;
<a name="l09491"></a>09491 }
<a name="l09492"></a>09492 
<a name="l09493"></a>09493 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09494"></a>09494 <span class="keywordtype">void</span> QCPBars::draw(QPainter *painter)<span class="keyword"> const</span>
<a name="l09495"></a>09495 <span class="keyword"></span>{
<a name="l09496"></a>09496   <span class="keywordflow">if</span> (!mVisible || mData-&gt;isEmpty()) <span class="keywordflow">return</span>;
<a name="l09497"></a>09497   painter-&gt;setClipRect(mKeyAxis-&gt;axisRect() | mValueAxis-&gt;axisRect());
<a name="l09498"></a>09498   
<a name="l09499"></a>09499   QCPBarDataMap::const_iterator it;
<a name="l09500"></a>09500   <span class="keywordflow">for</span> (it = mData-&gt;constBegin(); it != mData-&gt;constEnd(); ++it)
<a name="l09501"></a>09501   {
<a name="l09502"></a>09502     <span class="keywordflow">if</span> (it.key()+mWidth*0.5 &lt; mKeyAxis-&gt;range().lower || it.key()-mWidth*0.5 &gt; mKeyAxis-&gt;range().upper)
<a name="l09503"></a>09503       <span class="keywordflow">continue</span>;
<a name="l09504"></a>09504     QPolygonF barPolygon = getBarPolygon(it.key(), it.value().value);
<a name="l09505"></a>09505     <span class="comment">// draw bar fill:</span>
<a name="l09506"></a>09506     <span class="keywordflow">if</span> (mainBrush().style() != Qt::NoBrush &amp;&amp; mainBrush().color().alpha() != 0)
<a name="l09507"></a>09507     {
<a name="l09508"></a>09508       painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeFills));
<a name="l09509"></a>09509       painter-&gt;setPen(Qt::NoPen);
<a name="l09510"></a>09510       painter-&gt;setBrush(mainBrush());
<a name="l09511"></a>09511       painter-&gt;drawPolygon(barPolygon);
<a name="l09512"></a>09512     }
<a name="l09513"></a>09513     <span class="comment">// draw bar line:</span>
<a name="l09514"></a>09514     <span class="keywordflow">if</span> (mainPen().style() != Qt::NoPen &amp;&amp; mainPen().color().alpha() != 0)
<a name="l09515"></a>09515     {
<a name="l09516"></a>09516       painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l09517"></a>09517       painter-&gt;setPen(mainPen());
<a name="l09518"></a>09518       painter-&gt;setBrush(Qt::NoBrush);
<a name="l09519"></a>09519       painter-&gt;drawPolyline(barPolygon);
<a name="l09520"></a>09520     }
<a name="l09521"></a>09521   }
<a name="l09522"></a>09522 }
<a name="l09523"></a>09523 
<a name="l09524"></a>09524 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09525"></a>09525 <span class="keywordtype">void</span> QCPBars::drawLegendIcon(QPainter *painter, <span class="keyword">const</span> QRect &amp;rect)<span class="keyword"> const</span>
<a name="l09526"></a>09526 <span class="keyword"></span>{
<a name="l09527"></a>09527   <span class="comment">// draw filled rect:</span>
<a name="l09528"></a>09528   painter-&gt;setBrush(mBrush);
<a name="l09529"></a>09529   painter-&gt;setPen(mPen);
<a name="l09530"></a>09530   painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l09531"></a>09531   QRect r = QRect(0, 0, rect.width()*0.67, rect.height()*0.67);
<a name="l09532"></a>09532   r.moveCenter(rect.center());
<a name="l09533"></a>09533   painter-&gt;drawRect(r);
<a name="l09534"></a>09534 }
<a name="l09535"></a>09535 
<a name="l09541"></a>09541 QPolygonF QCPBars::getBarPolygon(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l09542"></a>09542 <span class="keyword"></span>{
<a name="l09543"></a>09543   QPolygonF result;
<a name="l09544"></a>09544   <span class="keywordtype">double</span> baseValue = getBaseValue(key, value &gt;= 0);
<a name="l09545"></a>09545   result &lt;&lt; coordsToPixels(key-mWidth*0.5, baseValue);
<a name="l09546"></a>09546   result &lt;&lt; coordsToPixels(key-mWidth*0.5, baseValue+value);
<a name="l09547"></a>09547   result &lt;&lt; coordsToPixels(key+mWidth*0.5, baseValue+value);
<a name="l09548"></a>09548   result &lt;&lt; coordsToPixels(key+mWidth*0.5, baseValue);
<a name="l09549"></a>09549   <span class="keywordflow">return</span> result;
<a name="l09550"></a>09550 }
<a name="l09551"></a>09551 
<a name="l09561"></a>09561 <span class="keywordtype">double</span> QCPBars::getBaseValue(<span class="keywordtype">double</span> key, <span class="keywordtype">bool</span> positive)<span class="keyword"> const</span>
<a name="l09562"></a>09562 <span class="keyword"></span>{
<a name="l09563"></a>09563   <span class="keywordflow">if</span> (mBarBelow)
<a name="l09564"></a>09564   {
<a name="l09565"></a>09565     <span class="keywordtype">double</span> max = 0;
<a name="l09566"></a>09566     <span class="comment">// find bars of mBarBelow that are approximately at key and find largest one:</span>
<a name="l09567"></a>09567     QCPBarDataMap::const_iterator it = mBarBelow-&gt;mData-&gt;lowerBound(key-mWidth*0.1);
<a name="l09568"></a>09568     QCPBarDataMap::const_iterator itEnd = mBarBelow-&gt;mData-&gt;upperBound(key+mWidth*0.1);
<a name="l09569"></a>09569     <span class="keywordflow">while</span> (it != itEnd)
<a name="l09570"></a>09570     {
<a name="l09571"></a>09571       <span class="keywordflow">if</span> ((positive &amp;&amp; it.value().value &gt; max) ||
<a name="l09572"></a>09572           (!positive &amp;&amp; it.value().value &lt; max))
<a name="l09573"></a>09573         max = it.value().value;
<a name="l09574"></a>09574       ++it;
<a name="l09575"></a>09575     }
<a name="l09576"></a>09576     <span class="comment">// recurse down the bar-stack to find the total height:</span>
<a name="l09577"></a>09577     <span class="keywordflow">return</span> max + mBarBelow-&gt;getBaseValue(key, positive);
<a name="l09578"></a>09578   } <span class="keywordflow">else</span>
<a name="l09579"></a>09579     <span class="keywordflow">return</span> 0;
<a name="l09580"></a>09580 }
<a name="l09581"></a>09581 
<a name="l09590"></a>09590 <span class="keywordtype">void</span> QCPBars::connectBars(QCPBars *lower, QCPBars *upper)
<a name="l09591"></a>09591 {
<a name="l09592"></a>09592   <span class="keywordflow">if</span> (!lower &amp;&amp; !upper) <span class="keywordflow">return</span>;
<a name="l09593"></a>09593   
<a name="l09594"></a>09594   <span class="keywordflow">if</span> (!lower) <span class="comment">// disconnect upper at bottom</span>
<a name="l09595"></a>09595   {
<a name="l09596"></a>09596     <span class="comment">// disconnect old bar below upper:</span>
<a name="l09597"></a>09597     <span class="keywordflow">if</span> (upper-&gt;mBarBelow &amp;&amp; upper-&gt;mBarBelow-&gt;mBarAbove == upper)
<a name="l09598"></a>09598       upper-&gt;mBarBelow-&gt;mBarAbove = 0;
<a name="l09599"></a>09599     upper-&gt;mBarBelow = 0;
<a name="l09600"></a>09600   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!upper) <span class="comment">// disconnect lower at top</span>
<a name="l09601"></a>09601   {
<a name="l09602"></a>09602     <span class="comment">// disconnect old bar above lower:</span>
<a name="l09603"></a>09603     <span class="keywordflow">if</span> (lower-&gt;mBarAbove &amp;&amp; lower-&gt;mBarAbove-&gt;mBarBelow == lower)
<a name="l09604"></a>09604       lower-&gt;mBarAbove-&gt;mBarBelow = 0;
<a name="l09605"></a>09605     lower-&gt;mBarAbove = 0;
<a name="l09606"></a>09606   } <span class="keywordflow">else</span> <span class="comment">// connect lower and upper</span>
<a name="l09607"></a>09607   {
<a name="l09608"></a>09608     <span class="comment">// disconnect old bar above lower:</span>
<a name="l09609"></a>09609     <span class="keywordflow">if</span> (lower-&gt;mBarAbove &amp;&amp; lower-&gt;mBarAbove-&gt;mBarBelow == lower)
<a name="l09610"></a>09610       lower-&gt;mBarAbove-&gt;mBarBelow = 0;
<a name="l09611"></a>09611     <span class="comment">// disconnect old bar below upper:</span>
<a name="l09612"></a>09612     <span class="keywordflow">if</span> (upper-&gt;mBarBelow &amp;&amp; upper-&gt;mBarBelow-&gt;mBarAbove == upper)
<a name="l09613"></a>09613       upper-&gt;mBarBelow-&gt;mBarAbove = 0;
<a name="l09614"></a>09614     lower-&gt;mBarAbove = upper;
<a name="l09615"></a>09615     upper-&gt;mBarBelow = lower;
<a name="l09616"></a>09616   }
<a name="l09617"></a>09617 }
<a name="l09618"></a>09618 
<a name="l09619"></a>09619 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09620"></a>09620 QCPRange QCPBars::getKeyRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain)<span class="keyword"> const</span>
<a name="l09621"></a>09621 <span class="keyword"></span>{
<a name="l09622"></a>09622   QCPRange range;
<a name="l09623"></a>09623   <span class="keywordtype">bool</span> haveLower = <span class="keyword">false</span>;
<a name="l09624"></a>09624   <span class="keywordtype">bool</span> haveUpper = <span class="keyword">false</span>;
<a name="l09625"></a>09625   
<a name="l09626"></a>09626   <span class="keywordtype">double</span> current;
<a name="l09627"></a>09627   <span class="keywordtype">double</span> barWidthHalf = mWidth*0.5;
<a name="l09628"></a>09628   QCPBarDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l09629"></a>09629   <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l09630"></a>09630   {
<a name="l09631"></a>09631     current = it.value().key;
<a name="l09632"></a>09632     <span class="keywordflow">if</span> (inSignDomain == sdBoth || (inSignDomain == sdNegative &amp;&amp; current+barWidthHalf &lt; 0) || (inSignDomain == sdPositive &amp;&amp; current-barWidthHalf &gt; 0))
<a name="l09633"></a>09633     {
<a name="l09634"></a>09634       <span class="keywordflow">if</span> (current-barWidthHalf &lt; range.lower || !haveLower)
<a name="l09635"></a>09635       {
<a name="l09636"></a>09636         range.lower = current-barWidthHalf;
<a name="l09637"></a>09637         haveLower = <span class="keyword">true</span>;
<a name="l09638"></a>09638       }
<a name="l09639"></a>09639       <span class="keywordflow">if</span> (current+barWidthHalf &gt; range.upper || !haveUpper)
<a name="l09640"></a>09640       {
<a name="l09641"></a>09641         range.upper = current+barWidthHalf;
<a name="l09642"></a>09642         haveUpper = <span class="keyword">true</span>;
<a name="l09643"></a>09643       }
<a name="l09644"></a>09644     }
<a name="l09645"></a>09645     ++it;
<a name="l09646"></a>09646   }
<a name="l09647"></a>09647   
<a name="l09648"></a>09648   validRange = haveLower &amp;&amp; haveUpper;
<a name="l09649"></a>09649   <span class="keywordflow">return</span> range;
<a name="l09650"></a>09650 }
<a name="l09651"></a>09651 
<a name="l09652"></a>09652 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09653"></a>09653 QCPRange QCPBars::getValueRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain)<span class="keyword"> const</span>
<a name="l09654"></a>09654 <span class="keyword"></span>{
<a name="l09655"></a>09655   QCPRange range;
<a name="l09656"></a>09656   <span class="keywordtype">bool</span> haveLower = <span class="keyword">true</span>; <span class="comment">// set to true, because 0 should always be visible in bar charts</span>
<a name="l09657"></a>09657   <span class="keywordtype">bool</span> haveUpper = <span class="keyword">true</span>; <span class="comment">// set to true, because 0 should always be visible in bar charts</span>
<a name="l09658"></a>09658   
<a name="l09659"></a>09659   <span class="keywordtype">double</span> current;
<a name="l09660"></a>09660   
<a name="l09661"></a>09661   QCPBarDataMap::const_iterator it = mData-&gt;constBegin();
<a name="l09662"></a>09662   <span class="keywordflow">while</span> (it != mData-&gt;constEnd())
<a name="l09663"></a>09663   {
<a name="l09664"></a>09664     current = it.value().value + getBaseValue(it.value().key, it.value().value &gt;= 0);
<a name="l09665"></a>09665     <span class="keywordflow">if</span> (inSignDomain == sdBoth || (inSignDomain == sdNegative &amp;&amp; current &lt; 0) || (inSignDomain == sdPositive &amp;&amp; current &gt; 0))
<a name="l09666"></a>09666     {
<a name="l09667"></a>09667       <span class="keywordflow">if</span> (current &lt; range.lower || !haveLower)
<a name="l09668"></a>09668       {
<a name="l09669"></a>09669         range.lower = current;
<a name="l09670"></a>09670         haveLower = <span class="keyword">true</span>;
<a name="l09671"></a>09671       }
<a name="l09672"></a>09672       <span class="keywordflow">if</span> (current &gt; range.upper || !haveUpper)
<a name="l09673"></a>09673       {
<a name="l09674"></a>09674         range.upper = current;
<a name="l09675"></a>09675         haveUpper = <span class="keyword">true</span>;
<a name="l09676"></a>09676       }
<a name="l09677"></a>09677     }
<a name="l09678"></a>09678     ++it;
<a name="l09679"></a>09679   }
<a name="l09680"></a>09680   
<a name="l09681"></a>09681   validRange = !qFuzzyCompare(range.lower+1.0, range.upper+1.0);
<a name="l09682"></a>09682   <span class="keywordflow">return</span> range;
<a name="l09683"></a>09683 }
<a name="l09684"></a>09684 
<a name="l09685"></a>09685 
<a name="l09686"></a>09686 <span class="comment">// ================================================================================</span>
<a name="l09687"></a>09687 <span class="comment">// =================== QCPStatisticalBox</span>
<a name="l09688"></a>09688 <span class="comment">// ================================================================================</span>
<a name="l09750"></a>09750 <span class="comment"></span>QCPStatisticalBox::QCPStatisticalBox(QCPAxis *keyAxis, QCPAxis *valueAxis) :
<a name="l09751"></a>09751   QCPAbstractPlottable(keyAxis, valueAxis),
<a name="l09752"></a>09752   mKey(0),
<a name="l09753"></a>09753   mMinimum(0),
<a name="l09754"></a>09754   mLowerQuartile(0),
<a name="l09755"></a>09755   mMedian(0),
<a name="l09756"></a>09756   mUpperQuartile(0),
<a name="l09757"></a>09757   mMaximum(0)
<a name="l09758"></a>09758 {
<a name="l09759"></a>09759   QPen whiskerPen;
<a name="l09760"></a>09760   whiskerPen.setStyle(Qt::DashLine);
<a name="l09761"></a>09761   whiskerPen.setCapStyle(Qt::FlatCap);
<a name="l09762"></a>09762   setWhiskerPen(whiskerPen);
<a name="l09763"></a>09763   setWhiskerWidth(0.2);
<a name="l09764"></a>09764   
<a name="l09765"></a>09765   QPen medianPen;
<a name="l09766"></a>09766   medianPen.setWidthF(3);
<a name="l09767"></a>09767   medianPen.setCapStyle(Qt::FlatCap);
<a name="l09768"></a>09768   setMedianPen(medianPen);
<a name="l09769"></a>09769   
<a name="l09770"></a>09770   setBrush(Qt::NoBrush);
<a name="l09771"></a>09771   setWidth(0.5);
<a name="l09772"></a>09772   
<a name="l09773"></a>09773   QPen outlierPen;
<a name="l09774"></a>09774   outlierPen.setColor(Qt::blue);
<a name="l09775"></a>09775   setOutlierPen(outlierPen);
<a name="l09776"></a>09776   setOutlierBrush(Qt::NoBrush);
<a name="l09777"></a>09777   setOutlierSize(5);
<a name="l09778"></a>09778   
<a name="l09779"></a>09779   mSelectedPen = mPen;
<a name="l09780"></a>09780   mSelectedPen.setWidthF(2.5);
<a name="l09781"></a>09781   mSelectedPen.setColor(QColor(80, 80, 255));
<a name="l09782"></a>09782   mSelectedBrush = mBrush;
<a name="l09783"></a>09783 }
<a name="l09784"></a>09784 
<a name="l09785"></a>09785 QCPStatisticalBox::~QCPStatisticalBox()
<a name="l09786"></a>09786 {
<a name="l09787"></a>09787 }
<a name="l09788"></a>09788 
<a name="l09792"></a>09792 <span class="keywordtype">void</span> QCPStatisticalBox::setKey(<span class="keywordtype">double</span> key)
<a name="l09793"></a>09793 {
<a name="l09794"></a>09794   mKey = key;
<a name="l09795"></a>09795 }
<a name="l09796"></a>09796 
<a name="l09803"></a>09803 <span class="keywordtype">void</span> QCPStatisticalBox::setMinimum(<span class="keywordtype">double</span> value)
<a name="l09804"></a>09804 {
<a name="l09805"></a>09805   mMinimum = value;
<a name="l09806"></a>09806 }
<a name="l09807"></a>09807 
<a name="l09815"></a>09815 <span class="keywordtype">void</span> QCPStatisticalBox::setLowerQuartile(<span class="keywordtype">double</span> value)
<a name="l09816"></a>09816 {
<a name="l09817"></a>09817   mLowerQuartile = value;
<a name="l09818"></a>09818 }
<a name="l09819"></a>09819 
<a name="l09827"></a>09827 <span class="keywordtype">void</span> QCPStatisticalBox::setMedian(<span class="keywordtype">double</span> value)
<a name="l09828"></a>09828 {
<a name="l09829"></a>09829   mMedian = value;
<a name="l09830"></a>09830 }
<a name="l09831"></a>09831 
<a name="l09839"></a>09839 <span class="keywordtype">void</span> QCPStatisticalBox::setUpperQuartile(<span class="keywordtype">double</span> value)
<a name="l09840"></a>09840 {
<a name="l09841"></a>09841   mUpperQuartile = value;
<a name="l09842"></a>09842 }
<a name="l09843"></a>09843 
<a name="l09850"></a>09850 <span class="keywordtype">void</span> QCPStatisticalBox::setMaximum(<span class="keywordtype">double</span> value)
<a name="l09851"></a>09851 {
<a name="l09852"></a>09852   mMaximum = value;
<a name="l09853"></a>09853 }
<a name="l09854"></a>09854 
<a name="l09862"></a>09862 <span class="keywordtype">void</span> QCPStatisticalBox::setOutliers(<span class="keyword">const</span> QVector&lt;double&gt; &amp;values)
<a name="l09863"></a>09863 {
<a name="l09864"></a>09864   mOutliers = values;
<a name="l09865"></a>09865 }
<a name="l09866"></a>09866 
<a name="l09872"></a>09872 <span class="keywordtype">void</span> QCPStatisticalBox::setData(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> minimum, <span class="keywordtype">double</span> lowerQuartile, <span class="keywordtype">double</span> median, <span class="keywordtype">double</span> upperQuartile, <span class="keywordtype">double</span> maximum)
<a name="l09873"></a>09873 {
<a name="l09874"></a>09874   setKey(key);
<a name="l09875"></a>09875   setMinimum(minimum);
<a name="l09876"></a>09876   setLowerQuartile(lowerQuartile);
<a name="l09877"></a>09877   setMedian(median);
<a name="l09878"></a>09878   setUpperQuartile(upperQuartile);
<a name="l09879"></a>09879   setMaximum(maximum);
<a name="l09880"></a>09880 }
<a name="l09881"></a>09881 
<a name="l09887"></a>09887 <span class="keywordtype">void</span> QCPStatisticalBox::setWidth(<span class="keywordtype">double</span> width)
<a name="l09888"></a>09888 {
<a name="l09889"></a>09889   mWidth = width;
<a name="l09890"></a>09890 }
<a name="l09891"></a>09891 
<a name="l09897"></a>09897 <span class="keywordtype">void</span> QCPStatisticalBox::setWhiskerWidth(<span class="keywordtype">double</span> width)
<a name="l09898"></a>09898 {
<a name="l09899"></a>09899   mWhiskerWidth = width;
<a name="l09900"></a>09900 }
<a name="l09901"></a>09901 
<a name="l09910"></a>09910 <span class="keywordtype">void</span> QCPStatisticalBox::setWhiskerPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l09911"></a>09911 {
<a name="l09912"></a>09912   mWhiskerPen = pen;
<a name="l09913"></a>09913 }
<a name="l09914"></a>09914 
<a name="l09921"></a>09921 <span class="keywordtype">void</span> QCPStatisticalBox::setWhiskerBarPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l09922"></a>09922 {
<a name="l09923"></a>09923   mWhiskerBarPen = pen;
<a name="l09924"></a>09924 }
<a name="l09925"></a>09925 
<a name="l09932"></a>09932 <span class="keywordtype">void</span> QCPStatisticalBox::setMedianPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l09933"></a>09933 {
<a name="l09934"></a>09934   mMedianPen = pen;
<a name="l09935"></a>09935 }
<a name="l09936"></a>09936 
<a name="l09942"></a>09942 <span class="keywordtype">void</span> QCPStatisticalBox::setOutlierSize(<span class="keywordtype">double</span> pixels)
<a name="l09943"></a>09943 {
<a name="l09944"></a>09944   mOutlierSize = pixels;
<a name="l09945"></a>09945 }
<a name="l09946"></a>09946 
<a name="l09952"></a>09952 <span class="keywordtype">void</span> QCPStatisticalBox::setOutlierPen(<span class="keyword">const</span> QPen &amp;pen)
<a name="l09953"></a>09953 {
<a name="l09954"></a>09954   mOutlierPen = pen;
<a name="l09955"></a>09955 }
<a name="l09956"></a>09956 
<a name="l09962"></a>09962 <span class="keywordtype">void</span> QCPStatisticalBox::setOutlierBrush(<span class="keyword">const</span> QBrush &amp;brush)
<a name="l09963"></a>09963 {
<a name="l09964"></a>09964   mOutlierBrush = brush;
<a name="l09965"></a>09965 }
<a name="l09966"></a>09966 
<a name="l09967"></a>09967 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09968"></a>09968 <span class="keywordtype">void</span> QCPStatisticalBox::clearData()
<a name="l09969"></a>09969 {
<a name="l09970"></a>09970   setOutliers(QVector&lt;double&gt;());
<a name="l09971"></a>09971   setKey(0);
<a name="l09972"></a>09972   setMinimum(0);
<a name="l09973"></a>09973   setLowerQuartile(0);
<a name="l09974"></a>09974   setMedian(0);
<a name="l09975"></a>09975   setUpperQuartile(0);
<a name="l09976"></a>09976   setMaximum(0);
<a name="l09977"></a>09977 }
<a name="l09978"></a>09978 
<a name="l09979"></a>09979 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09980"></a>09980 <span class="keywordtype">double</span> QCPStatisticalBox::selectTest(<span class="keywordtype">double</span> key, <span class="keywordtype">double</span> value)<span class="keyword"> const</span>
<a name="l09981"></a>09981 <span class="keyword"></span>{
<a name="l09982"></a>09982   <span class="comment">// quartile box:</span>
<a name="l09983"></a>09983   QCPRange keyRange(mKey-mWidth*0.5, mKey+mWidth*0.5);
<a name="l09984"></a>09984   QCPRange valueRange(mLowerQuartile, mUpperQuartile);
<a name="l09985"></a>09985   <span class="keywordflow">if</span> (keyRange.contains(key) &amp;&amp; valueRange.contains(value))
<a name="l09986"></a>09986     <span class="keywordflow">return</span> mParentPlot-&gt;selectionTolerance()*0.99;
<a name="l09987"></a>09987   
<a name="l09988"></a>09988   <span class="comment">// min/max whiskers:</span>
<a name="l09989"></a>09989   <span class="keywordflow">if</span> (QCPRange(mMinimum, mMaximum).contains(value))
<a name="l09990"></a>09990     <span class="keywordflow">return</span> qAbs(mKeyAxis-&gt;coordToPixel(mKey)-mKeyAxis-&gt;coordToPixel(key));
<a name="l09991"></a>09991   
<a name="l09992"></a>09992   <span class="keywordflow">return</span> -1;
<a name="l09993"></a>09993 }
<a name="l09994"></a>09994 
<a name="l09995"></a>09995 <span class="comment">/* inherits documentation from base class */</span>
<a name="l09996"></a>09996 <span class="keywordtype">void</span> QCPStatisticalBox::draw(QPainter *painter)<span class="keyword"> const</span>
<a name="l09997"></a>09997 <span class="keyword"></span>{
<a name="l09998"></a>09998   <span class="keywordflow">if</span> (!mVisible) <span class="keywordflow">return</span>;
<a name="l09999"></a>09999   painter-&gt;setClipRect(mKeyAxis-&gt;axisRect() | mValueAxis-&gt;axisRect());
<a name="l10000"></a>10000   
<a name="l10001"></a>10001   painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l10002"></a>10002   drawQuartileBox(painter);
<a name="l10003"></a>10003   drawMedian(painter);
<a name="l10004"></a>10004   drawWhiskers(painter);
<a name="l10005"></a>10005   drawOutliers(painter);
<a name="l10006"></a>10006 }
<a name="l10007"></a>10007 
<a name="l10008"></a>10008 <span class="comment">/* inherits documentation from base class */</span>
<a name="l10009"></a>10009 <span class="keywordtype">void</span> QCPStatisticalBox::drawLegendIcon(QPainter *painter, <span class="keyword">const</span> QRect &amp;rect)<span class="keyword"> const</span>
<a name="l10010"></a>10010 <span class="keyword"></span>{
<a name="l10011"></a>10011   <span class="comment">// draw filled rect:</span>
<a name="l10012"></a>10012   painter-&gt;setRenderHint(QPainter::Antialiasing, mParentPlot-&gt;antialiasedElements().testFlag(QCustomPlot::aeGraphs));
<a name="l10013"></a>10013   painter-&gt;setPen(mPen);
<a name="l10014"></a>10014   painter-&gt;setBrush(mBrush);
<a name="l10015"></a>10015   QRect r = QRect(0, 0, rect.width()*0.67, rect.height()*0.67);
<a name="l10016"></a>10016   r.moveCenter(rect.center());
<a name="l10017"></a>10017   painter-&gt;drawRect(r);
<a name="l10018"></a>10018 }
<a name="l10019"></a>10019 
<a name="l10024"></a>10024 <span class="keywordtype">void</span> QCPStatisticalBox::drawQuartileBox(QPainter *painter)<span class="keyword"> const</span>
<a name="l10025"></a>10025 <span class="keyword"></span>{
<a name="l10026"></a>10026   QRectF box;
<a name="l10027"></a>10027   box.setTopLeft(coordsToPixels(mKey-mWidth*0.5, mUpperQuartile));
<a name="l10028"></a>10028   box.setBottomRight(coordsToPixels(mKey+mWidth*0.5, mLowerQuartile));
<a name="l10029"></a>10029   painter-&gt;setPen(mainPen());
<a name="l10030"></a>10030   painter-&gt;setBrush(mainBrush());
<a name="l10031"></a>10031   painter-&gt;drawRect(box);
<a name="l10032"></a>10032 }
<a name="l10033"></a>10033 
<a name="l10038"></a>10038 <span class="keywordtype">void</span> QCPStatisticalBox::drawMedian(QPainter *painter)<span class="keyword"> const</span>
<a name="l10039"></a>10039 <span class="keyword"></span>{
<a name="l10040"></a>10040   QLineF medianLine;
<a name="l10041"></a>10041   medianLine.setP1(coordsToPixels(mKey-mWidth*0.5, mMedian));
<a name="l10042"></a>10042   medianLine.setP2(coordsToPixels(mKey+mWidth*0.5, mMedian));
<a name="l10043"></a>10043   painter-&gt;setPen(mMedianPen);
<a name="l10044"></a>10044   painter-&gt;drawLine(medianLine);
<a name="l10045"></a>10045 }
<a name="l10046"></a>10046 
<a name="l10051"></a>10051 <span class="keywordtype">void</span> QCPStatisticalBox::drawWhiskers(QPainter *painter)<span class="keyword"> const</span>
<a name="l10052"></a>10052 <span class="keyword"></span>{
<a name="l10053"></a>10053   QLineF backboneMin, backboneMax, barMin, barMax;
<a name="l10054"></a>10054   backboneMax.setPoints(coordsToPixels(mKey, mUpperQuartile), coordsToPixels(mKey, mMaximum));
<a name="l10055"></a>10055   backboneMin.setPoints(coordsToPixels(mKey, mLowerQuartile), coordsToPixels(mKey, mMinimum));
<a name="l10056"></a>10056   barMax.setPoints(coordsToPixels(mKey-mWhiskerWidth*0.5, mMaximum), coordsToPixels(mKey+mWhiskerWidth*0.5, mMaximum));
<a name="l10057"></a>10057   barMin.setPoints(coordsToPixels(mKey-mWhiskerWidth*0.5, mMinimum), coordsToPixels(mKey+mWhiskerWidth*0.5, mMinimum));
<a name="l10058"></a>10058   painter-&gt;setPen(mWhiskerPen);
<a name="l10059"></a>10059   painter-&gt;drawLine(backboneMin);
<a name="l10060"></a>10060   painter-&gt;drawLine(backboneMax);
<a name="l10061"></a>10061   painter-&gt;setPen(mWhiskerBarPen);
<a name="l10062"></a>10062   painter-&gt;drawLine(barMin);
<a name="l10063"></a>10063   painter-&gt;drawLine(barMax);
<a name="l10064"></a>10064 }
<a name="l10065"></a>10065 
<a name="l10070"></a>10070 <span class="keywordtype">void</span> QCPStatisticalBox::drawOutliers(QPainter *painter)<span class="keyword"> const</span>
<a name="l10071"></a>10071 <span class="keyword"></span>{
<a name="l10072"></a>10072   painter-&gt;setPen(mOutlierPen);
<a name="l10073"></a>10073   painter-&gt;setBrush(mOutlierBrush);
<a name="l10074"></a>10074   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mOutliers.size(); ++i)
<a name="l10075"></a>10075     painter-&gt;drawEllipse(coordsToPixels(mKey, mOutliers.at(i)), mOutlierSize*0.5, mOutlierSize*0.5);
<a name="l10076"></a>10076 }
<a name="l10077"></a>10077 
<a name="l10078"></a>10078 <span class="comment">/* inherits documentation from base class */</span>
<a name="l10079"></a>10079 QCPRange QCPStatisticalBox::getKeyRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain)<span class="keyword"> const</span>
<a name="l10080"></a>10080 <span class="keyword"></span>{
<a name="l10081"></a>10081   validRange = mWidth &gt; 0;
<a name="l10082"></a>10082   <span class="keywordflow">if</span> (inSignDomain == sdBoth)
<a name="l10083"></a>10083   {
<a name="l10084"></a>10084     <span class="keywordflow">return</span> QCPRange(mKey-mWidth*0.5, mKey+mWidth*0.5);
<a name="l10085"></a>10085   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inSignDomain == sdNegative)
<a name="l10086"></a>10086   {
<a name="l10087"></a>10087     <span class="keywordflow">if</span> (mKey+mWidth*0.5 &lt; 0)
<a name="l10088"></a>10088       <span class="keywordflow">return</span> QCPRange(mKey-mWidth*0.5, mKey+mWidth*0.5);
<a name="l10089"></a>10089     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKey &lt; 0)
<a name="l10090"></a>10090       <span class="keywordflow">return</span> QCPRange(mKey-mWidth*0.5, mKey);
<a name="l10091"></a>10091     <span class="keywordflow">else</span>
<a name="l10092"></a>10092     {
<a name="l10093"></a>10093       validRange = <span class="keyword">false</span>;
<a name="l10094"></a>10094       <span class="keywordflow">return</span> QCPRange();
<a name="l10095"></a>10095     }
<a name="l10096"></a>10096   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inSignDomain == sdPositive)
<a name="l10097"></a>10097   {
<a name="l10098"></a>10098     <span class="keywordflow">if</span> (mKey-mWidth*0.5 &gt; 0)
<a name="l10099"></a>10099       <span class="keywordflow">return</span> QCPRange(mKey-mWidth*0.5, mKey+mWidth*0.5);
<a name="l10100"></a>10100     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mKey &gt; 0)
<a name="l10101"></a>10101       <span class="keywordflow">return</span> QCPRange(mKey, mKey+mWidth*0.5);
<a name="l10102"></a>10102     <span class="keywordflow">else</span>
<a name="l10103"></a>10103     {
<a name="l10104"></a>10104       validRange = <span class="keyword">false</span>;
<a name="l10105"></a>10105       <span class="keywordflow">return</span> QCPRange();
<a name="l10106"></a>10106     }
<a name="l10107"></a>10107   }
<a name="l10108"></a>10108   validRange = <span class="keyword">false</span>;
<a name="l10109"></a>10109   <span class="keywordflow">return</span> QCPRange();
<a name="l10110"></a>10110 }
<a name="l10111"></a>10111 
<a name="l10112"></a>10112 <span class="comment">/* inherits documentation from base class */</span>
<a name="l10113"></a>10113 QCPRange QCPStatisticalBox::getValueRange(<span class="keywordtype">bool</span> &amp;validRange, SignDomain inSignDomain)<span class="keyword"> const</span>
<a name="l10114"></a>10114 <span class="keyword"></span>{
<a name="l10115"></a>10115   <span class="keywordflow">if</span> (inSignDomain == sdBoth)
<a name="l10116"></a>10116   {
<a name="l10117"></a>10117     <span class="keywordtype">double</span> lower = qMin(mMinimum, qMin(mMedian, mLowerQuartile));
<a name="l10118"></a>10118     <span class="keywordtype">double</span> upper = qMax(mMaximum, qMax(mMedian, mUpperQuartile));
<a name="l10119"></a>10119     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;mOutliers.size(); ++i)
<a name="l10120"></a>10120     {
<a name="l10121"></a>10121       <span class="keywordflow">if</span> (mOutliers.at(i) &lt; lower)
<a name="l10122"></a>10122         lower = mOutliers.at(i);
<a name="l10123"></a>10123       <span class="keywordflow">if</span> (mOutliers.at(i) &gt; upper)
<a name="l10124"></a>10124         upper = mOutliers.at(i);
<a name="l10125"></a>10125     }
<a name="l10126"></a>10126     validRange = upper &gt; lower;
<a name="l10127"></a>10127     <span class="keywordflow">return</span> QCPRange(lower, upper);
<a name="l10128"></a>10128   } <span class="keywordflow">else</span>
<a name="l10129"></a>10129   {
<a name="l10130"></a>10130     QVector&lt;double&gt; values; <span class="comment">// values that must be considered (i.e. all outliers and the five box-parameters)</span>
<a name="l10131"></a>10131     values.reserve(mOutliers.size() + 5);
<a name="l10132"></a>10132     values &lt;&lt; mMaximum &lt;&lt; mUpperQuartile &lt;&lt; mMedian &lt;&lt; mLowerQuartile &lt;&lt; mMinimum;
<a name="l10133"></a>10133     values &lt;&lt; mOutliers;
<a name="l10134"></a>10134     <span class="comment">// go through values and find the ones in legal range:</span>
<a name="l10135"></a>10135     <span class="keywordtype">bool</span> haveUpper = <span class="keyword">false</span>;
<a name="l10136"></a>10136     <span class="keywordtype">bool</span> haveLower = <span class="keyword">false</span>;
<a name="l10137"></a>10137     <span class="keywordtype">double</span> upper = 0;
<a name="l10138"></a>10138     <span class="keywordtype">double</span> lower = 0;
<a name="l10139"></a>10139     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;values.size(); ++i)
<a name="l10140"></a>10140     {
<a name="l10141"></a>10141       <span class="keywordflow">if</span> ((inSignDomain == sdNegative &amp;&amp; values.at(i) &lt; 0) ||
<a name="l10142"></a>10142           (inSignDomain == sdPositive &amp;&amp; values.at(i) &gt; 0))
<a name="l10143"></a>10143       {
<a name="l10144"></a>10144         <span class="keywordflow">if</span> (values.at(i) &gt; upper || !haveUpper)
<a name="l10145"></a>10145         {
<a name="l10146"></a>10146           upper = values.at(i);
<a name="l10147"></a>10147           haveUpper = <span class="keyword">true</span>;
<a name="l10148"></a>10148         }
<a name="l10149"></a>10149         <span class="keywordflow">if</span> (values.at(i) &lt; lower || !haveLower)
<a name="l10150"></a>10150         {
<a name="l10151"></a>10151           lower = values.at(i);
<a name="l10152"></a>10152           haveLower = <span class="keyword">true</span>;
<a name="l10153"></a>10153         }
<a name="l10154"></a>10154       }
<a name="l10155"></a>10155     }
<a name="l10156"></a>10156     <span class="comment">// return the bounds if we found some sensible values:</span>
<a name="l10157"></a>10157     <span class="keywordflow">if</span> (haveLower &amp;&amp; haveUpper &amp;&amp; !qFuzzyCompare(upper+1.0, lower+1.0))
<a name="l10158"></a>10158     {
<a name="l10159"></a>10159       validRange = <span class="keyword">true</span>;
<a name="l10160"></a>10160       <span class="keywordflow">return</span> QCPRange(lower, upper);
<a name="l10161"></a>10161     } <span class="keywordflow">else</span>
<a name="l10162"></a>10162     {
<a name="l10163"></a>10163       validRange = <span class="keyword">false</span>;
<a name="l10164"></a>10164       <span class="keywordflow">return</span> QCPRange();
<a name="l10165"></a>10165     }
<a name="l10166"></a>10166   }
<a name="l10167"></a>10167 }
<a name="l10168"></a>10168 
<a name="l10169"></a>10169 
<a name="l10170"></a>10170 
<a name="l10171"></a>10171 
<a name="l10172"></a>10172 
<a name="l10173"></a>10173 
<a name="l10174"></a>10174 
<a name="l10175"></a>10175 
<a name="l10176"></a>10176 
<a name="l10177"></a>10177 
<a name="l10178"></a>10178 
<a name="l10179"></a>10179 
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Nov 13 2012 20:03:29 for SpinToolBox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
